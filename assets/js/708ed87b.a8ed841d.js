"use strict";(self.webpackChunkpop_gen_jl=self.webpackChunkpop_gen_jl||[]).push([[9139],{4137:function(e,a,t){t.d(a,{Zo:function(){return s},kt:function(){return f}});var n=t(7294);function o(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){o(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,o=function(e,a){if(null==e)return{};var t,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(o[t]=e[t]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=n.createContext({}),p=function(e){var a=n.useContext(u),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},s=function(e){var a=p(e.components);return n.createElement(u.Provider,{value:a},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,o=e.mdxType,r=e.originalType,u=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),c=p(t),d=o,f=c["".concat(u,".").concat(d)]||c[d]||m[d]||r;return t?n.createElement(f,l(l({ref:a},s),{},{components:t})):n.createElement(f,l({ref:a},s))}));function f(e,a){var t=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var r=t.length,l=new Array(r);l[0]=d;var i={};for(var u in a)hasOwnProperty.call(a,u)&&(i[u]=a[u]);i.originalType=e,i[c]="string"==typeof e?e:o,l[1]=i;for(var p=2;p<r;p++)l[p]=t[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},425:function(e,a,t){t.d(a,{Z:function(){return l}});var n=t(7294),o=t(6010),r={tabItem:"tabItem_Ymn6"};function l(e){var a=e.children,t=e.hidden,l=e.className;return n.createElement("div",{role:"tabpanel",className:(0,o.Z)(r.tabItem,l),hidden:t},a)}},3992:function(e,a,t){t.d(a,{Z:function(){return N}});var n=t(7462),o=t(7294),r=t(6010),l=t(2957),i=t(6550),u=t(5238),p=t(3609),s=t(2560);function c(e){return function(e){var a,t;return null!=(a=null==(t=o.Children.map(e,(function(e){if(!e||(0,o.isValidElement)(e)&&(a=e.props)&&"object"==typeof a&&"value"in a)return e;var a;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?a:[]}(e).map((function(e){var a=e.props;return{value:a.value,label:a.label,attributes:a.attributes,default:a.default}}))}function m(e){var a=e.values,t=e.children;return(0,o.useMemo)((function(){var e=null!=a?a:c(t);return function(e){var a=(0,p.l)(e,(function(e,a){return e.value===a.value}));if(a.length>0)throw new Error('Docusaurus error: Duplicate values "'+a.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[a,t])}function d(e){var a=e.value;return e.tabValues.some((function(e){return e.value===a}))}function f(e){var a=e.queryString,t=void 0!==a&&a,n=e.groupId,r=(0,i.k6)(),l=function(e){var a=e.queryString,t=void 0!==a&&a,n=e.groupId;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=n?n:null}({queryString:t,groupId:n});return[(0,u._X)(l),(0,o.useCallback)((function(e){if(l){var a=new URLSearchParams(r.location.search);a.set(l,e),r.replace(Object.assign({},r.location,{search:a.toString()}))}}),[l,r])]}function h(e){var a,t,n,r,l=e.defaultValue,i=e.queryString,u=void 0!==i&&i,p=e.groupId,c=m(e),h=(0,o.useState)((function(){return function(e){var a,t=e.defaultValue,n=e.tabValues;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+n.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}var o=null!=(a=n.find((function(e){return e.default})))?a:n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:l,tabValues:c})})),v=h[0],g=h[1],k=f({queryString:u,groupId:p}),b=k[0],y=k[1],N=(a=function(e){return e?"docusaurus.tab."+e:null}({groupId:p}.groupId),t=(0,s.Nk)(a),n=t[0],r=t[1],[n,(0,o.useCallback)((function(e){a&&r.set(e)}),[a,r])]),w=N[0],C=N[1],j=function(){var e=null!=b?b:w;return d({value:e,tabValues:c})?e:null}();return(0,o.useLayoutEffect)((function(){j&&g(j)}),[j]),{selectedValue:v,selectValue:(0,o.useCallback)((function(e){if(!d({value:e,tabValues:c}))throw new Error("Can't select invalid tab value="+e);g(e),y(e),C(e)}),[y,C,c]),tabValues:c}}var v=t(1048),g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function k(e){var a=e.className,t=e.block,i=e.selectedValue,u=e.selectValue,p=e.tabValues,s=[],c=(0,l.o5)().blockElementScrollPositionUntilNextRender,m=function(e){var a=e.currentTarget,t=s.indexOf(a),n=p[t].value;n!==i&&(c(a),u(n))},d=function(e){var a,t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":var n,o=s.indexOf(e.currentTarget)+1;t=null!=(n=s[o])?n:s[0];break;case"ArrowLeft":var r,l=s.indexOf(e.currentTarget)-1;t=null!=(r=s[l])?r:s[s.length-1]}null==(a=t)||a.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},a)},p.map((function(e){var a=e.value,t=e.label,l=e.attributes;return o.createElement("li",(0,n.Z)({role:"tab",tabIndex:i===a?0:-1,"aria-selected":i===a,key:a,ref:function(e){return s.push(e)},onKeyDown:d,onClick:m},l,{className:(0,r.Z)("tabs__item",g.tabItem,null==l?void 0:l.className,{"tabs__item--active":i===a})}),null!=t?t:a)})))}function b(e){var a=e.lazy,t=e.children,n=e.selectedValue,r=(Array.isArray(t)?t:[t]).filter(Boolean);if(a){var l=r.find((function(e){return e.props.value===n}));return l?(0,o.cloneElement)(l,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map((function(e,a){return(0,o.cloneElement)(e,{key:a,hidden:e.props.value!==n})})))}function y(e){var a=h(e);return o.createElement("div",{className:(0,r.Z)("tabs-container",g.tabList)},o.createElement(k,(0,n.Z)({},e,a)),o.createElement(b,(0,n.Z)({},e,a)))}function N(e){var a=(0,v.Z)();return o.createElement(y,(0,n.Z)({key:String(a)},e))}},368:function(e,a,t){t.r(a),t.d(a,{assets:function(){return m},contentTitle:function(){return s},default:function(){return v},frontMatter:function(){return p},metadata:function(){return c},toc:function(){return d}});var n=t(7462),o=t(3366),r=(t(7294),t(4137)),l=t(3992),i=t(425),u=["components"],p={id:"populationdata",title:"Population data",sidebar_label:"Population data"},s=void 0,c={unversionedId:"popdata/populationdata",id:"popdata/populationdata",title:"Population data",description:"Needless to say, population information is crucial for population genetics, so there are several handy tools for dealing with that information.",source:"@site/docs/popdata/populationdata.md",sourceDirName:"popdata",slug:"/popdata/populationdata",permalink:"/PopGen.jl/docs/popdata/populationdata",draft:!1,editUrl:"https://github.com/BioJulia/PopGen.jl/edit/documentation/docs/popdata/populationdata.md",tags:[],version:"current",lastUpdatedAt:1646148647,formattedLastUpdatedAt:"Mar 1, 2022",frontMatter:{id:"populationdata",title:"Population data",sidebar_label:"Population data"},sidebar:"docs",previous:{title:"Conditionals",permalink:"/PopGen.jl/docs/popdata/conditionals"},next:{title:"Location data",permalink:"/PopGen.jl/docs/popdata/locationdata"}},m={},d=[{value:"View unique population names",id:"view-unique-population-names",level:3},{value:"Rename populations",id:"rename-populations",level:3}],f={toc:d},h="wrapper";function v(e){var a=e.components,t=(0,o.Z)(e,u);return(0,r.kt)(h,(0,n.Z)({},f,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Needless to say, population information is crucial for population genetics, so there are several handy tools for dealing with that information.\nIf you need to see the population for every sample, then use ",(0,r.kt)("inlineCode",{parentName:"p"},"sampleinfo(popdata)")," to retrieve the dataframe containing sample information."),(0,r.kt)("h3",{id:"view-unique-population-names"},"View unique population names"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"populations(data::PopData; counts::Bool = false)\n")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"counts = false"),", returns a Vector of the unique populations present in the ",(0,r.kt)("inlineCode",{parentName:"p"},"PopData"),". If ",(0,r.kt)("inlineCode",{parentName:"p"},"counts = true"),", returns a\ntable of sample counts per population."),(0,r.kt)(l.Z,{block:!0,defaultValue:"unq",values:[{label:"unique populations",value:"unq"},{label:"counts per population",value:"cou"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"unq",mdxType:"TabItem"},(0,r.kt)("p",null,"Return a vector of the unique populations. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},'julia> populations(sharks)\n7-element Array{String,1}:\n "CapeCanaveral"\n "Georgia"\n "SouthCarolina"\n "FloridaKeys"\n "MideastGulf"\n "NortheastGulf"\n "SoutheastGulf"\n'))),(0,r.kt)(i.Z,{value:"cou",mdxType:"TabItem"},(0,r.kt)("p",null,"Retrun a table of the populations and their counts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"julia> populations(sharks, counts = true)\n7\xd72 DataFrame\n Row \u2502 population      count \n     \u2502 String          Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Cape Canaveral     21\n   2 \u2502 Georgia            30\n   3 \u2502 South Carolina     28\n   4 \u2502 Florida Keys       65\n   5 \u2502 Mideast Gulf       28\n   6 \u2502 Northeast Gulf     20\n   7 \u2502 Southeast Gulf     20\n")))),(0,r.kt)("h3",{id:"rename-populations"},"Rename populations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"populations!(data::PopData, rename::Dict)\npopulations!(data::PopData, rename::Vector{String})\npopulations!(data::PopData, samples::Vector{String}, populations::Vector{String})\n")),(0,r.kt)("p",null,"There are a handful of methods to alter ",(0,r.kt)("inlineCode",{parentName:"p"},"PopData")," population names depending on what you find most convenient. Each of these methods start with ",(0,r.kt)("inlineCode",{parentName:"p"},"populations!()")," and vary in their inputs. It's for that reason this function has an uncharacteristically long docstring. However, all the methods for ",(0,r.kt)("inlineCode",{parentName:"p"},"populations!")," are unified in that they edit ",(0,r.kt)("inlineCode",{parentName:"p"},"PopData")," in place."),(0,r.kt)(l.Z,{block:!0,defaultValue:"dict",values:[{label:"with a Dictionary",value:"dict"},{label:"with a Vector of names",value:"vec"},{label:"reassign by sample",value:"samp"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"dict",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"populations!(data::PopData, rename::Dict)\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Recommended for renaming existing populations\t")),(0,r.kt)("p",null,"Rename existing population ID's of ",(0,r.kt)("inlineCode",{parentName:"p"},"PopData")," using a ",(0,r.kt)("inlineCode",{parentName:"p"},"Dict")," of\n",(0,r.kt)("inlineCode",{parentName:"p"},"population_name => replacement"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},'# create a dictionary of name conversions\njulia> new_popnames = \nDict(\n  "CapeCanaveral" => "Atlantic",\n  "Georgia" => "Atlantic",\n  "SouthCarolina" => "Atlantic",\n  "FloridaKeys" => "Gulf",\n  "MideastGulf" => "Gulf",\n  "NortheastGulf" => "Gulf",\n  "SoutheastGulf" => "Gulf"\n);  \n\njulia> populations!(sharks, new_popnames)\njulia> populations(sharks, counts = true)\n2\xd72 DataFrame\n Row \u2502 population  count \n     \u2502 String      Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Atlantic       79\n   2 \u2502 Gulf          133\n'))),(0,r.kt)(i.Z,{value:"vec",mdxType:"TabItem"},(0,r.kt)("admonition",{title:"not recommended",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"These methods ",(0,r.kt)("em",{parentName:"p"},"are")," available, but the ",(0,r.kt)("inlineCode",{parentName:"p"},"Dict")," method is recommended instead of (1) and the reassign-by-sample method is recommended\ninstead of (2)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"populations!(data::PopData, rename::Vector{String})\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"rename the unique populations",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"condition"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"length(rename) == length(unique(populations))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rename")," is a vector of new unique population names in the order that they appear in ",(0,r.kt)("inlineCode",{parentName:"li"},"sampleinfo(popdata)"),"."))),(0,r.kt)("li",{parentName:"ol"},"rename the population association for every sample",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"condition"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"length(rename) == length(samplenames(data))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rename")," is a vector of new populations names for the samples in the order that they appear in ",(0,r.kt)("inlineCode",{parentName:"li"},"sampleinfo(popdata)"))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},'julia> new_popnames = ["Atlantic", "Atlantic", "Atlantic", "Gulf", "Gulf", "Gulf", "Gulf"] ;\n\njulia> populations!(sharks, new_popnames)\njulia> populations(sharks, counts = true)\n2\xd72 DataFrame\n Row \u2502 population  count \n     \u2502 String      Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Atlantic       79\n   2 \u2502 Gulf          133\n'))),(0,r.kt)(i.Z,{value:"samp",mdxType:"TabItem"},(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Recommended for assigning population ID's for specific samples.\t")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"populations!(data::PopData, samples::Vector{String}, populations::Vector{String})\n")),(0,r.kt)("p",null,"You may want outright overwrite all current population information. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of ",(0,r.kt)("inlineCode",{parentName:"p"},"PopData")," regardless of what they currently are. "),(0,r.kt)("p",null,"This method takes a vector of sample names and a vector of the new population names of the samples in the order that they appear in the name-vector."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},'# creating a vector of sample names\njulia> ch_names = samplenames(sharks)[1:5]\n5-element Array{String,1}:\n "cc_001"\n "cc_002"\n "cc_003"\n "cc_005"\n "cc_007"\n')),(0,r.kt)("p",null,"and we then also create the vector of these samples' new population names:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},'julia> popnames = ["North Cape", "North Cape", "North Cape", "South Cape", "South Cape"] ;\n')),(0,r.kt)("p",null,"Now we can combine them with ",(0,r.kt)("inlineCode",{parentName:"p"},"populations!")," to rename the first 5 Cape Canaveral samples."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"julia> populations!(sharks, ch_names, popnames)\njulia> sampleinfo(sharks)[1:6,:]\n6\xd75 DataFrame\n Row \u2502 name     population     ploidy  longitude  latitude \n     \u2502 String7  String         Int8    Float64    Float64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 cc_001   North Cape          2    28.3062  -80.5993\n   2 \u2502 cc_002   North Cape          2    28.3079  -80.5995\n   3 \u2502 cc_003   North Cape          2    28.3023  -80.5996\n   4 \u2502 cc_005   South Cape          2    28.6123  -80.4225\n   5 \u2502 cc_007   South Cape          2    27.8666  -80.3578\n   6 \u2502 cc_008   CapeCanaveral       2    27.8666  -80.3579\n")))))}v.isMDXComponent=!0}}]);