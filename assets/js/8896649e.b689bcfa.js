"use strict";(self.webpackChunkpop_gen_jl=self.webpackChunkpop_gen_jl||[]).push([[3469],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return c}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),d=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=d(e.components);return i.createElement(p.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=d(n),c=a,k=u["".concat(p,".").concat(c)]||u[c]||s[c]||l;return n?i.createElement(k,r(r({ref:t},m),{},{components:n})):i.createElement(k,r({ref:t},m))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=u;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var d=2;d<l;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6921:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return d},assets:function(){return m},toc:function(){return s},default:function(){return c}});var i=n(7462),a=n(3366),l=(n(7294),n(3905)),r=["components"],o={id:"delimited",title:"Delimited.jl",sidebar_label:"Delimited.jl"},p=void 0,d={unversionedId:"api/PopGenCore/delimited",id:"api/PopGenCore/delimited",title:"Delimited.jl",description:"PopGenCore.jl/src/io/Delimited.jl",source:"@site/docs/api/PopGenCore/Delimited.md",sourceDirName:"api/PopGenCore",slug:"/api/PopGenCore/delimited",permalink:"/PopGen.jl/docs/api/PopGenCore/delimited",editUrl:"https://github.com/BioJulia/PopGen.jl/edit/documentation/docs/api/PopGenCore/Delimited.md",tags:[],version:"current",lastUpdatedAt:1652451030,formattedLastUpdatedAt:"5/13/2022",frontMatter:{id:"delimited",title:"Delimited.jl",sidebar_label:"Delimited.jl"},sidebar:"docs",previous:{title:"Datasets.jl",permalink:"/PopGen.jl/docs/api/PopGenCore/datasets"},next:{title:"Genepop.jl",permalink:"/PopGen.jl/docs/api/PopGenCore/genepop"}},m={},s=[{value:"PopGenCore.jl/src/io/Delimited.jl",id:"popgencorejlsrciodelimitedjl",level:2},{value:"\ud83d\udfea delimited",id:"-delimited",level:3},{value:"Arguments",id:"arguments",level:4},{value:"Keyword Arguments",id:"keyword-arguments",level:4},{value:"File formatting:",id:"file-formatting",level:4},{value:"Missing data",id:"missing-data",level:4},{value:"Genotypes",id:"genotypes",level:5},{value:"Location data",id:"location-data",level:5},{value:"Formatting example",id:"formatting-example",level:4},{value:"Keyword Arguments",id:"keyword-arguments-1",level:4}],u={toc:s};function c(e){var t=e.components,n=(0,a.Z)(e,r);return(0,l.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"popgencorejlsrciodelimitedjl"},"PopGenCore.jl/src/io/Delimited.jl"),(0,l.kt)("p",null,"\ud83d\udce6  => not exported |\n\ud83d\udfea => exported by PopGenCore.jl |\n\ud83d\udd35 => exported by PopGen.jl"),(0,l.kt)("h3",{id:"-delimited"},"\ud83d\udfea delimited"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'delimited(infile::String; delim::Union{Char,String,Regex} = "auto", digits::Int64 = 3, silent::Bool = false)\n')),(0,l.kt)("p",null,"Load a delimited-type file into memory as a PopData object. ",(0,l.kt)("em",{parentName:"p"},"There should be no empty cells\nin your file")),(0,l.kt)("h4",{id:"arguments"},"Arguments"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"infile")," : path to file")),(0,l.kt)("h4",{id:"keyword-arguments"},"Keyword Arguments"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"delim")," : delimiter characters. By default uses auto-parsing of ",(0,l.kt)("inlineCode",{parentName:"li"},"CSV.File")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"digits")," : number of digits denoting each allele (default: ",(0,l.kt)("inlineCode",{parentName:"li"},"3"),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"diploid"),"  : whether samples are diploid for parsing optimizations (default: ",(0,l.kt)("inlineCode",{parentName:"li"},"true"),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"silent"),"   : whether to print file information during import (default: ",(0,l.kt)("inlineCode",{parentName:"li"},"true"),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allow_monomorphic")," : whether to keep monomorphic loci in the dataset (default: ",(0,l.kt)("inlineCode",{parentName:"li"},"false"),")")),(0,l.kt)("h4",{id:"file-formatting"},"File formatting:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The first row is column names (names don't matter)"),(0,l.kt)("li",{parentName:"ul"},"The columns must be in this order:",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"sample name"),(0,l.kt)("li",{parentName:"ol"},"population name"),(0,l.kt)("li",{parentName:"ol"},"longitude"),(0,l.kt)("li",{parentName:"ol"},"latitude"),(0,l.kt)("li",{parentName:"ol"},"locus_1 genotypes"),(0,l.kt)("li",{parentName:"ol"},"locus_2 genotypes"),(0,l.kt)("li",{parentName:"ol"},"etc...")))),(0,l.kt)("h4",{id:"missing-data"},"Missing data"),(0,l.kt)("h5",{id:"genotypes"},"Genotypes"),(0,l.kt)("p",null,"Missing genotypes can be formatted as all-zeros ",(0,l.kt)("inlineCode",{parentName:"p"},"000000"),", left empty, or negative-nine ",(0,l.kt)("inlineCode",{parentName:"p"},"-9")),(0,l.kt)("h5",{id:"location-data"},"Location data"),(0,l.kt)("p",null,"If location data is missing for a sample (which is ok!), make sure the value is\nblank, otherwise there will be transcription errors! (look at line 3 in the example below)"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'lizardsCA = delimited("CA_lizards.csv", digits = 3);\n')),(0,l.kt)("h4",{id:"formatting-example"},"Formatting example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"name,population,long,lat,Locus1,Locus2,Locus3\nsierra_01,mountain,11.11,-22.22,001001,-9,001001\nsierra_02,mountain,11.12,-22.21,001001,001001,001002\nsnbarb_01,coast,,,001001,001001,001002\nsnbarb_02,coast,11.14,-22.24,001001,001001,001001\nsnbarb_03,coast,11.15,,001002,001001,001001\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'lizardsCA = delimited("CA_lizards.csv", digits = 3);\n')),(0,l.kt)("hr",null),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'delimited(data::PopData; filename::String, delim::String = ",", digits::Integer = 3, format::String = "wide")\n')),(0,l.kt)("p",null,"Write PopData to a text-delimited file. "),(0,l.kt)("h4",{id:"keyword-arguments-1"},"Keyword Arguments"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"filename"),": a ",(0,l.kt)("inlineCode",{parentName:"li"},"String")," of the output filename"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"digits")," : an ",(0,l.kt)("inlineCode",{parentName:"li"},"Integer")," indicating how many digits to format each allele as (e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"(1, 2)")," => ",(0,l.kt)("inlineCode",{parentName:"li"},"001002")," for ",(0,l.kt)("inlineCode",{parentName:"li"},"digits = 3"),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"format")," : a ",(0,l.kt)("inlineCode",{parentName:"li"},"String")," indicating whether to output in",(0,l.kt)("inlineCode",{parentName:"li"},'"wide"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"long"')," (aka ",(0,l.kt)("inlineCode",{parentName:"li"},'"tidy"'),") format "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"delim")," : the ",(0,l.kt)("inlineCode",{parentName:"li"},"String")," delimiter to use for writing the file. ")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-julia"},'cats = @nancycats;\nfewer_cats = omit_samplenames(cats, samplenames(cats)[1:10]);\ndelimited(fewer_cats, filename = "filtered_nancycats.csv", digits = 3, format = "wide", delim = " ")\n')))}c.isMDXComponent=!0}}]);