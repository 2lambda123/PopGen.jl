"use strict";(self.webpackChunkpop_gen_jl=self.webpackChunkpop_gen_jl||[]).push([[7214],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return f}});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(t),d=l,f=u["".concat(s,".").concat(d)]||u[d]||m[d]||r;return t?a.createElement(f,i(i({ref:n},c),{},{components:t})):a.createElement(f,i({ref:n},c))}));function f(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,i=new Array(r);i[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[u]="string"==typeof e?e:l,i[1]=o;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2117:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return u}});var a=t(7462),l=t(3366),r=(t(7294),t(3905)),i=["components"],o={id:"allelematrices",title:"AlleleMatrices.jl",sidebar_label:"AlleleMatrices.jl"},s=void 0,p={unversionedId:"api/PopGenCore/allelematrices",id:"api/PopGenCore/allelematrices",title:"AlleleMatrices.jl",description:"PopGenCore.jl/src/AlleleMatrices.jl",source:"@site/docs/api/PopGenCore/AlleleMatrices.md",sourceDirName:"api/PopGenCore",slug:"/api/PopGenCore/allelematrices",permalink:"/PopGen.jl/docs/api/PopGenCore/allelematrices",draft:!1,editUrl:"https://github.com/BioJulia/PopGen.jl/edit/documentation/docs/api/PopGenCore/AlleleMatrices.md",tags:[],version:"current",lastUpdatedAt:1658766707,formattedLastUpdatedAt:"Jul 25, 2022",frontMatter:{id:"allelematrices",title:"AlleleMatrices.jl",sidebar_label:"AlleleMatrices.jl"},sidebar:"docs",previous:{title:"AlleleFreq.jl",permalink:"/PopGen.jl/docs/api/PopGenCore/allelefreq"},next:{title:"Conditionals.jl",permalink:"/PopGen.jl/docs/api/PopGenCore/conditionals"}},c={},u=[{value:"PopGenCore.jl/src/AlleleMatrices.jl",id:"popgencorejlsrcallelematricesjl",level:2},{value:"\ud83d\udfea matrix",id:"-matrix",level:3},{value:"\ud83d\udce6 _setcounts",id:"-_setcounts",level:3},{value:"\ud83d\udce6 _matrix",id:"-_matrix",level:3},{value:"\ud83d\udfea featurematrix",id:"-featurematrix",level:3}],m={toc:u},d="wrapper";function f(e){var n=e.components,t=(0,l.Z)(e,i);return(0,r.kt)(d,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"popgencorejlsrcallelematricesjl"},"PopGenCore.jl/src/AlleleMatrices.jl"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"\ud83d\udce6  not exported"),(0,r.kt)("th",{parentName:"tr",align:"center"},"\ud83d\udfea  exported by PopGenCore.jl"),(0,r.kt)("th",{parentName:"tr",align:"center"},"\ud83d\udd35  exported by PopGen.jl")))),(0,r.kt)("h3",{id:"-matrix"},"\ud83d\udfea matrix"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},'matrix(data::PopData, matrixtype::String = "frequency"; missings = "mean", scale = false, center = false)\n')),(0,r.kt)("p",null,"Return a matrix of allele counts or frequencies per genotype where rows are samples\nand columns are the occurence count or frequency of an allele for that locus in that sample.\nLoci and alleles are sorted alphanumerically. The ",(0,r.kt)("inlineCode",{parentName:"p"},"scale")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"center")," keywords are only relevant for allele frequencies, not counts."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Positional Arguments")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data"),": a PopData object"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"matrixtype"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"String")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Symbol")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"count")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"frequency")," (default: ",(0,r.kt)("inlineCode",{parentName:"li"},"frequency"),")")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Keyword Arguments")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"missings"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"String")," denoting how to handle missing values when outputting ",(0,r.kt)("inlineCode",{parentName:"li"},"frequency")," (default: ",(0,r.kt)("inlineCode",{parentName:"li"},"mean"),")",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'"missing"'),": fallback method to keep ",(0,r.kt)("inlineCode",{parentName:"li"},"missing")," values as they are"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'"zero"'),": replace ",(0,r.kt)("inlineCode",{parentName:"li"},"missing")," values with ",(0,r.kt)("inlineCode",{parentName:"li"},"0")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'"mean"'),": replace ",(0,r.kt)("inlineCode",{parentName:"li"},"missing")," values with the mean frequency for that allele in that locus"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"scale"),": a 'Bool' of whether to z-score scale allele frequencies (default: ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"center"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"Bool")," of whether to center the allele frequencies (default: 'false')")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'julia> cats = @nancycats ;\njulia> cnts = matrix(cats, "count") ;  cnts[1:5,1:6]\n5\xd76 Matrix{Union{Missing, Int8}}:\n  missing   missing   missing   missing   missing   missing\n  missing   missing   missing   missing   missing   missing\n 0         0         0         0         0         0\n 0         0         0         0         0         0\n 0         0         0         0         0         0\n\njulia> frq = matrix(cats, "frequency") ;  frq[1:5,1:6]\n5\xd76 Matrix{Union{Missing, Float32}}:\n 0.00460829  0.00460829  0.0276498  0.133641  0.00460829  0.0921659\n 0.00460829  0.00460829  0.0276498  0.133641  0.00460829  0.0921659\n 0.0         0.0         0.0        0.0       0.0         0.0\n 0.0         0.0         0.0        0.0       0.0         0.0\n 0.0         0.0         0.0        0.0       0.0         0.0\n\njulia> frq = matrix(cats, :frequency, missings = "zero") ;  frq[1:5,1:6]\n 5\xd76 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n \n julia> frq = matrix(cats, missings = "mean", scale = true, center = true) ;  frq[1:5,1:6]\n 5\xd76 Matrix{Float32}:\n  7.17017f-9   7.17017f-9   0.0        0.0        7.17017f-9   0.0\n  7.17017f-9   7.17017f-9   0.0        0.0        7.17017f-9   0.0\n -0.0709577   -0.0709577   -0.175857  -0.394198  -0.0709577   -0.300797\n -0.0709577   -0.0709577   -0.175857  -0.394198  -0.0709577   -0.300797\n -0.07\n')),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-_setcounts"},"\ud83d\udce6 _setcounts"),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-_matrix"},"\ud83d\udce6 _matrix"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"_matrix(data::PopData, ::Val{:count})\n")),(0,r.kt)("p",null,"Create a matrix of allele count per genotype where rows are samples\nand columns are the occurence count of an allele for that locus in that sample.\nMissing values are preserved as ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"_matrix(data::PopData, ::Val{:frequencyzero})\n")),(0,r.kt)("p",null,"Create a matrix of allele frequencies per genotype where rows are samples\nand columns are the frequency of an allele for that locus in that sample.\nMissing values are replaced by zeros."),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"_matrix(data::PopData, ::Val{:frequencymean})\n")),(0,r.kt)("p",null,"Create a matrix of allele frequencies per genotype where rows are samples\nand columns are the frequency of an allele for that locus in that sample.\nMissing values are replaced by the global mean allele frequency."),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"_matrix(data::PopData, ::Val{:frequencymissing})\n")),(0,r.kt)("p",null,"Create a matrix of allele frequencies per genotype where rows are samples\nand columns are the frequency of an allele for that locus in that sample.\nMissing values are kept as ",(0,r.kt)("inlineCode",{parentName:"p"},"missing"),"."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-featurematrix"},"\ud83d\udfea featurematrix"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},'featurematrix(data::PopData, matrixtype::Union{String, Symbol} = "genotype")\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Positional Arguments")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"- `data`: a PopData object\n- `matrixtype`: a `String` or `Symbol` of `genotype`, or `allele` (default: `genotype`)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"genotype feature matrix")),(0,r.kt)("p",null,"Return a matrix of dummy-encoded genotypes (0,1,2...), where rows correspond with samples and columns correspond to loci.\nMissing genotypes are encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),". For biallelic loci, ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," encodes homozygous for allele 1, ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," encodes for a heterozygote,\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," encodes for homozygous allele 2."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"allele feature matrix")),(0,r.kt)("p",null,"Return a matrix of dummy-encoded alleles (0,1), where rows correspond with samples and columns correspond to alleles within loci, such\nthat there are as many columns per locus as alleles for that locus. Missing alleles (from missing genotypes) are encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'julia> cats = @nancycats ;\njulia> featurematrix(cats)\n237\xd79 Matrix{Int8}:\n -1   0   0   0   0  0   0   0   0\n -1   1   1   1   0  0   1   0   0\n  0   0   2   2   1  1   2   0   1\n  1   2   3   3   2  0   0   1   0\n  1   3   4   4   3  0   3   0   0\n  \u22ee                  \u22ee\n 49   0   1  -1  36  0   0  -1  13\n 48   6   8  -1  25  1   2  -1   0\n 29   9  23  -1   7  3  26  14   0\n  3   5   8  -1   2  1   3  14   0\n 29  10  16  -1   4  3   2  -1   0\n\njulia> featurematrix(cats, "allele")\n237\xd7108 Matrix{Int8}:\n -1  -1  -1  -1  -1  \u2026  0  0  0  0  0  0\n -1  -1  -1  -1  -1     0  0  0  0  0  0\n  0   0   0   0   0     0  0  0  0  0  0\n  0   0   0   0   0     0  0  0  0  0  0\n  0   0   0   0   0     0  0  0  0  0  0\n  \u22ee                  \u22f1           \u22ee\n  0   0   0   0   0     0  0  0  1  0  0\n  0   0   0   0   0     0  0  0  0  0  0\n  0   0   0   0   0     0  0  0  0  0  0\n  0   0   0   0   0  \u2026  0  0  0  0  0  0\n  0   0   0   0   0     0  0  0  0  0  0 \n')),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"_featurematrix(data::PopData, ::Val{:genotype})\n")),(0,r.kt)("p",null,"Return a matrix of dummy-encoded genotypes (0,1,2...), where rows correspond with samples and columns correspond to loci.\nMissing genotypes are encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),". For biallelic loci, ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," encodes homozygous for allele 1, ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," encodes for a heterozygote,\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," encodes for homozygous allele 2."),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-julia"},"_featurematrix(data::PopData, ::Val{:allele})\n")),(0,r.kt)("p",null,"Return a matrix of dummy-encoded alleles (0,1,2...), where rows correspond with samples and columns correspond to loci.\nMissing genotypes are encoded as ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),"."))}f.isMDXComponent=!0}}]);