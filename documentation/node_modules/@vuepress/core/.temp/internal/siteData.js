/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "PopGen.jl",
  "description": "Population Genetics in Julia",
  "base": "/",
  "pages": [
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroImage": "/images/logo_banner.png",
        "title": null,
        "heroText": null,
        "heroDescription": null,
        "actionText": "Get Started →",
        "actionLink": "/guide/about",
        "features": [
          {
            "title": "Fast",
            "details": "Python/MATLAB like syntax, with C-like speed."
          },
          {
            "title": "Sane",
            "details": "Sensible function and arguments names, and default settings. Get more done without scratching your head."
          },
          {
            "title": "Transparent",
            "details": "The package is written entirely in Julia, meaning anyone using the package can investigate the internals and root out errors or inconsistencies."
          }
        ],
        "footer": "MIT Licensed | Copyright 2019-present | Pavel Dimens & Jason Selwyn"
      },
      "regularPath": "/",
      "relativePath": "README.md",
      "key": "v-4ba31236",
      "path": "/",
      "headers": [
        {
          "level": 2,
          "title": "Authors",
          "slug": "authors"
        }
      ],
      "content": "---\nhome: true\nheroImage: /images/logo_banner.png\ntitle: null\nheroText: null\nheroDescription: null\nactionText: Get Started →\nactionLink: /guide/about\nfeatures:\n- title: Fast\n  details: Python/MATLAB like syntax, with C-like speed.\n- title: Sane\n  details: Sensible function and arguments names, and default settings. Get more done without scratching your head.\n- title: Transparent\n  details: The package is written entirely in Julia, meaning anyone using the package can investigate the internals and root out errors or inconsistencies. \nfooter: MIT Licensed | Copyright 2019-present | Pavel Dimens & Jason Selwyn\n---\n\nThis is the documentation for the PopGen.jl package. If you're here, you're likely interested in doing some kind of population genetics analyses. Please read through the docs and try the functions out with the test data to get a feel for what PopGen.jl can do. \n\n## Authors\n\n[![alt text](/images/orcid.png)](https://orcid.org/0000-0003-3823-0373) [![alt text](/images/twitter.png)](https://twitter.com/PVDimens) Pavel Dimens, PhD Candidate @ U. Southern Mississippi\n\n[![alt text](/images/orcid.png)](http://orcid.org/0000-0002-9100-217X) [![alt text](/images/twitter.png)](https://twitter.com/JasonSelwyn) Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi \n"
    },
    {
      "title": "Relatedness (Kinship)",
      "frontmatter": {},
      "regularPath": "/analyses/relatedness.html",
      "relativePath": "analyses/relatedness.md",
      "key": "v-d4b54f48",
      "path": "/analyses/relatedness",
      "headers": [
        {
          "level": 3,
          "title": "About removing kin",
          "slug": "about-removing-kin"
        },
        {
          "level": 2,
          "title": "Calculate Relatedness",
          "slug": "calculate-relatedness"
        },
        {
          "level": 3,
          "title": "arguments",
          "slug": "arguments"
        },
        {
          "level": 3,
          "title": "keyword arguments",
          "slug": "keyword-arguments"
        },
        {
          "level": 3,
          "title": "methods",
          "slug": "methods"
        },
        {
          "level": 3,
          "title": "example",
          "slug": "example"
        },
        {
          "level": 2,
          "title": "Speed",
          "slug": "speed"
        },
        {
          "level": 2,
          "title": "Acknowledgements",
          "slug": "acknowledgements"
        }
      ],
      "content": "# Relatedness (Kinship)\n\n**Background**\n\nSometimes you want or need to know the relatedness of individuals in a sample. Relatedness is exactly what its name implies: how related individuals are given some provided genetic information. Relatedness can be used in quantitative genetics to estimate heritability, additive genetic variances, and covariances. It can also be used in population genetics to study isolation-by-distance or population structure.\n\nThe goal of calculating relatedness from molecular markers is to accurately estimate the proportion of the genome which is identical by descent between two individuals. With a pedigree this is \"relatively\" straightforward. However, for large, natural, populations pedigrees tend not to exist and so many brilliant minds have developed various equations and algorithms to estimate the relatedness from a set of molecular markers. Given two diploid individuals, there are 9 \"identity by descent\" models available between them ([Jacquard 1975](https://www.springer.com/gp/book/9783642884177), paywall), as shown below (from [Milligan 2003](https://www.genetics.org/content/163/3/1153.full)):\n\n![Jacquard IBD](/images/jacquard_identitiies.jpg)\n\nBroadly speaking there are two different ways of estimating genetic relatedness using molecular markers, methods of moments, and likelihood estimators. Generally moments estimators will be faster but aren't constrained to being between the theoretical minimum and maximum values of 0 and 1. The likelihood estimators use likelihood functions derived from the set of Jacquard Identity States (above) to determine the most likely inheritance pattern. One difference between the two classes is [generally] moments estimators require an assumption of no inbreeding, while that assumption isn't necessarily required for likelihood estimators (though it does simplify the math). It is increasingly common to use multiple estimators on pairs, simulated from your molecular marker, with a known relationships to determine the most appropriate estimator to use with your given data.\n\nPopGen.jl currently implements one of each class of estimator. The moments based estimator developed by [Queller & Goodnight 1989](https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1558-5646.1989.tb04226.x) using the variant defined by [Lynch & Ritland 1999](https://www.genetics.org/content/152/4/1753.full) and the likelihood estimator created by [Milligan 2003](https://www.genetics.org/content/163/3/1153.full). You can imagine there's a lot that  happens under the hood to perform this for all loci across all individuals-- all of which dutifully written by :star2: Jason Selwyn :star2:.\n\n### About removing kin\n\nThere are reasons for removing kin in population genetics datasets. For one, there are no siblings/kin or mixed-generations in a Hardy-Weinberg Equilibrium population, and the inclusion of siblings/kin in analyses that rely on HWE assumptions [technically] violate those assumptions. However, there are also arguments to keep kin/siblings in your data, those data are important for effective population size, linkage disequilibrium, etc. [Waples and Anderson (2017)](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14022) published a great perspective on the matter. \n\n\n## Calculate Relatedness\n\nCalculate the relatedness of all pairs of individuals in the dataframe using either Milligan's Dyadic Maximum Likelihood estimator or Queller & Goodnight's estimator.\n\n```julia\npairwise_relatedness(data::PopObj; method::String, inbreeding::Bool = true, verbose::Bool = true)\n```\n\n### arguments\n\n- `data` : the input `PopData`\n\n### keyword arguments\n\n- `method` : Method of relatedness estimation (see below)\n- `inbreeding` : Include the possibility of inbreeding (true) or not (false) - Only used with `method = \"dyadml\"`\n- `verbose` : If `false` only progress bar will be shown. If `true` extra output will be shown depending on the method chosen\n\n### methods\n\n- `\"dyadml\"` : Milligan (2003) Dyadic Likelihood Relatedness\n- `\"qg\"` : Queller & Goodnight (1989) Relatedness\n\n*****\n\n### example\n:::: tabs board-card stretch\n::: tab Queller-Goodnight relatedness\n```julia\ncats = nancycats() ;\npairwise_relatedness(cats, method = \"qg\", verbose = false)\n```\n:::\n::: tab output\n```\n\n```\n\nSee [Development](/other/api/hidden_api.md) for all of the APIs associated with `relatedness()`\n\n## Speed\n\nDepending on the number samples and loci in your data, the maximum-likelihood approach to relatedness can be quite time consuming. We include a progress bar thanks to [ProgressMeter.jl](https://github.com/timholy/ProgressMeter.jl) to provide some indication of how long it will take. As a point of reference, it takes approximately 13 hours to perform this relatedness calculation on the `gulfsharks` data (212 samples x 2213 loci).\n\nCurrently, relatedness calculations run single-threaded, and we hope to parallelize it with the stable release of Julia 1.3  to make it even faster. Many hands make light work!\n\n-------------------\n\n## Acknowledgements\n\nBoth [Convex.jl](https://github.com/JuliaOpt/Convex.jl) and [ECOS.jl](https://github.com/JuliaOpt/ECOS.jl) are pivotal for these calculations, and we thank the authors for their time developing and maintaining them, along with the members of the Julia Slack channel for pointing us towards those packages.\n"
    },
    {
      "title": "Hardy-Weinberg Equilibrium",
      "frontmatter": {},
      "regularPath": "/analyses/hardyweinberg.html",
      "relativePath": "analyses/hardyweinberg.md",
      "key": "v-16dabe24",
      "path": "/analyses/hardyweinberg",
      "headers": [
        {
          "level": 2,
          "title": "Chi-Squared Test",
          "slug": "chi-squared-test"
        },
        {
          "level": 3,
          "title": "arguments",
          "slug": "arguments"
        },
        {
          "level": 3,
          "title": "correction methods",
          "slug": "correction-methods"
        },
        {
          "level": 3,
          "title": "example",
          "slug": "example"
        }
      ],
      "content": "# Hardy-Weinberg Equilibrium\n\nTesting for Hardy-Weinberg Equilibrium (often abbreviated _HWE_) is a fairly common practice in population genetics. In a two-allele system, the HWE equation is defined as:\n$$p^2 + 2pq + q^2 = 1$$\nwhere $p$ is the frequency of the first allele and $q$ is the frequency of the second allele. The formula describes the frequency of all possible genotypes where\n\n| HWE variable | Genotype |    State     |\n| :----------: | :------: | :----------: |\n|    $p^2$    |   \"pp\"   |  homozygous  |\n|    $q^2$    |   \"qq\"   |  homozygous  |\n|    $2pq$     |   \"pq\"   | heterozygous |\n\nTesting for deviation from HWE is usually done with a Chi-Squared test, where one compares the observed genotype frequencies to the expected genotype frequencies given the observed allele frequencies at a locus. Specifically the equation is\n$$\\sum{\\frac{(observed - expected)^2}{expected}}$$\nwhere $observed$ is the observed genotype frequency and $expected$ is the expected genotype frequency for a locus. To generate our test statistic, we calculate the degrees of freedom: \n$$degrees\\ of\\ freedom = n_{expected\\ genotypes} - n_{observed\\ alleles}$$ \nand use this as the parameter for our Chi Squared distribution, followed by a cumulative density function using this Chi Squared distribution and our Chi-Squared value calculated above.\n## Chi-Squared Test\n\n```julia\nhwe_test(x::PopObj, by_pop::Bool = false, correction::String = \"none\")\n```\n\nCalculate chi-squared test of HWE for each locus and returns observed and expected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use `by_pop = true` to perform this separately for each population (default: by_pop = false) and return a NamedTuple with the names corresponding to the population names. Use `correction =` to specify a P-value correction method for multiple testing (recommended).\n\n### arguments\n\n- `x` : the input `PopObj`\n- `by_pop =` : `false` (default) or `true` for hwe-by-population\n- `correction =`  : a string specifying a P-value adjustment type (default: \"none\")\n\n### `correction` methods\n\n- `\"bonferroni\"` : Bonferroni adjustment\n- `\"holm\"` : Holm adjustment\n- `\"hochberg\"` : Hochberg adjustment\n- `\"bh\"` or `\"b-h\"` : Benjamini-Hochberg adjustment\n- `\"by\"` or `\"b-y\"`: Benjamini-Yekutieli adjustment\n- `\"bl\"` or `\"b-l\"` : Benjamini-Liu adjustment\n- `\"hommel\"` : Hommel adjustment\n- `\"sidak\"` : Šidák adjustment\n- `\"forward stop\"` or `\"fs\"` : Forward-Stop adjustment\n- `\"bc\"` or `\"b-c\"` : Barber-Candès adjustment\n\n:thinking: For more information on multiple testing adjustments, see [MultipleTesting.jl](https://juliangehring.github.io/MultipleTesting.jl/stable/)\n\n### example\n:::: tabs board-card stretch\n::: tab HWE Chi-Squared example\n```julia\nhwe_test(gulfsharks(), correction = \"bh\")\n```\n:::\n::: tab output\n```\n2213×7 DataFrames.DataFrame\n│ Row  │ locus        │ het_obs   │ het_exp   │ χ²        │ DF       │ P          │ Pcorr      │\n│      │ String       │ Float64   │ Float64   │ Float64⍰  │ Float64⍰ │ Float64⍰   │ Float64⍰   │\n├──────┼──────────────┼───────────┼───────────┼───────────┼──────────┼────────────┼────────────┤\n│ 1    │ contig_35208 │ 0.419811  │ 0.398051  │ 0.690981  │ 3.0      │ 0.875323   │ 0.948912   │\n│ 2    │ contig_23109 │ 0.262136  │ 0.288434  │ 1.71251   │ 1.0      │ 0.19066    │ 0.295543   │\n│ 3    │ contig_4493  │ 0.205742  │ 0.228532  │ 2.0785    │ 1.0      │ 0.149387   │ 0.234857   │\n│ 4    │ contig_10742 │ 0.0666667 │ 0.0644444 │ 0.249703  │ 1.0      │ 0.617284   │ 0.807471   │\n│ 5    │ contig_14898 │ 0.240566  │ 0.21875   │ 2.10859   │ 1.0      │ 0.146475   │ 0.230442   │\n│ 6    │ contig_8483  │ 0.0188679 │ 0.0186899 │ 0.019229  │ 1.0      │ 0.889712   │ 0.948912   │\n│ 7    │ contig_8065  │ 0.0801887 │ 0.0769736 │ 0.369866  │ 1.0      │ 0.543077   │ 0.732045   │\n│ 8    │ contig_14708 │ 0.0616114 │ 0.0597134 │ 0.213168  │ 1.0      │ 0.644295   │ 0.828219   │\n│ 9    │ contig_2307  │ 0.0289855 │ 0.0285654 │ 0.0447664 │ 1.0      │ 0.832434   │ 0.938862   │\n│ 10   │ contig_14564 │ 0.2       │ 0.209751  │ 0.453809  │ 1.0      │ 0.500532   │ 0.6894     │\n│ 11   │ contig_15269 │ 0.15566   │ 0.146505  │ 1.51012   │ 3.0      │ 0.679938   │ 0.857489   │\n│ 12   │ contig_24796 │ 0.161137  │ 0.201613  │ 8.50406   │ 1.0      │ 0.00354355 │ 0.00596524 │\n│ 13   │ contig_14251 │ 0.490566  │ 0.49782   │ 0.0450074 │ 1.0      │ 0.83199    │ 0.938862   │\n│ 14   │ contig_44797 │ 0.0240385 │ 0.0237495 │ 0.0307836 │ 1.0      │ 0.860724   │ 0.944468   │\n│ 15   │ contig_43681 │ 0.42381   │ 0.472778  │ 2.25286   │ 1.0      │ 0.133368   │ 0.211628   │\n│ 16   │ contig_24115 │ 0.0333333 │ 0.0327778 │ 0.0603275 │ 1.0      │ 0.805979   │ 0.931567   │\n│ 17   │ contig_5456  │ 0.0471698 │ 0.0460573 │ 0.12369   │ 1.0      │ 0.725066   │ 0.892017   │\n│ 18   │ contig_21698 │ 0.0758294 │ 0.0729543 │ 0.327695  │ 1.0      │ 0.567019   │ 0.758715   │\n⋮\n│ 2195 │ contig_8479  │ 0.0235849 │ 0.0598856 │ 212.031   │ 3.0      │ 0.0        │ 0.0        │\n│ 2196 │ contig_47462 │ 0.45283   │ 0.502803  │ 213.589   │ 3.0      │ 0.0        │ 0.0        │\n│ 2197 │ contig_4095  │ 0.259434  │ 0.275398  │ 212.0     │ 3.0      │ 0.0        │ 0.0        │\n│ 2198 │ contig_7239  │ 0.0660377 │ 0.0729352 │ 212.25    │ 3.0      │ 0.0        │ 0.0        │\n│ 2199 │ contig_40507 │ 0.0330189 │ 0.0688746 │ 212.062   │ 3.0      │ 0.0        │ 0.0        │\n│ 2200 │ contig_42145 │ 0.358491  │ 0.31754   │ 5.95351   │ 3.0      │ 0.113894   │ 0.182428   │\n│ 2201 │ contig_1033  │ 0.363208  │ 0.352872  │ 0.181856  │ 1.0      │ 0.669783   │ 0.85219    │\n│ 2202 │ contig_2798  │ 0.122642  │ 0.140219  │ 212.952   │ 3.0      │ 0.0        │ 0.0        │\n│ 2203 │ contig_12991 │ 0.0518868 │ 0.112685  │ 212.161   │ 3.0      │ 0.0        │ 0.0        │\n│ 2204 │ contig_22981 │ 0.188679  │ 0.200783  │ 0.770434  │ 1.0      │ 0.380083   │ 0.551307   │\n│ 2205 │ contig_15342 │ 0.268868  │ 0.29084   │ 212.328   │ 3.0      │ 0.0        │ 0.0        │\n│ 2206 │ contig_24711 │ 0.273585  │ 0.288136  │ 0.540694  │ 1.0      │ 0.462145   │ 0.645777   │\n│ 2207 │ contig_18959 │ 0.466981  │ 0.437422  │ 0.968086  │ 1.0      │ 0.325158   │ 0.482394   │\n│ 2208 │ contig_43517 │ 0.103774  │ 0.150454  │ 212.675   │ 3.0      │ 0.0        │ 0.0        │\n│ 2209 │ contig_27356 │ 0.0660377 │ 0.0906016 │ 213.73    │ 3.0      │ 0.0        │ 0.0        │\n│ 2210 │ contig_475   │ 0.367925  │ 0.375     │ 0.0754717 │ 1.0      │ 0.78353    │ 0.926932   │\n│ 2211 │ contig_19384 │ 0.0613208 │ 0.11264   │ 214.152   │ 3.0      │ 0.0        │ 0.0        │\n│ 2212 │ contig_22368 │ 0.0896226 │ 0.11224   │ 212.481   │ 3.0      │ 0.0        │ 0.0        │\n│ 2213 │ contig_2784  │ 0.0283019 │ 0.0908241 │ 212.047   │ 3.0      │ 0.0        │ 0.0        │\n```\n:::\n::: tab HWE by locus per population\n```\njulia> hwe_test(gulfsharks(), by_pop = true, correction = \"bh\")\n\n```\n:::\n::::"
    },
    {
      "title": "Join the Slack channel!",
      "frontmatter": {},
      "regularPath": "/community.html",
      "relativePath": "community.md",
      "key": "v-29a7b594",
      "path": "/community",
      "headers": [
        {
          "level": 2,
          "title": "Join the Slack channel!",
          "slug": "join-the-slack-channel"
        },
        {
          "level": 2,
          "title": "Contributing",
          "slug": "contributing"
        },
        {
          "level": 3,
          "title": "Improving available code",
          "slug": "improving-available-code"
        },
        {
          "level": 3,
          "title": "Pointing out bugs",
          "slug": "pointing-out-bugs"
        },
        {
          "level": 3,
          "title": "Writing new functions or methods for existing functions",
          "slug": "writing-new-functions-or-methods-for-existing-functions"
        },
        {
          "level": 3,
          "title": "Writing or editing the docs",
          "slug": "writing-or-editing-the-docs"
        },
        {
          "level": 3,
          "title": "Spreading the word",
          "slug": "spreading-the-word"
        },
        {
          "level": 3,
          "title": "Kindness and encouragement",
          "slug": "kindness-and-encouragement"
        }
      ],
      "content": "## Join the Slack channel!\nHave questions, want to talk population genetics, or have ideas?\n \n [![alt text](https://img.shields.io/badge/slack-join%20PopGen.jl-9d72b1?style=for-the-badge&logo=slack)](https://join.slack.com/t/popgenjl/shared_invite/zt-deam65n8-DuBs2z1oDtsbBuRplJW~Pg)\n\n## Contributing\nWe absolutely welcome contributors to this package/project! See below for ways you can help PopGen.jl grow.\n\n### Improving available code\n\nBy nature, most (if not all) users of PopGen.jl will be biologists, and will not come from a strong computational background. Heck, the co-creators of the package don't even have a strong computation background (we're very good at nodding and smiling). There are various [best-practices](https://docs.julialang.org/en/v1/manual/style-guide/index.html) documented in Julia that help users write code to get the best performance out of the language, and sometimes a function that gets written isn't as performant as it can be. If you come up with faster and/or more memory efficient alternatives to the functions in PopGen.jl, we wholeheartedly encourage you to open up a issue or pull request and we'll try to integrate that into the PopGen.jl ecosystem.\n\n### Pointing out bugs \nNo one is perfect (except maybe Betty White), so it's very possible that mistakes get made, especially as more users begin adopting and contributing to PopGen.jl (we hope). If something isn't functioning correctly, please open an issue **that includes a minimum working example**. We definitely want to figure out what's going on, and we need as much information as possible to try to diagnose issues as they come up.\n\nJulia's overall performance is rooted in really clever dispatching to the LLVM compiler, and the underlying system benefits most from stricter typing, wherever we can enforce it, and we expect that this strictness may result in extra issues being raised from niche use-cases. \n\n#### Testing your data against the available code\n\nDuring PopGen.jl's development, we generally use `nancycats` and `gulfsharks` for just about everything. Those two datasets cover the range of what we expect are common use-cases; a smaller microsatellite dataset (nancycats) and a medium sized SNP dataset (gulfsharks). However, we know better than to put all of our faith into _n_ = 2, so please use your own data and mess around with PopGen.jl and let us know if something doesn't jive.\n\n### Writing new functions or methods for existing functions\n\nBy all means, extend PopGen.jl to include all sorts of analyses! GST, Tajima's D, AMOVA, SAMOVA, porting `BOTTLENECK`, coalescence, etc. Yes please! Part of the intent behind PopGen.jl is to have it act as a sort of sandbox to play around in, which is why most of the package's basic calculations are modularized (see the hidden API). As a design choice, it made the most sense to have written the package in this way, because many population genetic calculations are built on top of other ones (like allele frequency or heterozygosity).\n\n### Writing or editing the docs\n\nThe documentation of PopGen.jl must be approachable and _helpful_. Helpful in the sense that if someone was tasked with \"looking for siblings\" in their data and didn't know exactly how, that the documentation for the `relatedness` command would provide some kind of _context_ as to what it does and how, with figures, and with helpful in-line links to the source publications or more in-depth online resources. This package is not intended for only expert-level users, which means that the documentation **needs to be accessible to entry-level users**. By no means will the documentation be the ultimate compendium of all population genetics knowledge, but it _will_ be helpful beyond simply stating a command, its arguments, and a one-liner of what it does.\n\nIf you want to contribute but don't feel comfortable with the programming side of things, then we encourage you to help grow the documentation. Clarify the language in some sections, or maybe provide a useful diagram where one doesn't exist. Or typos. There are always typoes.\n\n### Spreading the word\n\nThe very soul of open-source projects relies on people wanting to get involved. Spread the word :smiley:. If you are into social media, give us a shoutout. We can't imagine why you'd want to, but if you insisted on using a hashtag, then #PopGenjl is probably the sensible choice. \n\n### Kindness and encouragement\n\nThis stuff can be hard. As the package grows, we expect that we'll be dealing with a growing number of issues/complaints. A little thumbs-up :thumbsup: or prayer-hands :pray: emoji (Pavel's personal favorite) can go a long way. Or cook up your own cactus graphic (like the one below) and send it to us. Who doesn't love adorable cactuses doing human things?\n\n![error_cactus](/images/terminal_cactus.png)"
    },
    {
      "title": "Comparison",
      "frontmatter": {
        "sidebarDepth": 2
      },
      "regularPath": "/guide/comparison.html",
      "relativePath": "guide/comparison.md",
      "key": "v-fd7a276c",
      "path": "/guide/comparison",
      "headers": [
        {
          "level": 2,
          "title": "Benchmarks",
          "slug": "benchmarks"
        },
        {
          "level": 3,
          "title": "Loading in data",
          "slug": "loading-in-data"
        },
        {
          "level": 3,
          "title": "PopData vs genind size",
          "slug": "popdata-vs-genind-size"
        },
        {
          "level": 3,
          "title": "Chi-squared test for HWE",
          "slug": "chi-squared-test-for-hwe"
        }
      ],
      "content": "---\nsidebarDepth: 2\n---\n\n# Comparison\n\nThere's a reason we started investing so many hours and so many new grey hairs into writing PopGen.jl when there was an existing ecosystem in R to perform these same tasks. Like we explain in the home page of these docs, we want a platform that is:\n\n1. fast(er)\n2. written in a single language\n3. easy to use\n\nSo, we'd like to prove that Julia and PopGen.jl actually achieves that by showing a few benchmarks comparing PopGen.jl to `adegenet` and `pegas`, which along with `ape` are arguably the most commonly used and robust population genetic packages available. It's worth mentioning that we ourselves use and have published work incorporating these packages, and are tremendously grateful for the work invested in those packages. We appreciate those folks and have tremendous respect and envy for the work they continue to do! Here are links to [adegenet](https://github.com/thibautjombart/adegenet), [pegas](https://academic.oup.com/bioinformatics/article/26/3/419/215731/), and [ape](https://cran.r-project.org/package=ape).  \n\n\n\n## Benchmarks\n\nTo make this a practical comparison, we're going to use the `gulfsharks` data because it is considerably larger (212 samples x 2213 loci) than `nancycats` (237 x 9) and a bit more of a \"stress test\".  All benchmarks in R are performed using the `microbenchmark` package, and  `BenchmarkTools` are used for Julia. \n\n:::: tabs board-card stretch\n::: tab load R packages\n```r\nlibrary(adegenet)\nlibrary(pegas)\nlibrary(microbenchmark)\n```\n:::\n::: tab load Julia packages\n``` julia\nusing BenchmarkTools, PopGen\n```\n:::\n::::\n\nAs a note, the reported benchmarks are being performed on a 64-bit Manjaro Linux system on a nothing-special Lenovo Thinkbook 14S  with 8gigs of RAM and a 8th gen Intel i5 mobile processor. **Note:** all of the Julia benchmarks, unless explicitly stated, are performed single-threaded (i.e. not parallel, distributed, or GPU). \n\n\n\n### Loading in data\n\nSince `gulfsharks` is shamelessly provided in PopGen.jl, we simply invoke the `gulfsharks()` command in Julia. If you would like to try this yourself in R, find the `gulfsharks.gen` file in the package repository under `/data/data/gulfsharks.gen`. It will print out the input filename several times, which is omitted below for clarity. Since the file importer now uses CSV.jl to read in the file, there are two steps of the genepop parser that are multithreaded. However, the majority of the data parsing (formatting the raw data into a correct PopObj structure) occurs using a single thread. This R benchmark will take a few minutes. Consider making some tea while you wait.\n\n:::: tabs board-card stretch\n::: tab Julia\n```julia\njulia> @btime x = gulfsharks() ; # hide the output\n1.049 s (2472280 allocations: 166.30 MiB)\n```\n:::\n::: tab R\n```r\n> microbenchmark(read.genepop(file = \"/home/pdimens/gulfsharks.gen\", ncode = 3L, quiet = TRUE))\nUnit: seconds\n read.genepop(file = \"/home/pdimens/gulfsharks.gen\", ncode = 3L, quiet = FALSE)\n      min       lq     mean   median       uq      max neval\n 5.670637 6.218719 6.745065 6.387936 7.019667 9.173005   100\n```\n:::\n::::\n\nComparing averages, PopGen.jl clocks in at `1.049s` versus adegenet's `6.745s` , so ~6.4x faster.\n\nJulia  :rocket:   |    R  :snail:\n\n\n### `PopData` vs `genind` size\n\nIt was pretty tricky to come up with a sensible/efficient/convenient data structure for PopGen.jl, and the original attempt was a Julian variant to a `genind`, which itself is something known as an `S4 class object`. While the two-IndexedTables design might not seem like it took a lot of effort, we ultimately decided that the column-major style and available tools, combined with careful genotype Typing was a decent \"middle-ground\" of ease-of-use vs performance. Plus, we are suckers for consistent syntax, which `genind`'s don't have compared to standard R syntax (looking at you too, Tidyverse/ggplot!). \n\n*Anyway*, it's important to understand how much space your data will take up in memory (your RAM) when you load it in, especially since data's only getting bigger! Keep in mind that `gulfsharks()` in PopGen.jl also provides lat/long data, which _should_ inflate the size of the object somewhat compared to the `genind`, which we won't add any location data to.\n:::: tabs board-card stretch\n::: tab Julia\n```julia\njulia> Base.summarysize(x)\n1612428\n#bytes\n```\n:::\n::: tab R\n```r\n> object.size(gen)\n5331536 bytes\n```\n:::\n::::\n![clutches pearls](/images/clutches pearls cactus.png)\n\nWhat sorcery is this?! Well, it's all in the Typing of the genotypes. Each genotype for each locus is encoded as a `Tuple` of either `Int8` (if SNPs) or `Int16` (if msats) to absolutely minimize their footprint without further going into byte-level encoding (so you can still see human-readable alleles). An `Int8` is a signed integer that occupies 8bits of memory, whereas an `Int16` occupies 16bits (as compared to a standard `Int64`). \n\nThe original file is `3.2mb`, and our `PopObj`takes up ~`1.6mb` in memory (half as big as the source file!) versus the ~`5.3mb` of a `genind`, which is ~1.5x larger than the source file and ~3.3x larger than our `PopObj`. That's quite a big difference!\n\nJulia  :house_with_garden: ​   |    R  :european_castle:\n\n\n### Chi-squared test for HWE\n\nThis is a classic population genetics test and a relatively simple one. \n\n```julia tab=\"Julia\"\njulia> @btime hwe_test(x, correction = \"bh\") ;\n  392.527 ms (1599668 allocations: 57.20 MiB)\n```\n\nThe R benchmark will take a while again, so if you're following along, this would be a good time to reconnect with an old friend.\n\n```r tab=\"R\"\n> microbenchmark(hw.test(gen, B = 0))\nUnit: seconds\n                expr      min       lq     mean   median       uq      max neval\n hw.test(gen, B = 0) 5.100298 5.564807 6.265948 5.878842 6.917006 8.815179   100\n```\n\nComparing averages, PopGen.jl clocks in at ~`400ms` versus adegenet's `6.3s`, so ~15x faster.\n\nJulia  :rocket:  |   R  :snail:\n\n \n"
    },
    {
      "title": "A quick Julia primer",
      "frontmatter": {},
      "regularPath": "/guide/",
      "relativePath": "guide/README.md",
      "key": "v-676214cb",
      "path": "/guide/",
      "headers": [
        {
          "level": 2,
          "title": "Using Julia",
          "slug": "using-julia"
        },
        {
          "level": 2,
          "title": "First-time Performance",
          "slug": "first-time-performance"
        },
        {
          "level": 2,
          "title": "Semicolons",
          "slug": "semicolons"
        },
        {
          "level": 3,
          "title": "At the end of a command",
          "slug": "at-the-end-of-a-command"
        },
        {
          "level": 3,
          "title": "In between assignment commands",
          "slug": "in-between-assignment-commands"
        },
        {
          "level": 2,
          "title": "Help mode",
          "slug": "help-mode"
        },
        {
          "level": 2,
          "title": "Type information",
          "slug": "type-information"
        },
        {
          "level": 3,
          "title": "Type Unions",
          "slug": "type-unions"
        },
        {
          "level": 3,
          "title": "Subtypes",
          "slug": "subtypes"
        },
        {
          "level": 2,
          "title": "Functions vs. Methods",
          "slug": "functions-vs-methods"
        },
        {
          "level": 3,
          "title": "ERROR: MethodError: no method matching",
          "slug": "error-methoderror-no-method-matching"
        },
        {
          "level": 2,
          "title": "Functions with and without keywords",
          "slug": "functions-with-and-without-keywords"
        }
      ],
      "content": "# A quick Julia primer \n*For getting the most out of this documentation*\n\nThere is nothing inherently special about this documentation relative to other documentation, other than we really *really* want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend [Think Julia: How to Think Like a Data Scientist](https://benlauwens.github.io/ThinkJulia.jl/latest/book.html) by Ben Lauwens to establish some solid Julia foundations. It's free online! Also, the Julia language maintains [its own great documentation](https://docs.julialang.org/en/v1/) that we rely on quite heavily for development.\n\n\n## Using Julia\n\nEveryone has their own particular workflows, and if you're new to Julia, you might not have established one yet. Julia can be used rather comfortably using its built-in interpreter, but you can also use it via Atom (the [officially supported](https://junolab.org/) `uber-juno` add-on) for an RStudio-like experience. If you're already a fan of Jupyter notebooks (or [**nteract**](https://nteract.io/)), then all you need is to install the `IJulia` package in Julia and you have full Jupyter support for Julia! Other popular options are VScode (julia add-on), or Emacs. \n\n::: tip Trivia\nIf you didn't already know,  the name \"Jupyter\" is actually a concatenation of **Ju** (julia) **Pyt** (python) and **eR** (R). 🤯\n:::\n\n## First-time Performance\nIf you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). It's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists **only the first time** you run something. Every subsequent run of a function, even with different parameters, will be **substantially** faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with `@time` before the function and compare the results. Here's an example:\n``` \njulia> @time using PopGen\n17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time)\n\njulia> @time using PopGen\n0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)\n```\n\n## Semicolons\n\nSemicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language.  They mean different things depending on where they are.\n\n### At the end of a command\n\n When you see a semicolon after invoking a function, what that means is \"don't show me the output\".\n\nExample: \n\n```julia\njulia> x = 2 + 2\n4\n\njulia> x = 10 + 2 ;\n\njulia> x\n12\n```\n\nJulia will still process the command and assign `10 + 2` to `x`, but it won't show you the output. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back large volumes of text. **These semicolons are optional** \n\n\n\n### In between assignment commands\n\nIf you see a semicolon in between two variable assignments or commands, like so:\n\n```julia\njulia> x = [1,2] ; y = [3,4]\n```\n\nthat's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing:\n\n```julia\njulia> x = [1,2]\njulia> y = [3,4]\n```\n\nWe sometimes choose this writing format for very quick  and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you!\n\n## Help mode\n\nTo enter `help` mode in the REPL, simply press the question mark key `?` (shift + key) and you will notice a different prompt `help?>` for you to type in a function.\n\n```julia\nhelp?>population\n```\n\n```\nsearch: population populations population! populations!\n\n  population(data::PopData; listall::Bool = false)\n\n  View unique population ID's in a PopObj.\n\n  listall = true, displays ind and their population instead (default = false).\n```\n\n\n\n## Type information\n\nJulia encourages strong typing of variables, and the functions in `PopGen` are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the `type` information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the `help` system in the REPL (above), or search for a function in the Documentation pane in Juno. \n\nYou'll notice types follow a specific format, which is `object::type`. This format is a type declaration, so in the function `population`, which looks like: \n\n```julia\npopulation(data::PopData; listall::Bool = false)\n```\n\n- `data` is a variable of type `PopData` \n- `listall` is a variable of type `Bool` (Boolean) meaning it only takes `true` or `false` without quotes, and the default value is set to `false`\n\n### Type Unions\n\nYou might see the type `Union` appear occasionally throughout this documentation, and you can consider it a list of allowable types. For example, if something was of type `::Union{String,Integer}`, that means that **either** a `String` or `Integer` works. \n\n### Subtypes\n\nThe julia language is abound with types (and you can create your own!), and has a hierarchical system of supertypes and subtypes. As you can probably guess, a supertype can contain multiple subtypes, such as `Signed` being a supertype of (among other things) `Int64, Int32, Int16, Int8`. All vectors are subtypes of `AbstractVector`.  If you want to try it yourself, use the `supertype()` command on your favorite Type, like `supertype(Float32)`. You will occasionally see `<:` instead of `::`, which means \"is a subtype of\". This is used for condtional evaluation, like `typeof(something) <: Signed`, and in some function methods like `function(var1::T) where T <: Supertype`, which leads us to:\n\n#### where T\n\nThis looks weird at first,  but it's actually very simple. When we do method definitions, we can define methods with strict types, like `funct(data:PopData, arg1::Int8)`, or we can generalize it with `where T`, which looks like :\n\n```julia\nfunction funct1(data::PopData, thing1::T) where T\n```\n\nThis will auto-create a method for any possible Type for `thing1`. Usually, that's problematic, as incorrect input will lead to obscure errors (e.g. multiplying integers with strings?!). Instead, you can constrain the types for `T` like this:\n\n```julia\nfunction funct2(data::PopData, thing1::T) where T <: Signed\n```\n\nWith the constraint above, it will generate methods for all cases where `thing1` is a subtype of `Signed`, which includes all the numerical Types (integers, Floats, etc.). This will make sure that the function will behave correctly for a range of input types.\n\nYou can also use this type of notation to clean up a method definition where multiple arguments have the same Type specification:\n\n```julia\nfunction funct3(data::PopData, thing1::T, thing2::T, thing3::T) where T<:AbstractFloat\n```\n\nSo, instead of writing `thing1::Float64, thing2::Float64, thing3::Float64`, we just use `T` as a placeholder and assign it as a subtype of something at the end.  It ends up being pretty handy!\n\n\n## Functions vs. Methods \n\nAs part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different *methods* depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of `if` statements that determines what the program does depending on the input. \n\n::: tip Best Practice\nAs a rule of thumb, `for ` loops with `if` conditions in them slow down the compiler, so best-practice often encourages us to write type-specific methods.\n:::\nIn practice, this looks like:\n\n```\n# combine two numbers\njulia> function add(x::Integer, y::Integer)\n           x+y\n       end\nadd (generic function with 1 method)\n\n# combine two strings\njulia> function add(x::String, y::String)\n           x*y\n       end\nadd (generic function with 2 methods)\n                \njulia> add(1,2)\n3\n\njulia> add(\"water\", \"melon\")\n\"watermelon\"\n```\n\nMultiple dispatch therefor leads to a unique type of possible error: the `MethodError`\n\n### ERROR: MethodError: no method matching\n\nUsing the function `add` from the example above, let's have a look at what happens when we try to `add` an `Integer` with a `String`:\n\n```julia\njulia> add(1,\"melon\")\nERROR: MethodError: no method matching add(::Int64, ::String)\nClosest candidates are:\n  add(::String, ::String) at none:2\n  add(::Integer, ::Integer) at none:2\nStacktrace:\n [1] top-level scope at none:0\n```\n\nThis error is telling us \"there is no such function called `add`, who's inputs are an `Integer` followed by a `String`\". But, it does offer us some alternatives, like the two `add` functions we created earlier.\n\nThe functions within `PopGen` are almost always explicitly typed, so if you are getting the `MethodError: no method matching` error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below).\n\nSometimes you might include an argument with a keyword when there isn't one, or include an argument without a keyword when there needs to be one (honestly, we make that mistake too and we *wrote* this stuff). To help minimize those mistakes, please read below about which arguments have keywords and which don't.\n\n::: warning MethodErrors\nMethodError's can definitely get annoying, but they are more commonly the result of incorrect inputs versus . If you double-checked your inputs and things still don't work, please submit an issue. Thanks!\n:::\n\n\n## Functions with and without keywords \n\nLet's talk about semicolons some more.\n\n::: details TL;DR\nReading these docs, pay attention to semicolons in the function argument lists.\n-  arguments before a semicolon have no keyword and follow an explicit order\n-  arguments after a semicolon have a keyword `argument = value` and their order doesn't matter\n- `MethodError: no methods matching` is often a user error and not a bug, but if it is, please open an issue!\n:::\n\nBroadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format `argument = value`. This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. \n\n:::: tabs board-card stretch\n::: tab 1. No semicolon in argument list\n```julia\nfunction function_name(var1::type, var2::type, var3::type)\n    do stuff with vars\nend\n```\nIf a function is declared with only commas in the argument list, like shown above, then the arguments to that function **must** have no keywords and follow the exact order they appear in. If the generic example above had the typing:\n```julia\nfunction function_name(var1::String, var2::Float64, var3::Array{String,1})\n    do stuff with vars\nend\n```\nthen the only acceptable way to run this function without getting a `MethodError` would be with arguments in the order of `function_name(String, Float64, Array{String,1})`. Even if some of the arguments have a default values, like `var2::Float64 = 6.66`, the order of arguments/types has to be respected as declared.\n:::\n::: tab 2. Semicolon in argument list\n```julia\nfunction function_name(var1::type; var2::type, var3::type)\n    do stuff with vars\nend\n```\n\nIn this format, everything that comes **before** the semicolon follows the strict rules from **Format 1**, and everything that comes **after** the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you **must** use the keywords to declare those arguments, or you will receive another `MethodError: no method matching`, which is, as we've mentioned, annoying. \n:::\n::::"
    },
    {
      "title": "Provided datasets",
      "frontmatter": {},
      "regularPath": "/guide/io/datasets.html",
      "relativePath": "guide/io/datasets.md",
      "key": "v-84c68194",
      "path": "/guide/io/datasets",
      "headers": [
        {
          "level": 2,
          "title": "datasets",
          "slug": "datasets"
        },
        {
          "level": 3,
          "title": "nancycats",
          "slug": "nancycats"
        },
        {
          "level": 3,
          "title": "gulfsharks",
          "slug": "gulfsharks"
        }
      ],
      "content": "# Provided datasets\nPopGen.jl provides two datasets as examples, `nancycats` and `gulfsharks`. The datasets can be retrieved using the `dataset` function, or their names as commands without arguments (e.g. `gulfsharks()`). \n\n::: tip identitcal methods\nThe methods are identical (one is a wrapper for the other), but the benefit of calling the datasets directly by name is that you get the luxury of tab auto-completion :grin:\n:::\n\n## datasets\n```julia\ndataset(::String)\n```\nReturns a `PopData` object of the dataset you would like to retrieve by calling the dataset as a string by name.\n\n**Example:**\n```julia\nsharks = dataset(\"gulfsharks\")\ncats = dataset(\"nancycats\")\n```\n### nancycats\n\nWe include the familiar nancycats microsatellite data, as featured in [adegenet](http://adegenet.r-forge.r-project.org), for easy importing into PopGen.jl as `PopData`. As an alternative to `datasets`, you can invoke the `nancycats()`  command without any arguments.\n\n```\njulia> ncats = nancycats() ; summary(ncats)\nPopData Object\n  Marker type: Microsatellite\n  Ploidy: 2\n  Number of individuals: 237\n  Number of loci: 9\n  Populations: 17\n  Longitude: absent\n  Latitude: absent\n```\n\nThe spatial coordinates provided for the dataset in `adegenet` are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted.  If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know!\n\n### gulfsharks\n\nWe also include the SNP dataset used in Dimens *et al.* 2019 \"[A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark, *Carcharhinus acronotus*](https://link.springer.com/article/10.1007/s00227-019-3533-1)\" since it was already on hand. Like `nancycats`, we provide a convenient function to load these data into PopGen.jl as `PopData`. As an alternative to `datasets`, you can invoke the `gulfsharks()` command without any arguments. \n\n```jullia\njulia> sharks = gulfsharks() ; summary(sharks)\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 212\n  Number of loci: 2213\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n```\n\n"
    },
    {
      "title": "Delimited format",
      "frontmatter": {},
      "regularPath": "/guide/io/delimited.html",
      "relativePath": "guide/io/delimited.md",
      "key": "v-64c2e588",
      "path": "/guide/io/delimited",
      "headers": [
        {
          "level": 2,
          "title": "Delimited format",
          "slug": "delimited-format"
        },
        {
          "level": 2,
          "title": "Import a delimited file as PopData",
          "slug": "import-a-delimited-file-as-popdata"
        },
        {
          "level": 3,
          "title": "Arguments",
          "slug": "arguments"
        },
        {
          "level": 3,
          "title": "Keyword Arguments",
          "slug": "keyword-arguments"
        },
        {
          "level": 2,
          "title": "Formatting",
          "slug": "formatting"
        },
        {
          "level": 3,
          "title": "Missing data",
          "slug": "missing-data"
        },
        {
          "level": 2,
          "title": "Acknowledgements",
          "slug": "acknowledgements"
        }
      ],
      "content": "## Delimited format\n\n## Import a delimited file as `PopData`\n\n```julia\ndelimited(infile::String; delim::Union{Char,String,Regex} = \"auto\", digits::Int = 3, diploid::Bool = true, silent::Bool = false)\n\n# Example\njulia> a = delimited(\"/data/cali_poppy.csv\", digits = 2)\n```\n\n::: warning Windows users\nmake sure to change your backslashes `\\` to forward slashes `/` \n:::\n\n### Arguments\n\n- `infile::String` : path to the input file, in quotes\n\n### Keyword Arguments\n\n- `delim::String` : delimiter characters. The default (`\"auto\"`) uses auto-parsing of `CSV.File`\n\n- `digits::Integer` : the number of digits used to denote an allele (default: `3`)\n- `diploid::Bool`  : whether samples are diploid for parsing optimizations (default: `true`)\n- `silent::Bool` : whether to print file information during import (default: `true`)\n\n## Formatting\n\n- First row is column names in this order:\n  1. name\n  2. population\n  3. longitude\n  4. latitude\n  5. locus_1_name\n  6. locus_2_name\n  7. etc...\n\n### Missing data\n#### Genotypes\nMissing genotypes can be formatted as all-zeros (ex.`000000`) or negative-nine `-9`\n\n#### Location data\nIf location data is missing for a sample (which is ok!), make sure the value is written\nas `0`, otherwise there will be transcription errors!\n\n:::: tabs board-card stretch\n::: tab formatting example\n```\nname,population,long,lat,Locus1,Locus2,Locus3\nsierra_01,mountain,11.11,-22.22,001001,002002,001001\nsierra_02,mountain,11.12,-22.21,001001,001001,001002\nsnbarb_03,coast,0,0,001001,001001,001002\nsnbarb_02,coast,11.14,-22.24,001001,001001,001001\nsnbarb_03,coast,11.15,0,001002,001001,001001\n```\n:::\n::::\n\n::: tip\nYou can also use the command `csv()` synonymously with `delimited()`. \n:::\n\n## Acknowledgements\n\nThanks to the efforts of the [CSV.jl](https://github.com/JuliaData/CSV.jl) team, we are able leverage that package to do much of the heavy lifting within this parser. "
    },
    {
      "title": "Reading in data",
      "frontmatter": {},
      "regularPath": "/guide/io/file_import.html",
      "relativePath": "guide/io/file_import.md",
      "key": "v-09d0341e",
      "path": "/guide/io/file_import",
      "headers": [
        {
          "level": 2,
          "title": "Supported File Types",
          "slug": "supported-file-types"
        },
        {
          "level": 3,
          "title": "Delimited files",
          "slug": "delimited-files"
        },
        {
          "level": 3,
          "title": "Genepop Files",
          "slug": "genepop-files"
        },
        {
          "level": 3,
          "title": "Variant Call Format",
          "slug": "variant-call-format"
        }
      ],
      "content": "# Reading in data\n\nCurrently, PopGen.jl provides four different file parsers with which to create `PopData`. Each of the file types have their own file importer denoted simply by the file type:\n\n| File type                     | Function to import it |\n| ----------------------------- | --------------------- |\n| Delimited                     | `delimited()`         |\n| Genepop                       | `genepop()`           |\n| Variant Call Format           | `vcf()`               |\n| Variant Call Format (bzipped) | `bcf()`               |\n\nYou're encouraged to use functions, but PopGen.jl also provides you with an all-encompassing wrapper  called `read_in()`. \n\n::: details file_import alias\nThe name \"read_in\" is short and sweet, but isn't the most descriptive, so we provide a more explicitly-named alias `file_import()`. Feel free to use whichever you like best.\n:::\n\n```julia\nread_in(infile::String; kwargs...)\nfile_import(infile::String; kwargs...)\n```\n\nwhere `infile` is a String of your filename (in quotes) and `kwargs` are the corresponding keyword arguments associated with your file type. The function `read_in()` uses all the same keyword arguments as do the commands specific to their file types, therefore you should have a look at those commands (usually the defaults suffice). \n\n`read_in()` infers the file type from the file extension, so for it to work properly your file must end with the extensions permitted below (case insensitive). If you're feeling particularly rebellious and your file does not conform to these extensions (such as a genepop file with a `.gen.final.v2.seriously` extension), then feel free to use the specific file importers, since they use the same exact syntax, there is zero difference in performance, and ignore file extensions. Ultimately, what crazy extensions you give your files is your business, and we love that about you. \n\n## Supported File Types\n\n### [Delimited files](delimited.md) \n\nAccepted extensions: `.csv`, `.tsv`, `.txt`\n\n- files in which values are separated using a consistent delimiter, such as commas, spaces, or tabs\n- first rows are column names\n- each line represents a row\n\n\n### [Genepop Files](genepop.md)\n\nAccepted extensions: `.gen`, `.genepop`\n\n- first row is a comment and skipped\n- then comes list of all loci, usually 1-per-line\n  - sometimes horizontally arranged and separated by commas\n- populations separated by a word like `\"POP\"`\n- sample names followed by a **comma, then a tab or space**\n- genotypes separated by **tabs** or **spaces**\n- genotypes represented as a combination of ploidy x _n_-digits \n\t- e.g. for genotype 001002 (3 digits per allele)\n\t- allele 1 = 001\n\t- allele 2 = 002\n\n\n### [Variant Call Format](variantcall.md)\n\nAccepted extensions: `.vcf`, `.bcf`\n\nThis format is **much** more complex and variable depending on which variant caller produced the file. If you're super duper interested in the specifications of BCF/VCF files, have a look at the [official specification documentation](http://samtools.github.io/hts-specs/VCFv4.3.pdf)."
    },
    {
      "title": "About",
      "frontmatter": {},
      "regularPath": "/guide/about.html",
      "relativePath": "guide/about.md",
      "key": "v-5d58c9d4",
      "path": "/guide/about",
      "headers": [
        {
          "level": 2,
          "title": "About",
          "slug": "about"
        },
        {
          "level": 2,
          "title": "Goal",
          "slug": "goal"
        },
        {
          "level": 2,
          "title": "Why Julia (and not Python or R)?",
          "slug": "why-julia-and-not-python-or-r"
        }
      ],
      "content": "\n## About\n\nPopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in *sane*, user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem.\n\n## Goal\n\nTo be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: *Sanity, Sensibility, Accessibility*.\n\n:::: tabs board-card stretch\n::: tab Sanity\nFunctions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. The first argument for all functions is the input data without keywords. Always. If a function has a very obvious name, then it likely it won't need keyword arguments.\n:::\n::::\n\n:::: tabs board-card stretch\n::: tab Sensibility\nFunctions need to be sensible, both in what they do and how they do it. This means they should include only the most relevant arguments and the most practical defaults. It also means the outputs need to be flexible enough to use with other Julia packages, such as `Query.jl`, or `Plots`.\n:::\n::::\n\n:::: tabs board-card stretch\n::: tab Accessibility\nDocumentation is everything! Julia is a comparatively young language and we *want* you to be comfortable using PopGen.jl. That means investing **a lot** of time into writing thorough documentation intended for users across a wide spectrum of proficiency. We also recognize that you (the reader) might not be very familiar with Julia, so we've written [a section](/guide/) on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer.\n:::\n::::\n\n## Why Julia (and not Python or R)?\n\n#### Speed and syntax\n\nThe speed is comparable to C when coded correctly. Also, has Python-like syntax with **optional** tabs. We are also fans of 1-indexing, but that's more of a perk. Not convinced? Check out our [comparison benchmarks](getting_started/comparison.md).\n\n#### A modern language for modern problems\n\nJulia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future work).\n\n#### Community & contribution\n\nJulia's internals solve what's know as the \"two language problem\". That is, languages that are easy to write in (e.g. Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (e.g. C, C++, Fortran). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because things work and they are easy to use. **But**, it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are kind of helpless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! **Yikes!**\n\nSo, if we write everything in Julia, and you use everything in Julia, users can themselves diagnose these things if they so choose. This means users can contribute to the overall health and accuracy of this package. Yes, that means that we might be getting more Issues opened up (*ugh*), but a bug found is a lot better than a bug overlooked!\n\nLike most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA using `PopData`? Send us a pull request (please!)! Or [join the Slack!](community.md)\n\n#### Package manager\n\nWhich, let's be honest, is such a delight to use. [Installing PopGen.jl](getting_started/install.md) should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia. "
    },
    {
      "title": "Installation",
      "frontmatter": {},
      "regularPath": "/guide/install.html",
      "relativePath": "guide/install.md",
      "key": "v-61dd8ad6",
      "path": "/guide/install",
      "headers": [
        {
          "level": 2,
          "title": "Installing PopGen.jl",
          "slug": "installing-popgen-jl"
        },
        {
          "level": 2,
          "title": "Using PopGen",
          "slug": "using-popgen"
        }
      ],
      "content": "# Installation\n\n## Installing PopGen.jl\n\nThe package is currently unregistered while it's under active early development. However, installation is still simple!\n\n:::: tabs board-card stretch\n::: tab in the REPL or Juno\nInvoke the package manager with `]` in the REPL and use\n\n```julia\nadd \"https://github.com/pdimens/PopGen.jl\"\n```\n\n![install](/images/install_repl.gif)\n:::\n::: tab with Jupyter Notebooks or nteract\n```julia\nusing Pkg\nPkg.add(PackageSpec(url=\"https://github.com/pdimens/PopGen.jl\", rev=\"master\"))\n```\n\n![install](/images/install_jupyter.gif)\n:::\n::::\n\n## Using PopGen\n\nLike all Julia packages, to activate PopGen.jl, simply run:\n\n```julia\njulia> using PopGen\n```\n\nFeel free to play around with the test data in `/data/data/` or add it to your workspace with the `nancycats` and `gulfsharks` commands.\n\n\n::: warning Arch Linux users\nIf you compiled Julia from source, your PopGen.jl installation may fail due to incorrectly building `Arpack`, which is expected to be in one place, but the compilation puts in another. \n\n**Solutions**:\n\n- install official Julia binaries from the AUR (`julia-bin`), which includes a correctly bundled `Arpack` (recommended)\n- if Julia was compiled from source: install `julia-arpack` from the AUR and make sure to delete `~/.julia/packages/Arpack` if it exists. That *should* fix things, but sometimes it still acts up.\n:::"
    },
    {
      "title": "Genepop format",
      "frontmatter": {},
      "regularPath": "/guide/io/genepop.html",
      "relativePath": "guide/io/genepop.md",
      "key": "v-dabcb914",
      "path": "/guide/io/genepop",
      "headers": [
        {
          "level": 2,
          "title": "Import a genepop file as PopData",
          "slug": "import-a-genepop-file-as-popdata"
        },
        {
          "level": 3,
          "title": "arguments",
          "slug": "arguments"
        },
        {
          "level": 3,
          "title": "keyword Arguments",
          "slug": "keyword-arguments"
        },
        {
          "level": 2,
          "title": "Format",
          "slug": "format"
        },
        {
          "level": 2,
          "title": "Acknowledgements",
          "slug": "acknowledgements"
        }
      ],
      "content": "# Genepop format\n\n## Import a genepop file as `PopData`\n\n```julia\ngenepop(infile; kwargs...)\n\n# Example\njulia> b = genepop(\"/data/wasp_hive.gen\", digits = 3, popsep = \"POP\")\n```\n\n::: warning Windows users\nMake sure to change your backslashes `\\` to forward slashes `/` \n:::\n\n### arguments\n\n- `infile::String` : path to genepop file, in quotes\n\n### keyword Arguments\n\n- `digits::Integer`: number of digits denoting each allele (default: `3`)\n- `popsep::String` : word that separates populations in `infile` (default: \"POP\")\n- `diploid::Bool`  : whether samples are diploid for parsing optimizations (default: `true`)\n- `silent::Bool`   : whether to print file information during import (default: `true`)\n\n::: tip population names\nBy default, the file reader will assign numbers as population ID's (as Strings) in order of appearance in the genepop file. Use the `populations!` function to rename these with your own population ID's.\n:::\n\n## Format\n\nFiles must follow standard Genepop formatting:\n\n- First line is a comment (and skipped)\n- Loci are listed after first line as one-per-line without commas or in single comma-separated row\n- A line with a particular and consistent keyword must delimit populations\n- **Must** be the same word each time and not a unique population name\n- File is **tab** delimited or **space** delimited, but not both\n\n:::: tabs board-card stretch\n::: tab genepop w/loci stacked vertically\n```\nWasp populations in New York\nLocus1\nLocus2\nLocus3\nPOP\nOneida_01,\t250230\t564568\t110100\nOneida_02,\t252238\t568558\t100120\nOneida_03,\t254230\t564558\t090100\nPOP\nNewcomb_01,\t254230\t564558\t080100\nNewcomb_02,\t000230\t564558\t090080\nNewcomb_03,\t254230\t000000\t090100\nNewcomb_04,\t254230\t564000\t090120\n```\n:::\n::: tab genepop w/loci stacked horizontally\n```\nWasp populations in New York\nLocus1,Locus2,Locus3\nPOP\nOneida_01,\t250230\t564568\t110100\nOneida_02,\t252238\t568558\t100120\nOneida_03,\t254230\t564558\t090100\nPOP\nNewcomb_01,\t254230\t564558\t080100\nNewcomb_02,\t000230\t564558\t090080\nNewcomb_03,\t254230\t000000\t090100\nNewcomb_04,\t254230\t564000\t090120\n```\n:::\n::::\n\n## Acknowledgements\n\nThe original implementations of this parser were written using only Base Julia, and while the speed was fantastic, the memory footprint involved seemed unusually high (~650mb RAM to parse `gulfsharks`, which is only 3.2mb in size). However, thanks to the efforts of the [CSV.jl](https://github.com/JuliaData/CSV.jl) team, we leverage that package to do much of the heavy lifting, in a multicore way, and all the while preserving the speed and reducing the memory footprint quite a bit!\n\n"
    },
    {
      "title": "Variant Call Format",
      "frontmatter": {},
      "regularPath": "/guide/io/variantcall.html",
      "relativePath": "guide/io/variantcall.md",
      "key": "v-7be4f5a8",
      "path": "/guide/io/variantcall",
      "headers": [
        {
          "level": 2,
          "title": "Import a BCF/VCF file as a PopObj",
          "slug": "import-a-bcf-vcf-file-as-a-popobj"
        },
        {
          "level": 2,
          "title": "What BCF/VCF files contain and lack",
          "slug": "what-bcf-vcf-files-contain-and-lack"
        },
        {
          "level": 2,
          "title": "Format",
          "slug": "format"
        },
        {
          "level": 2,
          "title": "Acknowledgements",
          "slug": "acknowledgements"
        }
      ],
      "content": "# Variant Call Format\n\n## Import a BCF/VCF file as a `PopObj`\nPopGen.jl provides a simple command `vcf` to import a VCF file as a `PopObj`, which requires only the name of the file and nothing else. While not strictly necessary, if you have polyploid or mixed-ploidy samples, this import method may be most efficient.\n\n```julia\npotato = vcf(\"/home/data/russet_potatoes.vcf\")\n```\n\nand similar for `bcf` formatted files:\n\n```julia\ncabbage = bcf(\"/home/data/nappa_cabbage.bcf\")\n```\n\n::: warning Windows users\nMake sure to change your backslashes `\\` to forward slashes `/` \n:::\n\n## What BCF/VCF files contain and lack\n\nDue to the nature of the file format, importing variant call files **will** provide:\n\n- sample names\n- ploidy of each sample\n- locus names\n- genotypes\n\nbut they **will not** provide:\n\n- population information\n- latitude or longitude\n\nThis means you will need to add that information separately afterwards. Location data (which is optional!) can be added to the `PopData` with the `locations!` command. Population names (mandatory!) can be added using `populations!()`\n\n## Format\n\nVariant Call Format (or *VCF*) files already follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use `Freebayes` ourselves). Please open an issue if they do, or reach out to us on the community Slack.\n\n::: danger Filter files beforehand\nKeep in mind, BCF/VCF files need to be filtered **before** importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to `vcftools`, `bcftools`, and `vcflib` to filter your sequence data. \n:::\n\n\n## Acknowledgements\nThe majority of the BCF/VCF reader is thanks to the tremendous efforts of Ben J. Ward and the BioJulia contributors involved in [GeneticVariation.jl](https://github.com/BioJulia/GeneticVariation.jl), which we use to parse your files into `PopObj` format. If you love the file importer, then give those folks your thanks. If something is wrong and/or you hate the importer, blame us (and please [open up an issue](https://github.com/pdimens/PopGen.jl/issues) :sweat_smile:)."
    },
    {
      "title": "Other data types",
      "frontmatter": {},
      "regularPath": "/guide/other_types.html",
      "relativePath": "guide/other_types.md",
      "key": "v-e22a8114",
      "path": "/guide/other_types",
      "headers": [
        {
          "level": 3,
          "title": "Genotype",
          "slug": "genotype"
        },
        {
          "level": 3,
          "title": "GenotypeArray",
          "slug": "genotypearray"
        }
      ],
      "content": "# Other data types\n\nWhile not strictly their own composite types, we also define aliases for genotypes and vectors of genotypes, as their explicit types can get a little unwieldy to use. The types shown below in the code blocks include their name and type (all types are of type `DataType`) on the first line, and what the alias actually defines on the second line.\n\n### Genotype\n\n```julia\nGenotype::DataType\nNTuple{N,<:Signed} where N\n```\n\nAn `NTuple` is itself an alias for a `Tuple{Vararg{}}` , but you can think of it as Tuple of `N` length composed of items of a particular type, in this case it's items that are subtypes of `Signed` (the integer types). The length of the tuple (`N`) will vary based on the ploidy of the sample, and the element `Type` will vary whether the markers are snps (`Int8`) or microsatellites (`Int16`), making this a pretty flexible (but immutable) structure.\n\n### GenotypeArray\n\n```julia\nGenotypeArray::DataType\nAbstractVector{S} where S<:Union{Missing,Genotype}\n```\n\nAs you can guess from the name, this Type wraps `Genotype` into a Vector, while permitting `missing` values (what's genetics without missing data!?). By using `AbstractVector` (rather than `Vector`), we also have the flexibility of functions working on things like `SubArrays` out of the box. \n\n::: tip why bother defining these aliases?\nGetting the most out of Julia and demonstrating good practices means making sure functions work on the things they're supposed to, and give informative error messages when the input isn't suitable for the function (a rare case of _wanting_ MethodErrors). Without these aliases, functions would either have vague definitions like `f(x,y,z) where x <: AbstractArray` and potentially cause errors, or overly complicated definitions like `f(x::AbstractVector{S},y,z) where {N, T<:Signed,S<:NTuple{N,T}}` and not be very legible. Instead, functions are written as `f(x,y,z) where x<:GenotypeArray`, and that seems like a good compromise of getting the latter while looking like the former."
    },
    {
      "title": "PopObj and PopData types",
      "frontmatter": {},
      "regularPath": "/guide/popobj_type.html",
      "relativePath": "guide/popobj_type.md",
      "key": "v-34724bd6",
      "path": "/guide/popobj_type",
      "headers": [
        {
          "level": 2,
          "title": "Metadata",
          "slug": "metadata"
        },
        {
          "level": 3,
          "title": "name",
          "slug": "name"
        },
        {
          "level": 3,
          "title": "population",
          "slug": "population"
        },
        {
          "level": 3,
          "title": "ploidy",
          "slug": "ploidy"
        },
        {
          "level": 3,
          "title": "longitude",
          "slug": "longitude"
        },
        {
          "level": 3,
          "title": "latitude",
          "slug": "latitude"
        },
        {
          "level": 2,
          "title": "Genotype Information",
          "slug": "genotype-information"
        },
        {
          "level": 3,
          "title": "name",
          "slug": "name-2"
        },
        {
          "level": 3,
          "title": "population",
          "slug": "population-2"
        },
        {
          "level": 3,
          "title": "locus",
          "slug": "locus"
        },
        {
          "level": 3,
          "title": "genotype",
          "slug": "genotype"
        },
        {
          "level": 2,
          "title": "Viewing PopData",
          "slug": "viewing-popdata"
        },
        {
          "level": 2,
          "title": "location data",
          "slug": "location-data"
        }
      ],
      "content": "# PopObj and PopData types\nFor the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called  `PopData`. The struct is defined as:\n\n```julia\nstruct PopData\n\tmeta::IndexedTable\n\tloci::IndexedTable\nend\n```\n\nAs you can see, a `PopData` is made up of two IndexedTables (from [JuliaDB.jl](https://github.com/JuliaComputing/JuliaDB.jl)), one called `meta` for sample information (metadata), and the other called `loci` which includes genotype information. This structure allows for easy and convenient access to the fields using dot `.` accessors.. The `meta` and `loci` tables are both specific in their structure, so here is an illustration to help you visualize a `PopData` object:\n\n![PopData](/images/PopData.svg)\n\n\n`PopData` and other custom types introduced in PopGen.jl fall under an AbstractType we call `PopObj`, which is short for \"PopGen Object\".\n\n::: details pronouncing \"PopObj\"\nIt's not super obvious, but we decided to pronounce PopObj as \"pop ob\" with a silent j because it sounds better than saying \"pop obj\", but writing it as PopOb looks weird. It's a silly little detail that Pavel seems to care a lot about.\n:::\n\n::: danger avoid manual creation!\nWhile it may seem simple enough to create two IndexedTables and make a `PopData` out of them, the structure of `meta` and `loci` are specific, so small mistakes in creating them can create many errors and prevent PopGen from working correctly on your data. Please use the included `csv`, `genepop`, and `vcf` file importers instead.\n:::\n\n## Metadata\n\nThe `meta` table has 5 specific categories/columns: name, population, ploidy, longitude, latitude. These can be directly accessed with `PopData.meta.columns.colname` where `PopData` is the name of your PopData object, and `colname` is one of the five column names below.\n\n### name\n\n`::Vector{String}`\n\nThe individual/sample names\n\n```julia\n[\"ind_001\", \"ind_002\", \"ind_003\"]\n```\n\n### population\n\n`::Vector{String}`\n\nThe individual/sample population ID's\n\n```julia\n[\"borneo\", \"borneo\", \"new jersey\"]\n```\n\n### ploidy\n\n`::Vector{Int8}`\n\nThe ploidy of the samples\n\n```julia\n[2, 2, 2]\n```\n\n### longitude\n\n`::Vector{Union{Missing,Float32}}`\n\nlatitude data of samples (decimal degrees)\n\n```\n[-11.12, 15.32, 11.02, -4.42]\n```\n\n### latitude\n\n`::Vector{Union{Missing,Float64}}`\n\nlongitude data of samples (decimal degrees)\n\n```\n[-11.12, 15.32, 11.02, -4]\n```\n\n## Genotype Information\n\nThe genotype information is stored in a separate table called `loci`. This table is rather special in that it is stored in \"tidy\" format, i.e. one record per row. Storing data this way makes it a lot easier to interrogate the data and write new functions, along with leveraging [JuliaDBMeta.jl](https://github.com/piever/JuliaDBMeta.jl). It also means the table will have as many rows as loci x samples, which can become a lot. To reduce redundant objects inflating object size, the columns name, population, and locus are `CategoricalStrings`  from [CategoricalArrays.jl](https://github.com/JuliaData/CategoricalArrays.jl), which is a memory-saving data structure for long repetitive categorical data. Without using this format, `gulfsharks`, whose source file is 3.2mb, would occupy about 27mb in your RAM! The classes of `.loci` can be directly accessed with `PopData.loci.columns.colname` where `PopData` is the name of your PopData object, and `colname` is one of the four column names below.\n\n### name\n\n`::Vector{CategoricalString}`\n\nThe sample name, stored as a `CategoricalString`. Fundamentally, this acts like the `name` column of the `meta` table, except when deleting entries and a few uncommon edge cases.\n\n### population\n\n`::Vector{CategoricalString}`\n\nThe population ID associated with that sample, stored as a `CategoricalString`. Fundamentally, this acts like the `population` column of the `meta` table, except when deleting entries and a few uncommon edge cases.\n\n### locus\n\n`::Vector{CategoricalString}`\n\nThe locus associated with the genotype, stored as a `CategoricalString`.\n\n### genotype\n\n`::Vector{Union{Missing,Genotype}}`\n\nThe genotypes of the `loci` are an array of type `Genotype`, which is an alias for a built-in Julia Tuple type with each value corresponding to an allele (read below to disentangle what that type actually is). For the most part, it looks like this:\n\n```julia tab=\"genotype example\"\n[(0,1), (0,0), missing, (1,2)]\n```\n\n::: warning immutable genotypes\nWe use the Tuple type for genotypes of individuals because they are **immutable** (cannot be changed). By the time you're using PopGen.jl, your data should already be filtered and screened. Hand-editing of genotype alleles is **strongly** discouraged, so we outlawed it.\n:::\n\n## Viewing PopData\n\nGiven the volume of information that can be present in a `PopData`, we recommend `summary()` to summarize/overview the data rather than regurgitate everything on the screen. \n\n```\njulia> a = gulfsharks() ;\n\njulia> summary(a)\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 212\n  Number of loci: 2213\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n```\n\n## location data\n\nLocation data is optional for a `PopData`. There are functions that use location information (e.g. `locations`), but most don't, so it's not a dealbreaker. At present, there are no analyses that utilize location information. "
    },
    {
      "title": "Directly accessing elements",
      "frontmatter": {},
      "regularPath": "/tutorials/accessing_popdata.html",
      "relativePath": "tutorials/accessing_popdata.md",
      "key": "v-73e0b054",
      "path": "/tutorials/accessing_popdata",
      "headers": [
        {
          "level": 2,
          "title": "Loading in the data",
          "slug": "loading-in-the-data"
        },
        {
          "level": 2,
          "title": "The metadata table",
          "slug": "the-metadata-table"
        },
        {
          "level": 3,
          "title": ".meta",
          "slug": "meta"
        },
        {
          "level": 3,
          "title": ".name",
          "slug": "name"
        },
        {
          "level": 3,
          "title": ".population",
          "slug": "population"
        },
        {
          "level": 3,
          "title": ".ploidy",
          "slug": "ploidy"
        },
        {
          "level": 3,
          "title": ".latitude",
          "slug": "latitude"
        },
        {
          "level": 3,
          "title": ".longitude",
          "slug": "longitude"
        },
        {
          "level": 2,
          "title": "The genotype table",
          "slug": "the-genotype-table"
        },
        {
          "level": 3,
          "title": ".loci",
          "slug": "loci"
        },
        {
          "level": 3,
          "title": "locus names",
          "slug": "locus-names"
        },
        {
          "level": 3,
          "title": "view genotypes",
          "slug": "view-genotypes"
        }
      ],
      "content": "# Directly accessing elements\n\nA little hands-on training will probably go a long way, so let's through some of the functions available in PopGen.jl with the included data. This tutorial will include both inputs and outputs so you can be confident what you're seeing in your Julia session is exactly what's supposed to happen. Sometimes the outputs can be a little lengthy, so they will be arranged in code \"tabs\", where the left-most tab is the input named after what it's accomplishing, and the right tab is the output of running the command. This guide is to show you how to directly access  `PopData` elements, but there are shortcut commands to view just about every element of the data within. \n\n::: danger don't manually edit or sort\nThere are specific relationships between the record entries in `PopData` objects, so **do not use** `sort`, `sort!`, or manually arrange/add/delete anything in PopData. There are included functions to remove samples or loci, rename things, add location data, etc. \n:::\n## Loading in the data\n\nLet's keep things simple by loading in the nancycats data and calling it `ncats`.\n\n\n:::: tabs type:board-card stretch\n\n::: tab load nancycats\n``` julia\njulia> ncats = nancycats() ; summary(ncats)\n```\n:::\n\n::: tab output\n```\nPopData Object\n  Marker type: Microsatellite\n  Ploidy: 2\n  Number of individuals: 237\n  Number of loci: 9\n  Populations: 17\n  Longitude: absent\n  Latitude: absent\n```\n:::\n::::\n\n\nNow that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopData. The IndexedTable format requires a little extra work, so we must use the convention `PopData.meta.columns.colname` to directly access the columns we want.\n\n## The metadata table\n\n### .meta\n\nTo view the entire `meta` table.\n\n:::: tabs type:board-card stretch\n\n::: tab PopData meta field\n```julia\njulia> ncats.meta\n```\n:::\n\n::: tab output\n```julia\nTable with 237 rows, 5 columns:\nname    population  ploidy  latitude  longitude\n───────────────────────────────────────────────\n\"N1\"    \"1\"         2       missing   missing\n\"N2\"    \"1\"         2       missing   missing\n\"N3\"    \"1\"         2       missing   missing\n\"N4\"    \"1\"         2       missing   missing\n\"N5\"    \"1\"         2       missing   missing\n\"N6\"    \"1\"         2       missing   missing\n\"N7\"    \"1\"         2       missing   missing\n\"N8\"    \"1\"         2       missing   missing\n⋮\n\"N231\"  \"17\"        2       missing   missing\n\"N232\"  \"17\"        2       missing   missing\n\"N233\"  \"17\"        2       missing   missing\n\"N234\"  \"17\"        2       missing   missing\n\"N235\"  \"17\"        2       missing   missing\n\"N236\"  \"17\"        2       missing   missing\n\"N237\"  \"17\"        2       missing   missing\n```\n:::\n\n::::\n\n### .name\n\nThis will access the names of the samples.\n\n\n:::: tabs type:board-card stretch\n\n::: tab meta .name field\n``` julia\njulia> ncats.meta.columns.name\n```\n:::\n\n::: tab output\n```\n237-element Array{String,1}:\n \"N1\"  \n \"N2\"  \n \"N3\"  \n \"N4\"  \n \"N5\"  \n \"N6\"  \n \"N7\"  \n \"N8\"  \n ⋮     \n \"N230\"\n \"N231\"\n \"N232\"\n \"N233\"\n \"N234\"\n \"N235\"\n \"N236\"\n \"N237\"\n```\n:::\n::::\n\n### .population\nThis will access the names of the populations associated with each sample, in the same order as the  samples.\n\n\n:::: tabs type:board-card stretch\n::: tab meta .population field\n``` julia\njulia> ncats.meta.columns.population\n```\n:::\n\n::: tab output\n```\n237-element Array{String,1}:\n \"1\" \n \"1\" \n \"1\" \n \"1\" \n \"1\" \n \"1\" \n \"1\" \n \"1\" \n ⋮   \n \"17\"\n \"17\"\n \"17\"\n \"17\"\n \"17\"\n \"17\"\n \"17\"\n \"17\"\n```\n:::\n::::\n\nThese ID's aren't super informative. Later, we'll change them using the `popid!` command.\n\n###  .ploidy\n\nThis shows you the ploidy of the data per individual\n\n:::: tabs type:board-card stretch\n::: tab meta .ploidy\n``` julia\njulia> ncats.meta.columns.ploidy\n```\n:::\n::: tab output\n```\n237-element Array{Int8,1}:\n 2\n 2\n 2\n 2\n 2\n 2\n 2\n 2\n ⋮\n 2\n 2\n 2\n 2\n 2\n 2\n 2\n 2\n```\n:::\n::::\n\n### .latitude\n\nThis accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns a vector of `missing`.\n\n:::: tabs type:board-card stretch\n::: tab meta .latitude field\n```julia\njulia> ncats.meta.columns.latitude\n```\n:::\n::: tab output\n```\n237-element Array{Union{Missing, Float32},1}:\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n ⋮      \n missing\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n```\n:::\n::::\n\n### .longitude\n\nThis accesses the longitude information of the PopObj. Like before, if there is none, like in the nancycats data, it returns an array of `missing`.\n\n:::: tabs type:board-card stretch\n::: tab meta .longitude field\n```julia\njulia> ncats.meta.columns.longitude\n```\n:::\n::: tab output\n```\n237-element Array{Union{Missing, Float32},1}:\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n ⋮      \n missing\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n```\n:::\n::::\n\n:::: tabs type:border-card stretch\n::: tab actually seeing some location info \nThe nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for `.longitude` and `.latitude`, load in `gulfsharks` and try it out. We'll use `hcat` (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the `locations` command does this.\n:::    \n::: tab gulfsharks location data\n``` julia\njulia> sharks = gulfsharks() ;    # semicolon just supresses printing output\n\njulia> hcat(sharks.meta.columns.name, sharks.meta.columns.latitude, sharks.meta.columns.longitude)\n\n212×3 Array{Any,2}:\n\"cc_001\"   28.3062  -80.5993\n\"cc_002\"   28.3079  -80.5995\n\"cc_003\"   28.3023  -80.5996\n\"cc_005\"   28.6123  -80.4225\n\"cc_007\"   27.8666  -80.3578\n\"cc_008\"   27.8666  -80.3579\n\"cc_009\"   27.8682  -80.3482\n\"cc_010\"   27.8711  -80.3482\n\"cc_012\"   28.4815  -80.4303\n\"cc_013\"   28.2421  -80.2494\n⋮                           \n\"seg_021\"  29.9466  -86.0399\n\"seg_023\"  29.9969  -85.6494\n\"seg_024\"  29.6966  -87.4403\n\"seg_025\"  30.064   -86.5374\n\"seg_026\"  30.0696  -86.5376\n\"seg_027\"  29.9065  -86.0905\n\"seg_028\"  30.0532  -87.3661\n\"seg_029\"  30.0522  -87.3662\n\"seg_030\"  29.8234  -85.7143\n\"seg_031\"  29.8234  -85.7143\n```\n:::\n::::\n--------------------\n\n## The genotype table\n\n### .loci\n\nThis will show you the entire `loci` table.\n\n:::: tabs type:board-card stretch\n::: tab PopData loci field \n```julia\njulia> ncats.loci\n```\n:::\n\n::: tab output\n```\nTable with 2133 rows, 4 columns:\nname    population  locus    genotype\n─────────────────────────────────────\n\"N1\"    \"1\"         \"fca8\"   missing\n\"N1\"    \"1\"         \"fca23\"  (4, 9)\n\"N1\"    \"1\"         \"fca43\"  (4, 4)\n\"N1\"    \"1\"         \"fca45\"  (1, 3)\n\"N1\"    \"1\"         \"fca77\"  (9, 9)\n\"N1\"    \"1\"         \"fca78\"  (3, 6)\n\"N1\"    \"1\"         \"fca90\"  (9, 9)\n\"N1\"    \"1\"         \"fca96\"  (8, 8)\n⋮\n\"N237\"  \"17\"        \"fca45\"  missing\n\"N237\"  \"17\"        \"fca77\"  (6, 9)\n\"N237\"  \"17\"        \"fca78\"  (3, 7)\n\"N237\"  \"17\"        \"fca90\"  (8, 8)\n\"N237\"  \"17\"        \"fca96\"  missing\n\"N237\"  \"17\"        \"fca37\"  (10, 10)\n```\n:::\n::::\n\n### locus names\n\nThis will access the names of the loci as they appear in the data. Since everything but the genotypes in `.loci` are coded as Categorical, we need to use `levels()` from `CategoricalArrays.jl` or `unique()` from Base to pull out the unique loci. \n\n:::: tabs type:board-card stretch\n::: tab loci .locus\n```julia\njulia> levels(ncats.loci.columns.locus)\n# or #\njulia> unique(ncats.loci.columns.locus)\n```\n:::\n::: tab output\n```\n9-element Array{String,1}:\n \"fca8\" \n \"fca23\"\n \"fca43\"\n \"fca45\"\n \"fca77\"\n \"fca78\"\n \"fca90\"\n \"fca96\"\n \"fca37\"\n```\n:::\n::::\n\n\n### view genotypes\n\nBecause the genotype data is in \"tidy\" format, accessing genotypes in a meaningful way is not immediately obvious. We can of course follow the same convention of `data.loci.genotype` as we have above, but a list of all the genotypes across all individuals, loci, and populations isn't terribly useful. Instead, we can use the JuliaDB or JuliaDBMeta interfaces to retrieve this information. Here is an example using `@where` from JuliaDBMeta:\n\n:::: tabs type:board-card stretch\n::: tab single locus\n```julia\njulia> @where ncats.loci :locus == \"fca8\"\nTable with 237 rows, 4 columns:\nname    population  locus   genotype\n────────────────────────────────────\n\"N1\"    \"1\"         \"fca8\"  missing\n\"N2\"    \"1\"         \"fca8\"  missing\n\"N3\"    \"1\"         \"fca8\"  (9, 13)\n\"N4\"    \"1\"         \"fca8\"  (8, 9)\n\"N5\"    \"1\"         \"fca8\"  (8, 9)\n\"N6\"    \"1\"         \"fca8\"  (9, 13)\n\"N7\"    \"1\"         \"fca8\"  (9, 9)\n\"N8\"    \"1\"         \"fca8\"  (9, 13)\n⋮\n\"N232\"  \"17\"        \"fca8\"  (8, 12)\n\"N233\"  \"17\"        \"fca8\"  (8, 12)\n\"N234\"  \"17\"        \"fca8\"  (8, 13)\n\"N235\"  \"17\"        \"fca8\"  (9, 12)\n\"N236\"  \"17\"        \"fca8\"  (10, 13)\n\"N237\"  \"17\"        \"fca8\"  (9, 12)\n```\n:::\n::: tab multiple loci\n```julia\njulia> @where ncats.loci :locus in [\"fca8\", \"fca23\"]\nTable with 474 rows, 4 columns:\nname    population  locus    genotype\n─────────────────────────────────────\n\"N1\"    \"1\"         \"fca8\"   missing\n\"N1\"    \"1\"         \"fca23\"  (4, 9)\n\"N2\"    \"1\"         \"fca8\"   missing\n\"N2\"    \"1\"         \"fca23\"  (9, 9)\n\"N3\"    \"1\"         \"fca8\"   (9, 13)\n\"N3\"    \"1\"         \"fca23\"  (4, 9)\n\"N4\"    \"1\"         \"fca8\"   (8, 9)\n\"N4\"    \"1\"         \"fca23\"  (5, 5)\n⋮\n\"N235\"  \"17\"        \"fca8\"   (9, 12)\n\"N235\"  \"17\"        \"fca23\"  (4, 8)\n\"N236\"  \"17\"        \"fca8\"   (10, 13)\n\"N236\"  \"17\"        \"fca23\"  (2, 4)\n\"N237\"  \"17\"        \"fca8\"   (9, 12)\n\"N237\"  \"17\"        \"fca23\"  (2, 9)\n```\n:::\n::::\n\nNow that you're somewhat familiar with the parts of `PopData`, [have a look at the commands](view_and_sort.md) to view and manipulate `PopData` objects."
    },
    {
      "title": "Data exclusion",
      "frontmatter": {},
      "regularPath": "/tutorials/exclusion.html",
      "relativePath": "tutorials/exclusion.md",
      "key": "v-c51de354",
      "path": "/tutorials/exclusion",
      "headers": [
        {
          "level": 2,
          "title": "Exclude samples",
          "slug": "exclude-samples"
        },
        {
          "level": 2,
          "title": "Exclude loci",
          "slug": "exclude-loci"
        }
      ],
      "content": "# Data exclusion\n\nThis section covers situations where one may want to remove samples or loci from `PopData`. By design, removal functions _do not_ alter your original `PopData`, so you always have a backup handy (but don't forget to assign a name to the new `PopData`). Since the exclusion functions don't alter the original `PopData`, they do not end with a bang `!`. \n\n::: details alias functions\nFor the exclusion commands on this page, we made it so the words `omit` and `remove` are interchangeable with `exclude`, meaning  `remove_samples` and `omit_loci` are the same exact functions as their `exclude` variants. This was done so you can use them interchangeably and you wont' need to remember the specific name to perform these basic actions. Maybe you just prefer the word `omit`. We're not here to judge.\n:::\n\n## Exclude samples\n\n```julia\nexclude_samples(data::PopObj, samp_id::Union{String, Vector{String}})\n```\n\nReturns a new `PopData` object without the sample or samples provided. Input can be a single sample, or an array of samples. Will output an entire `PopData`, so use a semicolon after the command if you don't want the entire object printed to your screen. Use `summary`  if you want to confirm that the samples were removed. This command will inform you if samples were not found in the data. \n\n:::: tabs board-card stretch\n::: tab single individual\n``` julia\njulia> fewer_sharks = exclude_samples(sharks, \"cc_001\") ;\n\njulia> summary(fewer_sharks)\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 211\n  Number of loci: 2213\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n```\n:::\n::: tab multiple individuals\n``` julia\njulia> lots_fewer_sharks = remove_samples(sharks, [\"cc_001\", \"cc_002\", \"cc_003\"]) ; \n\njulia> summary(lots_fewer_sharks)\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 209\n  Number of loci: 2213\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n```\n:::\n::::\n::: warning sample not found!\nIf removing a single sample and it is not found in the PopData, an error will be returned. However, if removing multiple samples, you will receive a notice above the PopData output indicating which individuals were not found, while still removing the ones that were present.\n:::\n\n\n## Exclude loci\n\n```julia\nexclude_loci(data::PopObj, loci::Union{String, Vector{String}})\n```\n\nReturns a new `PopData` object without the locus or loci provided. Input can be a single locus, or an array of loci, all as Strings. Will output an entire `PopData`, so use a semicolon after the command if you don't want the entire object printed to your screen. Use `summary`  if you want to confirm that the loci were removed. This command will inform you if loci were not found in the data.\n\n:::: tabs board-card stretch\n::: tab single locus\n``` julia\njulia> fewer_shark_loci = exclude_loci(sharks, \"contig_475\") ;\n\njulia> summary(fewer_shark_loci)\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 212\n  Number of loci: 2212\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n```\n:::\n::: tab multiple loci\n``` julia\njulia> lots_fewer_loci = remove_loci(sharks, [\"contig_475\", \"contig_2784\", \"contig_8065\"]) ; \n\njulia> summary(lots_fewer_loci)\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 212\n  Number of loci: 2210\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n```\n:::\n::::\n\n::: warning locus not found!\nIf removing a single locus and it is not found in the PopData, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopData summary indicating which loci were not found, while removing the ones that were. If none of the loci specified were found, it will return an error.\n:::"
    },
    {
      "title": "Start here",
      "frontmatter": {},
      "regularPath": "/tutorials/manipulate.html",
      "relativePath": "tutorials/manipulate.md",
      "key": "v-7e9026da",
      "path": "/tutorials/manipulate",
      "headers": [
        {
          "level": 3,
          "title": "Accessing Elements",
          "slug": "accessing-elements"
        },
        {
          "level": 3,
          "title": "Viewing and Sorting",
          "slug": "viewing-and-sorting"
        },
        {
          "level": 3,
          "title": "Sample and Locus Exclusion/Removal",
          "slug": "sample-and-locus-exclusion-removal"
        },
        {
          "level": 3,
          "title": "Location and Population Information",
          "slug": "location-and-population-information"
        }
      ],
      "content": "# Start here\n\nPopGen.jl includes basic commands to provide obvious methods to inspect and alter `PopData`. Using standard Julia conventions, only commands ending with a bang `!` are mutable, meaning they alter the input data. So, commands like `populations` will show you population information, whereas `populations!` will change that information in your `PopData`. The mutable commands here alter the data in your `PopData`, but not the source data (i.e. the files used to create the `PopData`). Read over [Accessing parts of PopData](accessing_popdata.md) to become familiar with the components of `PopData`. \n\nThe \"manipulation\" commands were separated into three sections to make it less overwhelming, and using the `gulfsharks` data, you can explore each of the sections like a little tutorial. The sections don't follow any particular order, so feel free to jump around however you like. \n\nTo follow along like a tutorial, load the `gulfsharks` data in if you haven't already:\n\n```julia\njulia> using PopGen\n\njulia> sharks = gulfsharks() ;\n```\n\n### [Accessing Elements](accessing_popdata.md)\n\n### [Viewing and Sorting](view_and_sort.md)\n\n### [Sample and Locus Exclusion/Removal](exclusion.md)\n\n### [Location and Population Information](location_and_pop.md)\n\n"
    },
    {
      "title": "Location and population data",
      "frontmatter": {},
      "regularPath": "/tutorials/location_and_pop.html",
      "relativePath": "tutorials/location_and_pop.md",
      "key": "v-fc1a46e0",
      "path": "/tutorials/location_and_pop",
      "headers": [
        {
          "level": 2,
          "title": "Location Data",
          "slug": "location-data"
        },
        {
          "level": 3,
          "title": "View location data",
          "slug": "view-location-data"
        },
        {
          "level": 3,
          "title": "Add location data",
          "slug": "add-location-data"
        },
        {
          "level": 2,
          "title": "Population Names",
          "slug": "population-names"
        },
        {
          "level": 3,
          "title": "View population names",
          "slug": "view-population-names"
        },
        {
          "level": 3,
          "title": "Rename populations",
          "slug": "rename-populations"
        }
      ],
      "content": "# Location and population data\n\nPopulation genetics involves a focus on... populations (gasp!). The commands below show you how to view and modify both population information (names), and location information (geographic coordinates). \n\n## Location Data\n\n### View location data\n\n```julia\nlocations(data::PopData)\n```\n\nView location data (`.longitude` and `.latitude`) in a `PopData`,  returning a table the longitude and latitude information in `meta`. \n\n:::: tabs board-card stretch\n::: tab locations\n```julia\njulia> locations(sharks)\n```\n:::\n::: tab output\n```\nTable with 212 rows, 2 columns:\nlongitude  latitude\n───────────────────\n28.3062    -80.5993\n28.3079    -80.5995\n28.3023    -80.5996\n28.6123    -80.4225\n27.8666    -80.3578\n27.8666    -80.3579\n27.8682    -80.3482\n27.8711    -80.3482\n⋮\n30.0696    -86.5376\n29.9065    -86.0905\n30.0532    -87.3661\n30.0522    -87.3662\n29.8234    -85.7143\n29.8234    -85.7143\n```\n:::\n::::\n\n### Add location data\nLocation data can be added using one of the methods of `locations!`. As indicated by the bang `!`, your `PopData` will be edited in place, and there will be no return output. If your data is in Decimal Minutes format, this function will convert your long/lat into Decimal Degrees. To import those data into Julia, you'll likely want to use the wonderful `CSV.jl` package first. \n\n- Decimal Degrees : `-11.431`\n- Decimal Minutes : `-11 43.11` (notice the space)\n\n::: warning Must use minus sign\nYour data **must** use the minus sign `-` (if appropriate) instead of cardinal directions. `11 43.11W` is **not** valid.\n:::\n\nThere are three main ways of adding location data:\n:::: tabs board-card stretch\n::: tab Already in decimal degrees\n```julia\nlocations!(data::PopObj, long::Vector{T}, lat::Vector{T}) where T<:AbstractFloat\n```\n\nThis method is pretty straightforward, and it tolerates vectors with `missing` data.\n\n```julia\n# generate some fake location data\njulia> long = rand(212) .* 10 ; lat = rand(212) .* -10\n\njulia> locations!(sharks, long, lat)\n```\n:::\n::: tab Decimal minutes as strings\nIt would likely be most convenient if you imported your decimal minutes data as vectors of strings, which would look something like this:\n```julia\nlat = [\"11 44.31\", \"-25 41.94\"]\nlong = [\"-43 54.11\", \"22 23.11\"]\n```\n\nFor this, the method is\n\n```julia\nlocations!(data::PopData; lat::Vector{String}, long::Vector{String})\n```\n\nwhich uses the `lat` and `long` keywords.\n\n::: warning Missing values\nThis method tolerates `missing` values, but you will need to `replace!` the string `\"missing\"` with values of `missing`.\n:::\n\n::: tab Decimal minutes as separate vectors\nAlternatively, can input four vectors of numbers with the associated keyword arguments:\n\n| Input                       | Type    | Keyword Argument |\n| --------------------------- | ------- | ---------------- |\n| Vector of longitude degrees | Integer | `long_deg`       |\n| Vector of longitude minutes | Float   | `long_min`       |\n| Vector of latitude degrees  | Integer | `lat_deg`        |\n| Vector of latitude minutes  | Float   | `lat_min`        |\n\nThis method is easier or more tedious depending on what you consider a more practical approach. For example, if you have decimal-minutes coordinates for two samples:\n\n|          | Longitude | Latitude |\n| -------- | --------- | -------- |\n| Sample 1 | 11 43.12  | 15 36.53 |\n| Sample 2 | -12 41.32 | 11 22.41 |\n\nthen your inputs would be:\n\n```\nlo_deg = [11, -12]\nlo_min = [43.12, 41.32]\nla_deg  = [15, 11]\nla_min  = [36.53, 22.41]\n```\n\nand you would then use `locations!` like this:\n\n```julia\nlocations!(data, long_deg = lo_deg, long_min = lo_min, lat_deg = la_deg, lat_min = la_min)\n```\n:::\n::::\n\n\n## Population Names\n\n### View population names\n\n```julia\npopulations(data::PopData; listall::Bool = false)\n```\n\nJust as you can view population names with `PopData.meta.columns.population`, you can also view them with the `populations` command, which by default shows you a summary of the number of individuals in each population.  \n\n:::: tabs board-card stretch\n::: tab populations\n``` julia\njulia> populations(sharks)\n```\n:::\n::: tab output\n```\nTable with 7 rows, 2 columns:\npopulation        count\n───────────────────────\n\"Cape Canaveral\"  21\n\"Florida Keys\"    65\n\"Georgia\"         30\n\"Mideast Gulf\"    28\n\"Northeast Gulf\"  20\n\"South Carolina\"  28\n\"Southeast Gulf\"  20\n```\n:::\n::::\n\nYou can use the keyword `listall=true` to display each individual and their associated population as a table. \n:::: tabs board-card stretch\n::: tab listall = true\n``` julia\njulia> populations(sharks, listall=true)\n```\n:::\n::: tab output\n```\nTable with 212 rows, 2 columns:\nname       population\n───────────────────────────\n\"cc_001\"   \"Cape Canaveral\"\n\"cc_002\"   \"Cape Canaveral\"\n\"cc_003\"   \"Cape Canaveral\"\n\"cc_005\"   \"Cape Canaveral\"\n\"cc_007\"   \"Cape Canaveral\"\n\"cc_008\"   \"Cape Canaveral\"\n\"cc_009\"   \"Cape Canaveral\"\n\"cc_010\"   \"Cape Canaveral\"\n⋮\n\"seg_026\"  \"Southeast Gulf\"\n\"seg_027\"  \"Southeast Gulf\"\n\"seg_028\"  \"Southeast Gulf\"\n\"seg_029\"  \"Southeast Gulf\"\n\"seg_030\"  \"Southeast Gulf\"\n\"seg_031\"  \"Southeast Gulf\"\n```\n:::\n::::\n\n::: details alias functions\nYou can use the command `population` for the same functionality. We made the commands `population` and `populations` synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to `populations!` and `population!`\n:::\n\n### Rename populations\n\nThere are a handful of methods to alter `PopData` population names depending on what you find most convenient. Each of these methods start with `populations!()` and vary in their inputs. It's for that reason this function has an obnoxiously long docstring. For simplicity, the methods will be separated into categories. However, all the methods for `populations!` are unified in that they edit `PopData` in place, and print (rather than return) a table of the new population names and counts courtesy of `populations()`.\n\n#### Replace by matching\nThese methods require that some kind of population information is already present, in the sense that the samples in `PopData` aren't all in one population.\n:::: tabs board-card stretch\n::: tab using a Dictionary\n```julia\npopulations!(data::PopData, rename::Dict)\n```\n\nRename existing population ID's of `PopData` using a `Dict` of\n`population_name => replacement`.\n\n``` julia\n# create a dictionary of name conversions\njulia> new_popnames = Dict(\n    \t\t\"Cape Canaveral\" => \"Atlantic\",\n\t\t\t\"Georgia\" => \"Atlantic\",\n\t\t\t\"South Carolina\" => \"Atlantic\",\n    \t\t\"Florida Keys\" => \"Gulf\",\n    \t\t\"Mideast Gulf\" => \"Gulf\",\n    \t\t\"Northeast Gulf\" => \"Gulf\",\n    \t\t\"Southeast Gulf\" => \"Gulf\"\n\t\t);\t\n\njulia> populations!(sharks, new_popnames)\n\nTable with 2 rows, 2 columns:\npopulation  count\n─────────────────\n\"Atlantic\"  79\n\"Gulf\"      133\n```\n:::\n::: tab Using a Vector of names\n```julia\npopulations!(data::PopData, rename::Vector{String})\n```\n\n`Vector` of new unique population names in the order that they appear in the `PopData.meta`.\n\n```julia\njulia> new_popnames = [\"Atlantic\", \"Atlantic\", \"Atlantic\", \"Gulf\", \"Gulf\", \"Gulf\", \"Gulf\"]\n\njulia> populations!(sharks, new_popnames)\n\nTable with 2 rows, 2 columns:\npopulation  count\n─────────────────\n\"Atlantic\"  79\n\"Gulf\"      133\n```\n:::\n::: tab Using a Vector of oldnames and new names\n```julia\npopulations!(data::PopData, oldnames::Vector{String, newnames::Vector{String}})\n```\n\nSimilar to the `Dict` method, except instead of creating a dictionary of \"oldname\" => \"newname\", you input a Vector{String} of `oldnames` followed by another of `newnames`. Logically, the new names will replace the old names in the same order as they appear in `PopData.meta` (e.g. the first newname replaces the first oldname, etc.).\n\n```julia\njulia> old_pop = [\"Cape Canaveral\", \"Florida Keys\", \"Georgia\", \"Mideast Gulf\", \"Northeast Gulf\", \"South Carolina\", \"Southeast Gulf\"] ;\n\njulia> new_pop = [\"Atlantic\", \"Gulf\", \"Atlantic\", \"Gulf\", \"Gulf\", \"Atlantic\", \"Gulf\"] ;\n\njulia> populations(sharks, old_pop, new_pop)\nTable with 2 rows, 2 columns:\npopulation  count\n─────────────────\n\"Atlantic\"  79\n\"Gulf\"      133\n```\n:::\n\n**********\n\n#### Generate new population information\n\nYou may want outright overwrite all current population information. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of `PopData` regardless of what they currently are. \n\n::: warning Double-check your population counts\nIf you're playing along and getting errors that the lengths don't match, then get make sure you're using the right population counts. You can get those numbers with `populations(sharks)`.\n:::\n\n```julia\ncounts = [21, 65, 30, 28, 20, 28, 20]\n```\n\nand we then also create the vector of the names in the order in which they appear:\n\n```julia\npopnames = [\"Cape Canaveral\", \"Florida Keys\", \"Georgia\", \"Mideast Gulf\", \"Northeast Gulf\", \"South Carolina\", \"Southeast Gulf\"]\n```\n\nNow we can combine them with `populations!` to restore the population names to how they were originally\n::::: tabs board-card stretch\n::: tab Replace using a NamedTuple\n```julia\njulia> populations!(sharks, (counts = counts, names = popnames))\nTable with 7 rows, 2 columns:\npopulation        count\n───────────────────────\n\"Cape Canaveral\"  21\n\"Florida Keys\"    65\n\"Georgia\"         30\n\"Mideast Gulf\"    28\n\"Northeast Gulf\"  20\n\"South Carolina\"  28\n\"Southeast Gulf\"  20\n```\n:::\n::: tab Replace Using Vectors of names & counts\nThis is just about the same as using the `NamedTuple`, but perhaps some users will prefer this format.\n```julia\njulia> populations!(sharks, popnames, counts)\nTable with 7 rows, 2 columns:\npopulation        count\n───────────────────────\n\"Cape Canaveral\"  21\n\"Florida Keys\"    65\n\"Georgia\"         30\n\"Mideast Gulf\"    28\n\"Northeast Gulf\"  20\n\"South Carolina\"  28\n\"Southeast Gulf\"  20\n```\n:::\n::::\n"
    },
    {
      "title": "Viewing and Sorting",
      "frontmatter": {},
      "regularPath": "/tutorials/view_and_sort.html",
      "relativePath": "tutorials/view_and_sort.md",
      "key": "v-bfc020d4",
      "path": "/tutorials/view_and_sort",
      "headers": [
        {
          "level": 2,
          "title": "Individuals / Samples",
          "slug": "individuals-samples"
        },
        {
          "level": 3,
          "title": "view individuals' names",
          "slug": "view-individuals-names"
        },
        {
          "level": 2,
          "title": "Sorting",
          "slug": "sorting"
        },
        {
          "level": 2,
          "title": "Display Specific Loci and/or Samples",
          "slug": "display-specific-loci-and-or-samples"
        },
        {
          "level": 3,
          "title": "Get loci names",
          "slug": "get-loci-names"
        },
        {
          "level": 3,
          "title": "View genotypes at a locus",
          "slug": "view-genotypes-at-a-locus"
        },
        {
          "level": 2,
          "title": "View genotypes by sample (or anything)",
          "slug": "view-genotypes-by-sample-or-anything"
        },
        {
          "level": 2,
          "title": "Missing Data",
          "slug": "missing-data"
        }
      ],
      "content": "# Viewing and Sorting\n\nThe functions here help you inspect your `PopData` and pull information from it easily.\n\n## Individuals / Samples\n\n### view individuals' names\n\n```julia\nsamples(data::PopData)\n```\n\nView individual/sample names in a `PopData`. \n:::: tabs board-card stretch\n::: tab samples\n``` julia\njulia> samples(sharks)\n```\n:::\n::: tab output\n```\n212-element Array{String,1}:\n \"cc_001\" \n \"cc_002\" \n \"cc_003\" \n \"cc_005\" \n \"cc_007\" \n \"cc_008\" \n \"cc_009\" \n \"cc_010\" \n \"cc_012\" \n \"cc_013\" \n ⋮        \n \"seg_023\"\n \"seg_024\"\n \"seg_025\"\n \"seg_026\"\n \"seg_027\"\n \"seg_028\"\n \"seg_029\"\n \"seg_030\"\n \"seg_031\"\n```\n:::\n::::\n\n\n## Sorting\n\n```julia\nreindex(data::PopData, col::Union{String, Symbol})\n```\n\nBy default, the `loci` table of `PopData` is sorted by the `name` column. For performance or convenience reasons, you can sort it using any column you want. This will sort the `loci` table of a `PopData` object by column `col` and return new `PopData` object, keeping the original intact. The column names can be Strings or Symbols.\n\n:::: tabs board-card stretch\n::: tab sort\n```julia\nsorted_sharks = reindex(sharks, :population)\n```\n:::\n::::\n\n\n## Display Specific Loci and/or Samples\n\n### Get loci names\n\n```julia\nloci(data::PopData)\n```\n\nReturns a vector of strings of the loci names in a `PopData`\n:::: tabs board-card stretch\n::: tab loci\n```julia\njulia> loci(sharks)\n```\n:::\n::: tab output\n```\n2213-element Array{String,1}:\n \"contig_35208\"\n \"contig_23109\"\n \"contig_4493\" \n \"contig_10742\"\n \"contig_14898\"\n \"contig_8483\" \n \"contig_8065\" \n \"contig_14708\"\n \"contig_2307\" \n ⋮             \n \"contig_24711\"\n \"contig_18959\"\n \"contig_43517\"\n \"contig_27356\"\n \"contig_475\"  \n \"contig_19384\"\n \"contig_22368\"\n \"contig_2784\" \n```\n:::\n::::\n\n### View genotypes at a locus\n\n```julia\nlocus(data::PopData, locus::String)\n```\n\nDefault shows all genotypes for all individuals. Returns a Vector.\n:::: tabs board-card stretch\n::: tab all loci\n``` julia\njulia> locus(sharks, \"contig_2784\")\n```\n:::\n::: tab output\n```\n212-element view(::Array{Union{Missing, Tuple{Int8,Int8}},1}, [2213, 4426, 6639, 8852, 11065, 13278, 15491, 17704, 19917, 22130  …  449239, 451452, 453665, 455878, 458091, 460304, 462517, 464730, 466943, 469156]) with eltype Union{Missing, Tuple{Int8,Int8}}:\n (1, 1) \n (1, 1) \n (1, 1) \n (1, 1) \n (1, 1) \n (1, 1) \n (1, 1) \n (1, 1) \n ⋮      \n (1, 1) \n (1, 1) \n (1, 1) \n (1, 1) \n missing\n (1, 1) \n (1, 1) \n (1, 1) \n```\n\n::: tip returning a view\nThe `locus` function gives a `view` into the genotype section of the `loci` table.. The text above the  output is isn't anything to be worried about-- it's indicating you are looking at a `view` of a column of the table and that it's not returning a new vector.\n:::\n::::\n\n## View genotypes by sample (or anything)\n\nThis can be done fairly easily using JuliaDBMeta macro `@where`\n:::: tabs board-card stretch\n::: tab single sample\n```julia\njulia> @where sharks.loci :name == \"cc_001\"\nTable with 2213 rows, 4 columns:\nname      population        locus           genotype\n────────────────────────────────────────────────────\n\"cc_001\"  \"Cape Canaveral\"  \"contig_35208\"  (1, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_23109\"  (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_4493\"   (1, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_10742\"  (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_14898\"  (1, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_8483\"   (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_8065\"   (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_14708\"  (1, 1)\n⋮\n\"cc_001\"  \"Cape Canaveral\"  \"contig_43517\"  (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_27356\"  (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_475\"    (1, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_19384\"  (2, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_22368\"  (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_2784\"   (1, 1)\n```\n:::\n::: tab multiple samples\n```julia\njulia> @where sharks.loci :name in [\"cc_001\", \"cc_002\"]\nTable with 4426 rows, 4 columns:\nname      population        locus           genotype\n────────────────────────────────────────────────────\n\"cc_001\"  \"Cape Canaveral\"  \"contig_35208\"  (1, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_23109\"  (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_4493\"   (1, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_10742\"  (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_14898\"  (1, 2)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_8483\"   (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_8065\"   (1, 1)\n\"cc_001\"  \"Cape Canaveral\"  \"contig_14708\"  (1, 1)\n⋮\n\"cc_002\"  \"Cape Canaveral\"  \"contig_43517\"  (1, 1)\n\"cc_002\"  \"Cape Canaveral\"  \"contig_27356\"  (1, 1)\n\"cc_002\"  \"Cape Canaveral\"  \"contig_475\"    (1, 2)\n\"cc_002\"  \"Cape Canaveral\"  \"contig_19384\"  (2, 2)\n\"cc_002\"  \"Cape Canaveral\"  \"contig_22368\"  (1, 1)\n\"cc_002\"  \"Cape Canaveral\"  \"contig_2784\"   (1, 1)\n```\n:::\n::: tab name and locus\nIt also means that you can combine different queries with \"and\" `&&` and \"or\" `||`. Here is an example of an approach combining a name and locus criteria:\n\n```julia\njulia> @where sharks.loci :name in [\"cc_001\", \"cc_002\"] && :locus == \"contig_2784\"\nTable with 2 rows, 4 columns:\nname      population        locus          genotype\n───────────────────────────────────────────────────\n\"cc_001\"  \"Cape Canaveral\"  \"contig_2784\"  (1, 1)\n\"cc_002\"  \"Cape Canaveral\"  \"contig_2784\"  (1, 1)\n```\n:::\n::::\n\n\n## Missing Data\n\n```julia\nmissing(data::PopData; mode::String = \"sample\")\n```\n\nGet missing genotype information in a `PopData`. Specify a `mode` of operation to return a DataFrame corresponding with that missing information type.\n\n| mode     | alternative name | what it does                                                 |\n| -------- | ---------------- | ------------------------------------------------------------ |\n| `\"sample\"` | `\"individual\"`     | returns a count and list of missing loci per individual (default) |\n| `\"pop\"`    | `\"population\"`     | returns a count of missing genotypes per population          |\n| `\"locus\"`  | `\"loci\"`           | returns a count of missing genotypes per locus               |\n| `\"full\"`   | `\"detailed\"`       | returns a count of missing genotypes per locus per population |\n\n:::: tabs board-card stretch\n::: tab sample\n```\njulia> missing(sharks)\nTable with 212 rows, 2 columns:\nname       missing\n──────────────────\n\"cc_001\"   124\n\"cc_002\"   94\n\"cc_003\"   100\n\"cc_005\"   0\n\"cc_007\"   2\n\"cc_008\"   1\n\"cc_009\"   2\n\"cc_010\"   1\n⋮\n\"seg_026\"  0\n\"seg_027\"  2\n\"seg_028\"  25\n\"seg_029\"  0\n\"seg_030\"  1\n\"seg_031\"  1\n```\n:::\n::: tab pop\n```\njulia> missing(sharks, mode = \"pop\")\nTable with 7 rows, 2 columns:\npopulation        missing\n─────────────────────────\n\"Florida Keys\"    782\n\"Cape Canaveral\"  666\n\"Mideast Gulf\"    379\n\"Georgia\"         744\n\"Northeast Gulf\"  93\n\"Southeast Gulf\"  1504\n\"South Carolina\"  480\n```\n:::\n::: tab locus\n```\njulia> missing(sharks, mode = \"locus\")\nTable with 2213 rows, 2 columns:\nlocus           missing\n───────────────────────\n\"contig_35208\"  0\n\"contig_23109\"  6\n\"contig_4493\"   3\n\"contig_10742\"  2\n\"contig_14898\"  0\n\"contig_8483\"   0\n\"contig_8065\"   0\n\"contig_14708\"  1\n⋮\n\"contig_43517\"  6\n\"contig_27356\"  2\n\"contig_475\"    0\n\"contig_19384\"  5\n\"contig_22368\"  3\n\"contig_2784\"   7\n```\n:::\n::: tab full\n```tab\njulia> missing(sharks, mode = \"full\")\nTable with 15491 rows, 3 columns:\nlocus           population        missing\n─────────────────────────────────────────\n\"contig_35208\"  \"Florida Keys\"    0\n\"contig_35208\"  \"Cape Canaveral\"  0\n\"contig_35208\"  \"Mideast Gulf\"    0\n\"contig_35208\"  \"Georgia\"         0\n\"contig_35208\"  \"Northeast Gulf\"  0\n\"contig_35208\"  \"Southeast Gulf\"  0\n\"contig_35208\"  \"South Carolina\"  0\n\"contig_23109\"  \"Florida Keys\"    0\n⋮\n\"contig_2784\"   \"Cape Canaveral\"  0\n\"contig_2784\"   \"Mideast Gulf\"    1\n\"contig_2784\"   \"Georgia\"         1\n\"contig_2784\"   \"Northeast Gulf\"  1\n\"contig_2784\"   \"Southeast Gulf\"  1\n\"contig_2784\"   \"South Carolina\"  0\n```\n:::\n::::\n::: tip alternative names\nEach `mode` has an extra synonymous (alternative) name just because we can and want you to have the option of more explicitly legible code. If you get the `mode` wrong, it will let you know with an error message and run the default `\"sample\"` mode anyway.\n:::"
    }
  ],
  "themeConfig": {
    "logo": "/images/logo_icon.png",
    "flexSearchOptions": {},
    "nav": [
      {
        "text": "Home",
        "link": "/"
      },
      {
        "text": "About",
        "link": "/guide/about"
      },
      {
        "text": "Docs",
        "link": "/guide/"
      },
      {
        "text": "Contribute",
        "link": "/community"
      },
      {
        "text": "GitHub",
        "link": "https://github.com/pdimens/PopGen.jl"
      }
    ],
    "sidebar": [
      {
        "title": "Getting Started",
        "collapsable": true,
        "sidebarDepth": 1,
        "children": [
          "/guide/",
          "/guide/install",
          "/guide/comparison",
          "/guide/popobj_type",
          "/guide/other_types"
        ]
      },
      {
        "title": "Importing Data",
        "collapsable": true,
        "sidebarDepth": 2,
        "children": [
          "/guide/io/file_import",
          "/guide/io/delimited",
          "/guide/io/genepop",
          "/guide/io/variantcall",
          "/guide/io/datasets"
        ]
      },
      {
        "title": "Tutorials",
        "collapsable": true,
        "sidebarDepth": 1,
        "children": [
          "/tutorials/manipulate",
          "/tutorials/accessing_popdata",
          "/tutorials/view_and_sort",
          "/tutorials/location_and_pop",
          "/tutorials/exclusion"
        ]
      },
      {
        "title": "Analyses",
        "collapsable": true,
        "sidebarDepth": 1,
        "children": [
          "/analyses/hardyweinberg",
          "/analyses/relatedness"
        ]
      }
    ],
    "docsRepo": "pdimens/popgen.jl",
    "docsDir": "docs",
    "docsBranch": "master",
    "editLinks": true,
    "editLinkText": "Help us improve this page!",
    "searchPlaceholder": "Search the docs..."
  }
}