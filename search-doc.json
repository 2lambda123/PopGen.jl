[{"title":"A bit about FST","type":0,"sectionRef":"#","url":"/PopGen.jl/blog/fst","content":"","keywords":""},{"title":"What is FST?‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/fst#what-is-fst","content":"To understand FST, we need to start with F, the inbreeding coefficient devised by brilliant-but-ethically-questionable Sewall Wright. The F coefficient was a mathematically simple way to understand the level of inbreeding in a group, originally described for cattle breeds (the üêÑ part isn't relevant, but it's a fun fact). There were three circumstantial versions of F, denoted by very straightforward subscripted letters: FIT, FIS, FST. The I stands for Individual, S for Subpopulation, T for Total. The combination of letters explains what relationship you are measuring: FIT was the comparison of F for an Individual vs the Total, FIS was the comparison of F for an Individual vs a Subpopulation. Logically, FST would then mean you were looking at F for Subpopulations vs the Total, which is where population geneticists get all excited. The values range from 0 to 1, with 0 being panmixia (fully mixed) and 1 being complete isolation. Although it seems like it would be linear, it's not-- Wright considered 0.125 to be the cutoff between panmictic and divergent. If one was to calculate FST for one large group of individuals and get a value &gt;0.125, this would suggest there is population subdivision happening (exciting!!). "},{"title":"Pairwise FST‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/fst#pairwise-fst","content":"Going one step further, you can narrow how you calculate FST to identify different trends. A &quot;pairwise&quot; FST is when you calculate FST for only a pair of populations at a time. With a pairwise FST, you are now testing if two populations are panmictic or divergent with each other. Depending on your study system and the questions you're trying to answer, this can be extremely valuable information. From a genetic standpoint, it looks kinda like this: This is an over-simplified system (diploid, single locus, biallelic, ignoring Hardy-Weinberg stuff), but it demonstrates the point. When you are investigating two groups, if they are both completely heterozygous for the locus (for the same alleles), you would assume the groups are fully mixed (FST = 0). And that makes sense, right? Given the information required to calculate FST, it's a reasonable conclusion to say those alleles are constantly shared between the groups. And the opposite then should be true too: if both groups are completely fixed for different alleles (FST = 1), then they clearly aren't sharing alleles with each other. "},{"title":"Pitfalls‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/fst#pitfalls","content":"Like I alluded to in the opening paragraph, FST (and it's derivatives) aren't a golden rule. There are natural phenomena that FST cannot account for, which may lead to misleading results or incorrect interpretations of results. For one, there are Hardy-Weinberg assumptions, so the presence of kin, overlapping generations, etc. kinda messes things up. Another is consideration is that the genetic data we collect now is only a snapshot in time. If two populations are completely isolated from one another and have been for generations, but are long lived and slow to evolve, then FST may mislead you into believing they are panmictic (that happened in my shark study). These are just a few examples and there are more. "},{"title":"Significance testing‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/fst#significance-testing","content":"One way of being more rigorous with FST values is significance testing (you know, generating those p-values everyone loves so much). So the question is, how do we do that? One common (frequentist) solution is permutation testing. The rationale is this: we get some kind of observed FST with our samples arranged in their natural populations, so would that FST look the same if we shuffled the samples up? Honestly, that's the gist of it. We calculate our observed FST value, then we randomly shuffle the samples into two new populations and recalculate the pairwise FST for the new population pair. Then we just keep shuffling and recalculating FST a few thousands of times. After so many iterations, we compare how many times our observed (original) FST value was greater than the permuted FST values. This is known as a one-tailed test, since we're only interested in knowing if our observed FST is greater than randomness, meaning we're making the case that FST (and therefore divergence) is highest with our samples in this non-random population configuration. "},{"title":"Other means‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/fst#other-means","content":"The field of population genetics has expanded tremendously since the Fisher and Wright era, and there are now all sorts of interesting ways to identify population subdivision. Each method has its strengths and weaknesses, which is why it's good practice to try multiple things and find agreement between methods. At the time of this writing, PopGen.jl can calculate pairwise FST and perform significance testing using the Nei 1987, Weir &amp; Cockerham 1984, and Hudson et al. 1992 methods. If you're interested in contributing to PopGen.jl, we'd love to have you! "},{"title":"Logo Graveyard","type":0,"sectionRef":"#","url":"/PopGen.jl/blog/logos","content":"","keywords":""},{"title":"What is that logo?‚Äã","type":1,"pageTitle":"Logo Graveyard","url":"/PopGen.jl/blog/logos#what-is-that-logo","content":"If you haven't guessed already, it's the beloved Punnett Square! Nothing screams genetics like everyone's first entry-level genetic diagram! "},{"title":"The Logo Graveyard‚Äã","type":1,"pageTitle":"Logo Graveyard","url":"/PopGen.jl/blog/logos#the-logo-graveyard","content":"While this is completely unrelated to anything important about population genetics or Julia, I (Pavel) want you all to understand the logo-development process that led us to our logo so you can feel my struggle. The process is as follows: Jason and I spitball ideas I procrastinate real work and open up Inkscape to draft some ideas I compose 1-3 versions of an idea and send it to Jason if Jason != veto for i in 1:5 Jason critiques and suggests changes I makes the changes end end Jason and I finalize the idea! Weeks pass and I'm not quite satisfied and we start at 1 again I'm happy to say that we love the Punnett Square and it's for keeps, but have a look at the scrapped ideas as a little walk down memory lane:  "},{"title":"A bit about FST","type":0,"sectionRef":"#","url":"/PopGen.jl/blog","content":"","keywords":""},{"title":"What is FST?‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog#what-is-fst","content":"To understand FST, we need to start with F, the inbreeding coefficient devised by brilliant-but-ethically-questionable Sewall Wright. The F coefficient was a mathematically simple way to understand the level of inbreeding in a group, originally described for cattle breeds (the üêÑ part isn't relevant, but it's a fun fact). There were three circumstantial versions of F, denoted by very straightforward subscripted letters: FIT, FIS, FST. The I stands for Individual, S for Subpopulation, T for Total. The combination of letters explains what relationship you are measuring: FIT was the comparison of F for an Individual vs the Total, FIS was the comparison of F for an Individual vs a Subpopulation. Logically, FST would then mean you were looking at F for Subpopulations vs the Total, which is where population geneticists get all excited. The values range from 0 to 1, with 0 being panmixia (fully mixed) and 1 being complete isolation. Although it seems like it would be linear, it's not-- Wright considered 0.125 to be the cutoff between panmictic and divergent. If one was to calculate FST for one large group of individuals and get a value &gt;0.125, this would suggest there is population subdivision happening (exciting!!). "},{"title":"Pairwise FST‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog#pairwise-fst","content":"Going one step further, you can narrow how you calculate FST to identify different trends. A &quot;pairwise&quot; FST is when you calculate FST for only a pair of populations at a time. With a pairwise FST, you are now testing if two populations are panmictic or divergent with each other. Depending on your study system and the questions you're trying to answer, this can be extremely valuable information. From a genetic standpoint, it looks kinda like this: This is an over-simplified system (diploid, single locus, biallelic, ignoring Hardy-Weinberg stuff), but it demonstrates the point. When you are investigating two groups, if they are both completely heterozygous for the locus (for the same alleles), you would assume the groups are fully mixed (FST = 0). And that makes sense, right? Given the information required to calculate FST, it's a reasonable conclusion to say those alleles are constantly shared between the groups. And the opposite then should be true too: if both groups are completely fixed for different alleles (FST = 1), then they clearly aren't sharing alleles with each other. "},{"title":"Pitfalls‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog#pitfalls","content":"Like I alluded to in the opening paragraph, FST (and it's derivatives) aren't a golden rule. There are natural phenomena that FST cannot account for, which may lead to misleading results or incorrect interpretations of results. For one, there are Hardy-Weinberg assumptions, so the presence of kin, overlapping generations, etc. kinda messes things up. Another is consideration is that the genetic data we collect now is only a snapshot in time. If two populations are completely isolated from one another and have been for generations, but are long lived and slow to evolve, then FST may mislead you into believing they are panmictic (that happened in my shark study). These are just a few examples and there are more. "},{"title":"Significance testing‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog#significance-testing","content":"One way of being more rigorous with FST values is significance testing (you know, generating those p-values everyone loves so much). So the question is, how do we do that? One common (frequentist) solution is permutation testing. The rationale is this: we get some kind of observed FST with our samples arranged in their natural populations, so would that FST look the same if we shuffled the samples up? Honestly, that's the gist of it. We calculate our observed FST value, then we randomly shuffle the samples into two new populations and recalculate the pairwise FST for the new population pair. Then we just keep shuffling and recalculating FST a few thousands of times. After so many iterations, we compare how many times our observed (original) FST value was greater than the permuted FST values. This is known as a one-tailed test, since we're only interested in knowing if our observed FST is greater than randomness, meaning we're making the case that FST (and therefore divergence) is highest with our samples in this non-random population configuration. "},{"title":"Other means‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog#other-means","content":"The field of population genetics has expanded tremendously since the Fisher and Wright era, and there are now all sorts of interesting ways to identify population subdivision. Each method has its strengths and weaknesses, which is why it's good practice to try multiple things and find agreement between methods. At the time of this writing, PopGen.jl can calculate pairwise FST and perform significance testing using the Nei 1987, Weir &amp; Cockerham 1984, and Hudson et al. 1992 methods. If you're interested in contributing to PopGen.jl, we'd love to have you! "},{"title":"Relatedness Tutorial","type":0,"sectionRef":"#","url":"/PopGen.jl/blog/relatedness","content":"","keywords":""},{"title":"Getting Started‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#getting-started","content":"In a population genetics study, you often need to identify if there are kin in your data. This may be necessary because you are trying to remove kin from your data (because of Hardy-Weinberg assumptions), or maybe kinship is a central interest in your study. Either way, the goal of this tutorial is to provide you with a basic tutorial on using PopGen.jl to perform a relatedness analysis, which is sometimes called a kinship analysis. To follow along, you'll need to have Julia, along with the packages PopGen.jl, PopGenSims.jl, and StatsBase.jl installed. We'll be using the nancycats data because it's smaller than gulfsharks, so things should be a lot quicker. using PopGen, PopGenSims, StatsBase julia&gt; cats = @nancycats PopData{Diploid, 9 Microsatellite Loci} Samples: 237 Populations: 17  "},{"title":"Estimators‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#estimators","content":"Like Coancestry and the R packages that wrap it (i.e. relate, related), PopGen.jl provides a whole bunch of relatedness estimators that you can choose from for your data. Unfortunately, there is no right answer and you will need to use your discretion. Some people choose an estimator based on the heterozygosity of the data, others choose one based on more liberal or conservative values, and there are yet more criteria one can consider for choosing an estimator. To keep things simple, we're going to use LynchLi. Why? Because I'm the one writing this tutorial, and I said so üòÅ. "},{"title":"The Steps‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#the-steps","content":""},{"title":"1. Calculate pairwise relatedness‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#1-calculate-pairwise-relatedness","content":"This seems pretty obvious, but it needs to be said. In order to do the analysis, you need you get the pairwise relatedness values for the individuals of interest in your data. To keep things simple, we're going to do an all-by-all comparison. But, we also want to boostrap the pairs to create confidence intervals (&quot;CI&quot;) for each pair, so let's talk about that. "},{"title":"2. Bootstrap to calculate CI‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#2-bootstrap-to-calculate-ci","content":"It would behoove us to bootstrap the loci in a pairwise comparison n number of times so we can create a confidence interval for the relatedness estimates for each pair. This inflates the runtime of the analysis substantially, but it's a very useful method in making sense of our estimates. If one was to be conservative (and we generally are), then we would reject an estimate for a pair whose CI includes zero. In PopGen.jl, the estimates and bootstrapping are done all at once to minimize processing time, so the command for that would be julia&gt; rel_out = kinship(cats, method = LynchLi, iterations = 1000)  By default, the kinship function uses a 95% CI (interval = (0.025, 0.975)), but you can change that with interval = (low,high) where low and high are decimals of your quantiles. The kinship() function returns a NamedTuple of dataframes whenever you are bootstrapping, where each element shares its name with the method used, so in this case, we can access our results with rel_out.LynchLi. relatednessplotting julia&gt; rel_out.LynchLi 27966√ó8 DataFrame Row ‚îÇ sample_1 sample_2 n_loci LynchLi LynchLi_mean LynchLi_median LynchLi_S ‚ãØ ‚îÇ String String Int64 Float64? Float64? Float64? Float64? ‚ãØ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ N215 N216 8 0.743535 0.747288 0.748042 0.75344 ‚ãØ 2 ‚îÇ N215 N217 8 0.230605 0.233593 0.240085 0.34187 3 ‚îÇ N215 N218 8 0.230605 0.230507 0.221861 0.32161 4 ‚îÇ N215 N219 8 0.230605 0.23601 0.23567 0.32782 5 ‚îÇ N215 N220 8 0.333191 0.33798 0.350492 0.39898 ‚ãØ 6 ‚îÇ N215 N221 8 0.589656 0.594223 0.601308 0.61945 7 ‚îÇ N215 N222 8 0.0254328 0.0347216 0.0262021 0.21408 8 ‚îÇ N215 N223 8 0.333191 0.329983 0.331411 0.38402 9 ‚îÇ N215 N224 8 -0.0258602 -0.021062 -0.0301579 0.21112 ‚ãØ 10 ‚îÇ N215 N7 8 -0.282325 -0.27967 -0.288337 0.33611 11 ‚îÇ N215 N141 8 -0.0771532 -0.0796867 -0.083113 0.21261 12 ‚îÇ N215 N142 8 0.0254328 0.0302549 0.0330718 0.23957 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ã± 27955 ‚îÇ N295 N289 7 0.322731 0.347021 0.34118 0.41168 ‚ãØ 27956 ‚îÇ N295 N290 7 0.153414 0.160102 0.164866 0.22862 27957 ‚îÇ N296 N297 7 -0.0159038 -0.0182747 -0.0187108 0.16981 27958 ‚îÇ N296 N281 7 0.0405353 0.037025 0.0422647 0.15294 27959 ‚îÇ N296 N289 7 0.322731 0.328379 0.337317 0.35578 ‚ãØ 27960 ‚îÇ N296 N290 7 0.153414 0.152384 0.16194 0.19131 27961 ‚îÇ N297 N281 7 -0.0159038 -0.0128349 -0.0303449 0.21030 27962 ‚îÇ N297 N289 7 0.37917 0.392517 0.392818 0.45139 27963 ‚îÇ N297 N290 7 0.435609 0.437829 0.450044 0.47027 ‚ãØ 27964 ‚îÇ N281 N289 8 0.20428 0.21279 0.207425 0.29611 27965 ‚îÇ N281 N290 7 0.37917 0.386583 0.390585 0.45471 27966 ‚îÇ N289 N290 7 0.209853 0.217811 0.222894 0.28649 2 columns and 27942 rows omitted  "},{"title":"3. Create CI's for the sibships‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#3-create-cis-for-the-sibships","content":"There's more??? The next set of steps seem like a lot more work, so allow me to explain. The estimators all generally give you some value between 0-1 (or 0-0.5, same idea) and you can intuit that certain values mean certain things, like that 0 is &quot;unrelated&quot;, 0.25 is &quot;half-sib&quot;, and 0.5 is &quot;full-sib&quot;. However, those are fixed values, so how do we know how far we can deviate from 0.25 (for example) and still call our pair half-siblings? Instead of hand-waving, we can create confidence intervals from simulated data to act as sibship ranges for our data. If this doesn't make sense yet, it will below. Promise! i. simulate known sibship pairs‚Äã Next, we need to further contextualize what out estimates actually mean, and we need to devise a rigorous and defensible method to define the sibling-ship (&quot;sibship&quot;) of a pair of samples as unrelated, half-sibs, or full-sibs. To do this, we're going to use PopGenSims.jl to simulate data based on the allele frequencies in our data. What simulatekin does is simulate individuals based on the allele frequencies in your PopData, then simulate offspring of a particular siblingship resulting from the &quot;mating&quot; of those individuals. For example, when you specify &quot;fullsib&quot;, it generates two offspring resulting from two parents, n number of times. We want to do this for each of the three kinds of sibships. julia&gt; kin_sims = simulatekin(cats, fullsib = 500, halfsib = 500, unrelated = 500) PopData{Diploid, 9 Microsatellite Loci} Samples: 3000 Populations: 3  We can keep all three simulated relationships together, but it will be easier to explain things (for instructional purposes) if we don't, so let's split out each into its own PopData. julia&gt; fullsib = kin_sims[genodata(kin_sims).population .== &quot;fullsib&quot;] ; julia&gt; halfsib = kin_sims[genodata(kin_sims).population .== &quot;halfsib&quot;] ; julia&gt; unrelated = kin_sims[genodata(kin_sims).population .== &quot;unrelated&quot;] ;  ii. get relatedness estimates for the simulated data‚Äã Next, we want to get the relatedness estimate for each simulated pair of &quot;known&quot; sibship. We are only interested in the values for the simulated pairs and not samples across pairs. If you aren't sure why that is, think of it this way: we're trying to create a range of values where we can confidently say unknown things are full-sibs (or half-sib, etc.), so we want to know what range of values we get from a bunch of known fullsib pairs, not the unknown relationships of samples between pairs. It would a nightmare to manually specify only 2 individuals at a time into kinship(). Instead, the function has a shortcut built into it that will recognize the population names generated from simulatekin and only give you relatedness estimates for those pairs. So, we just need to run it once for each of our simulations, this time without bootstrapping because we are only interested in the estimates. Make sure to use the same estimator! The run will be a lot faster this time because it only needs to calculate estimates for 500 pairs each time (our n from above) and without bootstrapping. When not bootstrapping, kinship() returns a dataframe (versus a NamedTuple of dataframes). unrelated relatednesshalfsib relatednessfullsib relatedness julia&gt; un_sims_rel = kinship(unrelated_sims, method = LynchLi) 500√ó4 DataFrame Row ‚îÇ sample_1 sample_2 n_loci LynchLi ‚îÇ String String Int64 Float64? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ sim001_unrelated_1 sim001_unrelated_2 9 -0.11419 2 ‚îÇ sim002_unrelated_1 sim002_unrelated_2 9 -0.337028 3 ‚îÇ sim003_unrelated_1 sim003_unrelated_2 9 -0.0696222 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 498 ‚îÇ sim498_unrelated_1 sim498_unrelated_2 9 0.019513 499 ‚îÇ sim499_unrelated_1 sim499_unrelated_2 9 0.019513 500 ‚îÇ sim500_unrelated_1 sim500_unrelated_2 9 0.019513 494 rows omitted  And if we wanted to plot what that looks like (optional): using Plots, StatsPlots julia&gt; density(rel_out.LynchLi.LynchLi, label = &quot;real data&quot;, color = :grey, fill = (0, :grey)) julia&gt; density!(un_sims_rel.LynchLi, label = &quot;unrelated&quot;) julia&gt; density!(half_sims_rel.LynchLi, label = &quot;halfsib&quot;, color = :blue) julia&gt; density!(full_sims_rel.LynchLi, label = &quot;fullsib&quot;, color = :black) julia&gt; title!(&quot;relatedness estimates on simulated and real data&quot;)   Hopefully by now you are starting to contextualize why we're doing all of this. The distributions generated from our simulated data are giving us a better indication of what &quot;unrelated&quot;, &quot;halfsib&quot;, and &quot;fullsib&quot; estimates look like in our data. iii. sibship intervals‚Äã What we just did is create null distributions for each sibship relationship, so now all that's left is to get a confidence interval from each. Keep in mind that your values will be a bit different due to the randomization involved with many of these steps. julia&gt; unrelated_ci = quantile(un_sims_rel.LynchLi, (0.025, 0.975)) (-0.3380513384854698, 0.33097433075726507) julia&gt; halfsibs_ci = quantile(half_sims_rel.LynchLi, (0.025, 0.975)) (-0.06652262584414452, 0.5556155725649398) julia&gt; fullsibs_ci = quantile(full_sims_rel.LynchLi, (0.025, 0.975)) (0.1989727186688347, 0.8219939374819633)  So, given our data and the simulations we made, we can now make a reasonable assumption regarding the ranges for each sibship relationship: Relationship\tLower Bound\tUpper Boundunrelated\t-0.338\t0.331 half sibling\t-0.066\t0.555 full sibling\t0.199\t0.82 "},{"title":"4. Finally, the data assessment‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#4-finally-the-data-assessment","content":"Now that we have our relatedness estimates and the acceptable sibship ranges given our data, we can see where our data falls.Now, we can say that a particular sample pair is unrelated/halfsib/fullsib if: that pair's confidence interval does not include zero and that pair's estimate falls within any of the three calculate ranges Unfortunately, the ranges overlap quite a bit, which makes interpretation difficult, so it may be suitable to use a different estimator. "},{"title":"Closing remarks‚Äã","type":1,"pageTitle":"Relatedness Tutorial","url":"/PopGen.jl/blog/relatedness#closing-remarks","content":"There is more that can be done for relatedness, like network analysis. However, this tutorial covers what we consider a reasonable way to assess kinship in population genetic studies. If removing kin is your ultimate goal, consider the effects doing that may have on the analyses you are looking to do. Additionally, consider which individual of a pair you would remove and why. If you were curious as to how many identical loci a pair of samples may share, you can check that using pairwiseidentical(). Good luck! "},{"title":"A bit about FST","type":0,"sectionRef":"#","url":"/PopGen.jl/blog/tags/info","content":"","keywords":""},{"title":"What is FST?‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/tags/info#what-is-fst","content":"To understand FST, we need to start with F, the inbreeding coefficient devised by brilliant-but-ethically-questionable Sewall Wright. The F coefficient was a mathematically simple way to understand the level of inbreeding in a group, originally described for cattle breeds (the üêÑ part isn't relevant, but it's a fun fact). There were three circumstantial versions of F, denoted by very straightforward subscripted letters: FIT, FIS, FST. The I stands for Individual, S for Subpopulation, T for Total. The combination of letters explains what relationship you are measuring: FIT was the comparison of F for an Individual vs the Total, FIS was the comparison of F for an Individual vs a Subpopulation. Logically, FST would then mean you were looking at F for Subpopulations vs the Total, which is where population geneticists get all excited. The values range from 0 to 1, with 0 being panmixia (fully mixed) and 1 being complete isolation. Although it seems like it would be linear, it's not-- Wright considered 0.125 to be the cutoff between panmictic and divergent. If one was to calculate FST for one large group of individuals and get a value &gt;0.125, this would suggest there is population subdivision happening (exciting!!). "},{"title":"Pairwise FST‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/tags/info#pairwise-fst","content":"Going one step further, you can narrow how you calculate FST to identify different trends. A &quot;pairwise&quot; FST is when you calculate FST for only a pair of populations at a time. With a pairwise FST, you are now testing if two populations are panmictic or divergent with each other. Depending on your study system and the questions you're trying to answer, this can be extremely valuable information. From a genetic standpoint, it looks kinda like this: This is an over-simplified system (diploid, single locus, biallelic, ignoring Hardy-Weinberg stuff), but it demonstrates the point. When you are investigating two groups, if they are both completely heterozygous for the locus (for the same alleles), you would assume the groups are fully mixed (FST = 0). And that makes sense, right? Given the information required to calculate FST, it's a reasonable conclusion to say those alleles are constantly shared between the groups. And the opposite then should be true too: if both groups are completely fixed for different alleles (FST = 1), then they clearly aren't sharing alleles with each other. "},{"title":"Pitfalls‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/tags/info#pitfalls","content":"Like I alluded to in the opening paragraph, FST (and it's derivatives) aren't a golden rule. There are natural phenomena that FST cannot account for, which may lead to misleading results or incorrect interpretations of results. For one, there are Hardy-Weinberg assumptions, so the presence of kin, overlapping generations, etc. kinda messes things up. Another is consideration is that the genetic data we collect now is only a snapshot in time. If two populations are completely isolated from one another and have been for generations, but are long lived and slow to evolve, then FST may mislead you into believing they are panmictic (that happened in my shark study). These are just a few examples and there are more. "},{"title":"Significance testing‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/tags/info#significance-testing","content":"One way of being more rigorous with FST values is significance testing (you know, generating those p-values everyone loves so much). So the question is, how do we do that? One common (frequentist) solution is permutation testing. The rationale is this: we get some kind of observed FST with our samples arranged in their natural populations, so would that FST look the same if we shuffled the samples up? Honestly, that's the gist of it. We calculate our observed FST value, then we randomly shuffle the samples into two new populations and recalculate the pairwise FST for the new population pair. Then we just keep shuffling and recalculating FST a few thousands of times. After so many iterations, we compare how many times our observed (original) FST value was greater than the permuted FST values. This is known as a one-tailed test, since we're only interested in knowing if our observed FST is greater than randomness, meaning we're making the case that FST (and therefore divergence) is highest with our samples in this non-random population configuration. "},{"title":"Other means‚Äã","type":1,"pageTitle":"A bit about FST","url":"/PopGen.jl/blog/tags/info#other-means","content":"The field of population genetics has expanded tremendously since the Fisher and Wright era, and there are now all sorts of interesting ways to identify population subdivision. Each method has its strengths and weaknesses, which is why it's good practice to try multiple things and find agreement between methods. At the time of this writing, PopGen.jl can calculate pairwise FST and perform significance testing using the Nei 1987, Weir &amp; Cockerham 1984, and Hudson et al. 1992 methods. If you're interested in contributing to PopGen.jl, we'd love to have you! "},{"title":"Installation","type":0,"sectionRef":"#","url":"/PopGen.jl/docs","content":"","keywords":""},{"title":"Using PopGen‚Äã","type":1,"pageTitle":"Installation","url":"/PopGen.jl/docs#using-popgen","content":"Like all Julia packages, to activate PopGen.jl, simply run: julia&gt; using PopGen  Feel free to play around with the test data in /data/ or add it to your workspace with the @nancycats and @gulfsharks commands. For ArchLinux users If you compiled Julia from source, your PopGen.jl installation may fail due to incorrectly building Arpack, which is expected to be in one place, but the compilation puts in another. Solutions: install official Julia binaries from the AUR (julia-bin), which includes a correctly bundled Arpack (recommended)if Julia was compiled from source: install julia-arpack from the AUR and make sure to delete ~/.julia/packages/Arpack if it exists. That should fix things, but sometimes it still acts up. "},{"title":"\"Installing\" the docs‚Äã","type":1,"pageTitle":"Installation","url":"/PopGen.jl/docs#installing-the-docs","content":"The magic of Docusaurus (the engine these docs are built on) lets you &quot;install&quot; this documentation as a progressive web app (fancy web shortcut) if you're using a Chromium-based browser (e.g. Chrome, Chromium, Brave, Vivaldi, Edge). Doing so gives you quick-access to these docs as easy as double-clicking an application. Here's what that looks like using the Edge browser on Windows:  which then shows up in your Start menu like a plain-regular application!  "},{"title":"Clustering","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/analyses/clustering","content":"","keywords":""},{"title":"The cluster wrapper‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#the-cluster-wrapper","content":"All of the clustering methods implemented in PopGen.jl (read below) can be accessed using a single function cluster. cluster(::PopData, method::Function; matrixtype::Symbol, kwargs...)  A convenience wrapper to perform clustering on a PopData object determined by a designated method. The chosen method must also be supplied with the appropriate keyword arguments for that method. For more information on a specific method, read more below or see its docstring in a Julia session with ?methodname (e.g., ?kmediods). The keyword argument matrixtype refers to which input matrix you would like to use for clustering, one of either :pca (default, principal components of the scaled allele frequencies) or :freq (scaled allele frequencies). Clustering Methods‚Äã Method Name\tMethod Type\tKeyword Argumentskmeans\tK-means++\tk, iterations kmedoids\tK-medoids\tk, iterations hclust\tHierarchical Clustering\tlinkage, branchorder, distance fuzzycmeans\tFuzzy C-means\tc, fuzziness, iterations dbscan\tDensity-based Spatial Clustering of Applications with Noise (DBSCAN)\tradius, minpoints, distance Examples‚Äã julia&gt; cats = @nancycats; julia&gt; cluster(cats, kmeans, iterations = 100); julia&gt; cluster(cats, dbscan, matrixtype = :freq)  The results of these clustering methods can then be used for validation using any methods available in Clustering.jl. skipping the wrapper Since the clustering methods are exported, you can technically skip the cluster wrapper and use any of the methods directly (e.g. kmeans(PopData, k = 5)), although cluster() is the preferred method. "},{"title":"Clustering Methods‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#clustering-methods-1","content":""},{"title":"K-means‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#k-means","content":"kmeans(data::PopData; k::Int64, iterations::Int64 = 100, matrixtype::Symbol = :pca)  Perform Kmeans clustering (using Kmeans++ from Arthur &amp; Vassilvitskii 2007) on a PopData object. Returns a KmeansResultobject. Use the keyword argument iterations (default: 100) to set the maximum number of iterations allowed to achieve convergence. Clustering is performed on the matrixtype principal components of the scaled allele frequencies (:pca), or just the scaled allele frequencies themselves (:freq). In both cases, missing values are replaced by the global mean allele frequency. Keyword Arguments k: the number of desired clusters, given as an Integeriterations::Int64: the maximum number of iterations to attempt to reach convergence (default: 100)matrixtype: type of input matrix to compute (default: :pca) :pca: matrix of Principal Components of :freq:freq: matrix of scaled allele frequencies  Example julia&gt; cats = @nancycats ; julia&gt; km = kmeans(cats, k = 2)   "},{"title":"K-medoids‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#k-medoids","content":"kmedoids(data::PopData; k::Int64, iterations::Int64 = 100, distance::PreMetric = euclidean, matrixtype::Symbol = :pca)  Perform K-medoids (Kaufman &amp; Rousseeuw, 1990) clustering on a PopData object. Returns a KmedoidsResultobject. Use the keyword argument iterations (default: 100) to set the maximum number of iterations allowed to achieve convergence. Clustering is performed on the matrixtype principal components of the scaled allele frequencies (:pca), or just the scaled allele frequencies themselves (:freq). In both cases, missing values are replaced by the global mean allele frequency. Keyword Arguments k: the number of desired clusters, given as an Integeriterations::Int64: the maximum number of iterations to attempt to reach convergence (default: 100)distance: type of distance matrix to calculate on matrixtype (default: euclidean) see Distances.jl for a list of options (e.g. sqeuclidean, etc.) matrixtype: type of input matrix to compute (default: :pca) :pca: matrix of Principal Components of :freq:freq: matrix of scaled allele frequencies  Example julia&gt; cats = @nancycats ; julia&gt; km = kmedoids(cats, k = 2, distance = sqeuclidean)   "},{"title":"Hierarchical Clustering‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#hierarchical-clustering","content":"hclust(data::PopData; linkage::Symbol = :single, branchorder::Symbol = :r, distance::PreMetric = euclidean, matrixtype::Symbol = :pca)  Perform hierarchical clustering (Bar-Joseph et al., 2001) on a PopData object. Returns an Hclust object, which contains many metrics but does not include cluster assignments. Usecutree(::PopData, ::Hclust; krange...) to compute the sample assignments for a range of k clusters. Clustering is performed on the matrixtype principal components of the scaled allele frequencies (:pca), or just the scaled allele frequencies themselves (:freq). In both cases, missing values are replaced by the global mean allele frequency. Keyword Arguments linkage: defines how the distances between the data points are aggregated into the distances between the clusters :single: use the minimum distance between any of the cluster members (default):average: use the mean distance between any of the cluster members:complete: use the maximum distance between any of the members:ward: the distance is the increase of the average squared distance of a point to its cluster centroid after merging the two clusters:ward_presquared: same as :ward, but assumes that the distances in the distance matrix are already squared. branchorder: algorithm to order leaves and branches (default: :r) :r: ordering based on the node heights and the original elements order (compatible with R's hclust):optimal: branches are ordered to reduce the distance between neighboring leaves from separate branches using the &quot;fast optimal leaf ordering&quot; algorithm distance: type of distance matrix to calculate on matrixtype (default: euclidean) see Distances.jl for a list of options (e.g. sqeuclidean, etc.) matrixtype: type of input matrix (default: :pca) :pca: matrix of Principal Components of :freq:freq: matrix of allele frequencies cutree‚Äã cutree(::PopData, hcres::Hclust; krange::UnitRange{Int64}, height::Union{Int64, Nothing} = nothing) cutree(::PopData, hcres::Hclust; krange::Vector{Int64}, height::Union{Int64, Nothing} = nothing)  An expansion to the Clustering.cutree method (from Clustering.jl) that performs cluster assignments over krangeon the Hclust output from hclust(). Returns a DataFrame of sample names and columns corresponding to assignments per k in krange. The PopData object is used only for retrieving the sample names. Keyword Arguments krange: the number of desired clusters, given as a vector (ex. [2,4,5]) or range (2:5)h::Integer: the height at which the tree is cut (optional)  Example julia&gt; cats = @nancycats ; julia&gt; hca = hclust(cats, branchorder = :optimal) ; julia&gt; cutree(cats, hca, krange = 2:5)   "},{"title":"Fuzzy C-means‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#fuzzy-c-means","content":"fuzzycmeans(data::PopData; c::Int64, fuzziness::Int64 = 2, iterations::Int64 = 100, matrixtype::Symbol = :pca)  Perform Fuzzy C-means clustering (Bezdek et al. 1984) on a PopData object. Returns a FuzzyCMeansResult object, which contains the assignment weights in the .weights field. Clustering is performed on the matrixtype principal components of the scaled allele frequencies (:pca), or just the scaled allele frequencies themselves (:freq). In both cases, missing values are replaced by the global mean allele frequency. Keyword Arguments c: the number of desired clusters, given as an Integerfuzziness::Integer: clusters' fuzziness, must be &gt;1 (default: 2) a fuzziness of 2 is common for systems with unknown numbers of clusters iterations::Int64: the maximum number of iterations to attempt to reach convergence (default: 100)matrixtype: type of input matrix to compute (default: :pca) :pca: matrix of Principal Components of :freq:freq: matrix of scaled allele frequencies  Example julia&gt; cats = @nancycats ; julia&gt; fuzzycats = fuzzycmeans(cats, c = 5) ;   "},{"title":"DBSCAN‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#dbscan","content":"dbscan(::PopData; radius::Float64, minpoints::Int64 = 2, distance::PreMetric = euclidean, matrixtype::Symbol = :pca)  Perform Density-based Spatial Clustering of Applications with Noise (DBSCAN: Ester et al. 1996) on a PopData object. Returns a DbscanResult object, which contains the assignments in the.assignments field. Clustering is performed on the matrixtype principal components of the scaled allele frequencies (:pca), or just the scaled allele frequencies themselves (:freq). In both cases, missing values are replaced by the global mean allele frequency. Keyword Arguments radius::Float64: the radius of a point neighborhoodminpoints::Int: the minimum number of a core point neighbors (default: 2)distance: type of distance matrix to calculate on matrixtype (default: euclidean) see Distances.jl for a list of options (e.g. sqeuclidean, etc.) matrixtype: type of input matrix (default: :pca) :pca: matrix of Principal Components:freq: matrix of allele frequencies  Example julia&gt; cats = @nancycats ; julia&gt; fuzzycats = dbscan(cats, radius = 0.5) ;   "},{"title":"Acknowledgments‚Äã","type":1,"pageTitle":"Clustering","url":"/PopGen.jl/docs/analyses/clustering#acknowledgments","content":"Much of the heavy lifting within these clustering methods are actually the result of the amazing authors and contributors of Clustering.jl and the Principal Component Analysis available from MultivariateStats.jl. "},{"title":"Pairwise F-Statistics","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/analyses/fstatistics","content":"","keywords":""},{"title":"Background‚Äã","type":1,"pageTitle":"Pairwise F-Statistics","url":"/PopGen.jl/docs/analyses/fstatistics#background","content":"Originating with Wright's FFF fixation index (inbreeding coefficient), FFF has since evolved into a whole slew of statistics used to describe the differentiation/divergence within or between groups. As you may have seen from summary(), there are a common group of these indices (FISF_{IS}FIS‚Äã, FITF_{IT}FIT‚Äã, and FSTF_{ST}FST‚Äã) that compare the FFF at various hierarchical levels. The notation is pretty straightforward: III is for individuals, TTT is the total, and SSS is for subpopulations. F-statistic\tCompares\tAgainstFISF_{IS}FIS‚Äã\tIndividual\tSubpopulation FITF_{IT}FIT‚Äã\tIndividual\tTotal FSTF_{ST}FST‚Äã\tSubpopulation\tTotal Often, we are interested in pairwise FSTF_{ST}FST‚Äã, which is a type of coefficient that helps us infer how panmictic (fully mixed) two groups of interest are. A colloquial way of phrasing that is &quot;how much genetic mixing is there between these two groups?&quot;. The value of FSTF_{ST}FST‚Äã (and its derivatives) should typically range between 0 and 1 and can be interpreted like so: FSTF_{ST}FST‚Äã value\tInterpretation0\tthe two groups are completely panmictic 1\tthe two groups are completely isolated However, it's not a linear relationship, and Wright considered 0.125 as the cutoff for when to determine populations as divergent. FSTF_{ST}FST‚Äã isn't everything An important caveat to always consider is that FSTF_{ST}FST‚Äã is just one tool to help us understand trends and not the entire picture. The genetic data we collect is just a snapshot in current time and populations can be completely isolated but still have near-zeroFSTF_{ST}FST‚Äã values for a number of reasons (slow divergence time, recent introgression, etc.). Significance testing helps add context to observed FSTF_{ST}FST‚Äã values. "},{"title":"Pairwise FST‚Äã","type":1,"pageTitle":"Pairwise F-Statistics","url":"/PopGen.jl/docs/analyses/fstatistics#pairwise-fst","content":"pairwisefst(data::PopData; method::Function, by::String = &quot;global&quot;, iterations::Int64)  Calculate pairwise FSTF_{ST}FST‚Äã between populations in a PopData object. Set iterationsto a value greater than 0 to perform a single-tailed permutation test to obtain P-values of statistical significance. Use by = &quot;locus&quot; to perform a locus-by-locus FST for population pairs (iterations and significance testing ignored). `WeirCockerham is not yet implmented for by-locus FSTF_{ST}FST‚Äã. custom output type The returned object for is a custom PairwiseFST type with the fields results (stores the dataframe of FSTF_{ST}FST‚Äã values) and method (a string of which method was used to calculate it). This was done to define a custom show method to make the results a little nicer, and so you never lose track of which method was used for the calculation. If you want to access the dataframe directly, you will need to do so with varname.results where varname is whatever you named the output. "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Pairwise F-Statistics","url":"/PopGen.jl/docs/analyses/fstatistics#arguments","content":"data::PopData: a PopData object you wish to perform the calculation on "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Pairwise F-Statistics","url":"/PopGen.jl/docs/analyses/fstatistics#keyword-arguments","content":"method::Function: which FSTF_{ST}FST‚Äã calculation method you would like to use Hudson: the Hudson et al. (1992) method (only for biallelic data)WeirCockerham: the Weir &amp; Cockerham (1984) method (default)Nei: Nei (1987) genetic distance method by::String: perfrom a &quot;global&quot; pairwise FSTF_{ST}FST‚Äã or &quot;locus&quot; for locus-by-locus (ignores significance testing)iterations::Int64: the number of iterations for signficance testing (default: 0) Examples without significance testingwith significance testingby locus julia&gt; sharks = @gulfsharks ; julia&gt; pairwisefst(sharks, method = WeirCockerham) Pairwise FST: WeirCockerham CapeCanaveral Georgia SouthCarolina FloridaKeys MideastGulf NortheastGulf SoutheastGulf ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CapeCanaveral 0.0 0.0 0.0 0.0 0.0 0.0 0.0 Georgia 0.00081 0.0 0.0 0.0 0.0 0.0 0.0 SouthCarolina -0.0003 -0.00076 0.0 0.0 0.0 0.0 0.0 FloridaKeys 0.00282 0.00202 0.00204 0.0 0.0 0.0 0.0 MideastGulf 0.00423 0.00354 0.00329 0.00042 0.0 0.0 0.0 NortheastGulf 0.00264 0.00147 0.00146 -7.0e-5 -0.00023 0.0 0.0 SoutheastGulf 0.00312 0.00222 0.00191 -3.0e-5 0.00079 0.00118 0.0  "},{"title":"Kinship","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/analyses/kinship","content":"","keywords":""},{"title":"Background‚Äã","type":1,"pageTitle":"Kinship","url":"/PopGen.jl/docs/analyses/kinship#background","content":"Sometimes you want or need to know the relatedness of individuals in a sample. Relatedness is exactly what its name implies: how related individuals are given some provided genetic information (e.g. full siblings, half siblings, etc.). Relatedness can be used in quantitative genetics to estimate heritability, additive genetic variances, and covariances. It can also be used in population genetics to study isolation-by-distance or population structure. The goal of calculating relatedness from molecular markers is to accurately estimate the proportion of the genome which is identical by descent between two individuals. With a pedigree this is &quot;relatively&quot; straightforward. However, for large, natural, populations pedigrees tend not to exist and some brilliant minds have developed various equations to estimate the relatedness from a set of molecular markers. Given two diploid individuals, there are 9 &quot;identity by descent&quot; models available between them (Jacquard 1975, paywall), as shown below (from Milligan 2003):  Broadly speaking there are two different ways of estimating genetic relatedness using molecular markers: methods of moments, and likelihood estimators. Generally, moments estimators will be faster but aren't constrained to being between the theoretical minimum and maximum values of 0 and 1. The likelihood estimators use likelihood functions derived from the set of Jacquard Identity States (above) to determine the most likely inheritance pattern. One difference between the two classes is (generally) moments estimators require an assumption of no inbreeding, while that assumption isn't necessarily required for likelihood estimators (though it does simplify the math). It is increasingly common to use multiple estimators on pairs, simulated from your molecular markers, with known relationships to determine the most appropriate estimator to use with your data. PopGen.jl implements a wide variety of moments-based estimators: Blouin, Li &amp; Horvitz, Loiselle, Lynch, Lynch/Li, Lynch &amp; Ritland, Moran, Queller &amp; Goodnight, Ritland, and Wang. Along with these, we provide an option to estimate mean, median, standard error, and confidence intervals using bootstrapping. Have a look at the guide we provide detailing how to perform a basic relatedness analysis. A note about removing kin There are reasons for removing kin in population genetics datasets. For one, there are no siblings/kin or mixed-generations in a Hardy-Weinberg Equilibrium population, and the inclusion of siblings/kin in analyses that rely on HWE assumptions [technically] violate those assumptions. However, there are also arguments to keep kin/siblings in your data, those data are important for effective population size, linkage disequilibrium, etc. see Waples and Anderson (2017) "},{"title":"Calculate Relatedness‚Äã","type":1,"pageTitle":"Kinship","url":"/PopGen.jl/docs/analyses/kinship#calculate-relatedness","content":"There are two main methods of calculating pairwise relatedness, an all x all comparison of an entire PopData object or an all x all comparison for a subset of individuals in a PopData object. Regardless of which you prefer, they can be perfomed without bootstrapping, returning aNamedMatrix, or with bootstrapping, returning a DataFrame. Neither method estimates self-relatedness, so the diagonals of the NamedMatrix should be ignored. The resulting NamedMatrix can be converted to a DataFrame using kinshiptotable(). All vs. AllSpecific Samples kinship(data::PopData; kwargs...) Calculate pairwise relatedness estimates for all individuals in a PopData object using the specified method (see below). Returns a NamedMatrix if not performing bootstrapping, otherwise returns a DataFrame (since bootstrapping provides more output information). To calculate means, median, standard error, and confidence intervals using bootstrapping, set iterations = n where n is an integer greater than 0 (the default) corresponding to the number of bootstrap iterations you wish to perform for each pair. The default confidence interval is [0.0275, 0.975] (i.e. 95%), however that can be changed by supplying a Vector{Float64} of [low, high] to the keyword interval. Note: samples must be diploid. Arguments‚Äã data : A PopData object Keyword Arguments‚Äã method::Function : A method function (see below)iterations::Int64 : The number of iterations to perform bootstrapping (default: 0, will not perform bootstrapping)interval::Vector{Float64} : A Vector of [low, high] indicating the confidence intervals you would like for bootstrapping (default: [0.275, 0.975], i.e. 95%) Without BootstrappingWith Bootstrapping julia&gt; cats = @nancycats ; julia&gt; kin = kinship(cats, method = Moran) 237√ó237 Named Matrix{Float64} A ‚ï≤ B ‚îÇ N215 N216 ‚Ä¶ N289 N290 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ N215 ‚îÇ 8.13724e-316 1.62338 ‚Ä¶ 1.04589 1.15351 N216 ‚îÇ 1.62338 0.29485 0.957724 1.1637 N217 ‚îÇ 0.673577 0.587163 0.547427 0.709887 N218 ‚îÇ 0.896935 0.72942 0.919448 0.791255 ‚ãÆ ‚ãÆ ‚ãÆ ‚ã± ‚ãÆ ‚ãÆ N297 ‚îÇ 0.757915 0.858834 1.15432 1.2677 N281 ‚îÇ 0.686057 0.604236 0.942749 1.08762 N289 ‚îÇ 1.04589 0.957724 0.0 1.104 N290 ‚îÇ 1.15351 1.1637 ‚Ä¶ 1.104 0.0  "},{"title":"Methods‚Äã","type":1,"pageTitle":"Kinship","url":"/PopGen.jl/docs/analyses/kinship#methods","content":"There are several estimators available and are listed below. kinship takes the function names as arguments (case sensitive), therefore do not use quotes or colons in specifying the methods. autocompletion Since the methods correspond to function names, they will tab-autocomplete when inputting them. For more information on a specific method, please see the respective docstring (e.g. ?Loiselle). Method\tType\tMethod CallBlouin 1996\tmoments-based\tBlouin Li &amp; Horvitz 1953\tmoments-based\tLiHorvitz Loiselle 1995\tmoments-based\tLoiselle Lynch 1988\tmoments-based\tLynch Lynch/Li 1993\tmoments-based\tLynchLi Lynch &amp; Ritland 1999\tmoments-based\tLynchRitland Moran 1950\tmoments-based\tMoran Queller &amp; Goodnight 1989\tmoments-based\tQuellerGoodnight Ritland 1996\tmoments-based\tRitland Milligan 2003 &quot;DyadML&quot;\tmaximum-likelihood\tincomplete* Wang 2002\tmoments-based\tincomplete* *more kinship estimators Contact us or submit a pull request if you're interested in contributing to the kinship methods. DyadML and Wang (2002) estimators are currently incomplete and the others could use some optimizations. More help is always welcomed! Our wishlist also includes the KING method üòÑ "},{"title":"Posthoc analyses‚Äã","type":1,"pageTitle":"Kinship","url":"/PopGen.jl/docs/analyses/kinship#posthoc-analyses","content":"There are several different kinds of things you can do with kinship information (e.g. network analysis), and one that's provided is lovingly called kinshipposthoc(), which performs a permutation analysis to test if within-population relatedness is significantly greater than between-population relatedness for each population. We recommend that you correct for multiple testing using MultipleTesting.jl. kinshipposthoc(data::PopData, results::Union{DataFrame, NamedTuple}; iterations::Int)  Arguments‚Äã data : A PopData objectresults : the DataFrame or NamedTuple results from kinship() Keyword Arguments‚Äã iterations : number of iterations for the permutation tests (default: 20000) not a great name We admit &quot;kinshipposthoc&quot; is not a great name for this function. Please contact us with better ideas! üòÅ Example julia&gt; cats = @nancycats ; julia&gt; rel_out = kinship(cats, method = [Ritland, Moran], iterations = 100); julia&gt; kinshipposthoc(cats, rel_out) 17x3 DataFrame Row ‚îÇ population Ritland_P Moran_P ‚îÇ String Float64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ 1 5.0e-5 5.0e-5 2 ‚îÇ 2 5.0e-5 5.0e-5 3 ‚îÇ 3 5.0e-5 5.0e-5 4 ‚îÇ 4 5.0e-5 5.0e-5 5 ‚îÇ 5 5.0e-5 5.0e-5 6 ‚îÇ 6 5.0e-5 5.0e-5 7 ‚îÇ 7 5.0e-5 5.0e-5 8 ‚îÇ 8 5.0e-5 5.0e-5 9 ‚îÇ 9 5.0e-5 5.0e-5 10 ‚îÇ 10 5.0e-5 5.0e-5 11 ‚îÇ 11 5.0e-5 5.0e-5 12 ‚îÇ 12 5.0e-5 5.0e-5 13 ‚îÇ 13 5.0e-5 5.0e-5 14 ‚îÇ 14 5.0e-5 5.0e-5 15 ‚îÇ 15 5.0e-5 5.0e-5 16 ‚îÇ 16 5.0e-5 5.0e-5 17 ‚îÇ 17 5.0e-5 5.0e-5   "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Kinship","url":"/PopGen.jl/docs/analyses/kinship#acknowledgements","content":"The kinship methods were dutifully written and verified against R analogues by Jason Selwyn. They have since been rewritten twice for speed and memory optimization (14mb vs 14gb!). These anaylses can take a while, especially if performing bootstrapping; we provide a progress bar via Term.jl so you can move on and focus on other things in the meantime. "},{"title":"Hardy-Weinberg Equilibrium","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/analyses/hardyweinberg","content":"","keywords":""},{"title":"Chi-Squared Test‚Äã","type":1,"pageTitle":"Hardy-Weinberg Equilibrium","url":"/PopGen.jl/docs/analyses/hardyweinberg#chi-squared-test","content":"hwetest(data::PopData, by::String = &quot;locus&quot;, correction::String = &quot;none&quot;)  Calculate chi-squared test of HWE for each locus and returns observed and expected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use by = &quot;population&quot; to perform this separately for each population (default: &quot;locus&quot;). Use correction = to specify a P-value correction method for multiple testing (recommended). For convenience, the correction method is appended to the name of the column, so you will always know how those P-values were adjusted. "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Hardy-Weinberg Equilibrium","url":"/PopGen.jl/docs/analyses/hardyweinberg#arguments","content":"data : the input PopData "},{"title":"Keyword arguments‚Äã","type":1,"pageTitle":"Hardy-Weinberg Equilibrium","url":"/PopGen.jl/docs/analyses/hardyweinberg#keyword-arguments","content":"by : &quot;locus&quot; (default) or &quot;population&quot;correction : a string specifying a P-value adjustment type (default: &quot;none&quot;) correction methods‚Äã &quot;bonferroni&quot; : Bonferroni adjustment&quot;holm&quot; : Holm adjustment&quot;hochberg&quot; : Hochberg adjustment&quot;bh&quot; : Benjamini-Hochberg adjustment&quot;by&quot; : Benjamini-Yekutieli adjustment&quot;bl&quot; : Benjamini-Liu adjustment&quot;hommel&quot; : Hommel adjustment&quot;sidak&quot; : ≈†id√°k adjustment&quot;forwardstop&quot; or &quot;fs&quot; : Forward-Stop adjustment&quot;bc&quot; : Barber-CandeÃÄs adjustment ü§î For more information on multiple testing adjustments, see MultipleTesting.jl "},{"title":"Examples‚Äã","type":1,"pageTitle":"Hardy-Weinberg Equilibrium","url":"/PopGen.jl/docs/analyses/hardyweinberg#examples","content":"HWE Chi-SqHWE with P adjustmentHWE by population julia&gt; hwetest(@gulfsharks) 2209√ó4 DataFrame Row ‚îÇ locus chisq df P ‚îÇ String Float64 Int64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ contig_35208 94.5678 6 0.0 2 ‚îÇ contig_23109 50.789 2 9.36085e-12 3 ‚îÇ contig_4493 40.7903 2 1.38832e-9 4 ‚îÇ contig_10742 14.7325 2 0.000632247 5 ‚îÇ contig_14898 58.1948 2 2.30704e-13 6 ‚îÇ contig_8483 4.05732 2 0.131511 7 ‚îÇ contig_8065 18.0799 2 0.000118574 8 ‚îÇ contig_14708 13.6264 2 0.00109919 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 2203 ‚îÇ contig_18959 106.658 2 0.0 2204 ‚îÇ contig_43517 23.8965 2 6.47041e-6 2205 ‚îÇ contig_27356 14.4493 2 0.000728417 2206 ‚îÇ contig_475 76.6038 2 0.0 2207 ‚îÇ contig_19384 13.7915 2 0.00101209 2208 ‚îÇ contig_22368 20.3787 2 3.75686e-5 2209 ‚îÇ contig_2784 6.13433 2 0.0465531 2194 rows omitted  "},{"title":"Interpreting the results‚Äã","type":1,"pageTitle":"Hardy-Weinberg Equilibrium","url":"/PopGen.jl/docs/analyses/hardyweinberg#interpreting-the-results","content":"Since the results are in table form, you can easily process the table using DataFramesMeta.jl or Query.jl to find loci above or below the alpha threshold you want. As an example, let's perform an HWE-test on the nancycats data without any P-value adjustments: julia&gt; ncats_hwe = hwetest(@nancycats , by = &quot;population&quot;) ;  Now, we can now filter this table and leave only what we're interested in: julia&gt; ncats_hwe[(ncats_hwe.P .!== missing) .&amp; (ncats_hwe.P .&lt;= 0.05), :]  With this command, we filter the table for: the P-values are not missingthe P-values are less than or equal to 0.05.  Note: You can use DataFramesMeta.jl, Query.jl, SplitApplyCombine.jl and others for more declarative dataframe manipulation. This results in a table that now only includes non-missing P-values of 0.05 or lower: 71√ó5 DataFrame Row ‚îÇ locus population chisq df P ‚îÇ String String Float64 Int64 Float64? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 2 74.3426 30 1.24317e-5 2 ‚îÇ fca8 3 85.2 42 9.15914e-5 3 ‚îÇ fca8 6 70.4136 42 0.00390639 4 ‚îÇ fca8 7 63.3673 30 0.00035342 5 ‚îÇ fca8 10 26.4489 12 0.00926812 6 ‚îÇ fca8 11 60.801 42 0.0302593 7 ‚îÇ fca8 16 26.15 12 0.0102213 8 ‚îÇ fca8 17 57.2 30 0.00198256 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 65 ‚îÇ fca96 16 37.0033 20 0.0116913 66 ‚îÇ fca37 1 12.6562 6 0.0488314 67 ‚îÇ fca37 3 24.1481 12 0.0194174 68 ‚îÇ fca37 5 61.1317 12 1.40268e-8 69 ‚îÇ fca37 7 13.0062 6 0.042938 70 ‚îÇ fca37 11 61.8056 42 0.024858 71 ‚îÇ fca37 12 61.618 42 0.0257958 56 rows omitted  "},{"title":"Visualizing the results‚Äã","type":1,"pageTitle":"Hardy-Weinberg Equilibrium","url":"/PopGen.jl/docs/analyses/hardyweinberg#visualizing-the-results","content":"While not strictly necessary, it might sometimes make sense to generate of heatmap of the results for easier visualization. This is feasible for the nancycats data, but when loci are in the hundreds or thousands, this method quickly becomes counterproductive. In any case, here is a simple example of the HWE results for nancycats plotted as a heatmap using VegaLite.jl (other packages like Makie.jl, Plots.jl, Gadfly.jl etc. would work great too!): using VegaLite julia&gt; ncats_hwe = hwetest(@nancycats , by = &quot;population&quot;, correction = &quot;bonferroni&quot;); julia&gt; ncats_hwe |&gt; @vlplot(:rect, :locus, :population, color=:P_bonferroni)    "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Hardy-Weinberg Equilibrium","url":"/PopGen.jl/docs/analyses/hardyweinberg#acknowledgements","content":"While most of the arithmetic for the Hardy-Weinberg test is written by us, we rely on the Chi-Squared distribution and probability density function provided by Distributions.jl. "},{"title":"t-SNE","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/analyses/tsne","content":"","keywords":""},{"title":"tnse‚Äã","type":1,"pageTitle":"t-SNE","url":"/PopGen.jl/docs/analyses/tsne#tnse","content":"tsne(data::PopData, args...; kwargs...)  Perform t-SNE (t-Stochastic Neighbor Embedding) on a PopData object, returning a DataFrame. Converts the PopData object into a matrix of allele frequencies with missing values replaced with the global mean frequency of that allele. First performs PCA on that matrix, retainingreduce_dims dimensions of the PCA prior to t-SNE analysis. The other positional and keyword arguments are the same as tsne from TSne.jl. "},{"title":"Arguments‚Äã","type":1,"pageTitle":"t-SNE","url":"/PopGen.jl/docs/analyses/tsne#arguments","content":"data: a PopData objectndims: Dimension of the embedded space (default: 2)reduce_dims the number of the first dimensions of X PCA to use for t-SNE, if 0, all available dimension are used (default: 0)max_iter: Maximum number of iterations for the optimization (default: 1000)perplexity: The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. Different values can result in significantly different results (default: 30) "},{"title":"Keyword Arguments (optional)‚Äã","type":1,"pageTitle":"t-SNE","url":"/PopGen.jl/docs/analyses/tsne#keyword-arguments-optional","content":"distance: type Function or Distances.SemiMetric, specifies the function to use for calculating the distances between the rowspca_init: whether to use the first ndims of the PCA as the initial t-SNE layout, if false (the default), the method is initialized with the random layoutmax_iter: how many iterations of t-SNE to doverbose: output informational and diagnostic messagesprogress: display progress meter during t-SNE optimization (default: true)min_gain: eta: initial_momentum, final_momentum, momentum_switch_iter,stop_cheat_iter: cheat_scale low-level parameters of t-SNE optimizationextended_output: if true, returns a tuple of embedded coordinates matrix, point perplexities and final Kullback-Leibler divergence  "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"t-SNE","url":"/PopGen.jl/docs/analyses/tsne#acknowledgements","content":"This function is a wrapper for the another package, so really, all the brilliance and effort should be credited to the authors of TNSE.jl. "},{"title":"API","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api","content":"API These pages contains the APIs, or Application Programming Interface, which are the entirety of all the functions/commands available in PopGen.jl. Unlike other sections of these docs, these pages are intended to be technical rather than tutorial. Included here are the function definitions and their docstrings as they appear inside this package. Most of these functions are used under-the-hood and not exported, meaning that if you want to use them, you will need to invoke them with PackageName.function. For example, if you wanted to use uniquealleles (which is not exported), you can do so with PopGenCore.uniquealleles(). As a note, most things in PopGenCore are exported (for ease of development), and many parts of PopGenCore.jl are reexported by PopGen.jl. Each API page features icons indicating whether a function is exported by that package. You will see two icons next to functions that PopGen.jl reexports from PopGenCore.jl. Each page has a legend at the top for convenience. This is the icon system: üì¶ indicates the function is not exported by any package. functions beginning with underscores always have üì¶ üîµ indicates the function is exported by PopGenCore.jlüü™ indicates the function is exported by the package the function appears in (PopGen.jl, PopGenSims.jl). this applies only to non-PopGenCore.jl packages","keywords":""},{"title":"Principal Component Analysis","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/analyses/pca","content":"","keywords":""},{"title":"Principal Component Anaylsis‚Äã","type":1,"pageTitle":"Principal Component Analysis","url":"/PopGen.jl/docs/analyses/pca#principal-component-anaylsis","content":"pca(::PopData; maxpc::Int = 0, method::Symbol = :svd, missings::String = &quot;mean&quot;, pratio::Float64 = 0.99, center::Bool = false, scale::Bool = true)  Perform a Principal Component Analysis on a PopData object. Returns an indexible MultivariateStats.PCA object. keyword arguments‚Äã method::Symbol: The PCA method to use (default: :svd) :cov: based on covariance matrix decomposition:svd: based on Singular Value Decomposition of the input data maxpc::Int: The maximum number of principal components to retain (default: 0 = (min(d, ncol-1)))missings::String: How to treat missing genotypes in the allele frequency matrix (default: &quot;mean&quot;) &quot;mean&quot;: replace missing values with the mean frequency for that allele in that locus&quot;missing&quot;: keep missing values as they are&quot;zero&quot;: replace missing values with 0 pratio::Float64: The maxium ratio of variances preserved in the principal subspace (default = 0.99)center::Bool: whether to center the allele frequency matrix (default: false)scale::Bool: whether to Z-score scale the allele frequency matrix (default: true) Example julia&gt; cats = @nancycats; julia&gt; pca_cats = pca(cats, maxpc = 40); julia&gt; pca_cats.proj # the projection matrix 237√ó40 Matrix{Float64}: -0.0922663 -0.00353549 -0.0205698 ‚Ä¶ 0.0148947 0.0114937 0.0119581 -0.0939368 0.00935327 -0.0488424 -0.0167817 -0.0144753 -0.0348131 -0.0545479 -0.00597291 0.0527322 -0.0359343 0.00588278 0.0205089 -0.0745392 0.0306307 -0.0210157 0.100871 0.0440558 0.0728491 ‚ãÆ ‚ã± -0.0859615 0.0369075 0.000597856 -0.0633689 0.0249073 -0.0405845 -0.0547981 0.0322698 -0.0107031 -0.1138 -0.000545308 0.00296074 -0.0950973 0.0163225 0.00588324 ‚Ä¶ 0.0256939 0.0831163 0.00374728 -0.0843321 -0.0082427 -0.0309442 0.00382228 0.0179109 0.0217293 julia&gt; pca_cats.prinvars # the principal variances 40-element Vector{Float64}: 20.906886724195086 8.015966142401036 7.501281679600134 6.628421860444929 ‚ãÆ 2.6556826537989755 2.599100605083436 2.5912046561168447 2.5000331618590637   "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Principal Component Analysis","url":"/PopGen.jl/docs/analyses/pca#acknowledgements","content":"The PCA method is an extension of the hyper-fast methods written in MultivariateStats.jl. The centering and scaling are also outsourced to the methods present in StatsBase.jl. A lot of clever package authors and contributors in this ecosystem! "},{"title":"Clustering.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/clustering","content":"","keywords":""},{"title":"PopGen.jl/src/KMeans.jl‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#popgenjlsrckmeansjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ cutree‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-cutree","content":"cutree(::PopData, hcres::Hclust; krange::UnitRange{Int64}, height::Union{Int64, Nothing} = nothing) cutree(::PopData, hcres::Hclust; krange::Vector{Int64}, height::Union{Int64, Nothing} = nothing)  An expansion to the Clustering.cutree method (from Clustering.jl) that performs cluster assignments over krangeon the Hclust output from hclust(). Returns a DataFrame of sample names and columns corresponding to assignments per k in krange. The PopData object is used only for retrieving the sample names. Keyword Arguments krange: the number of desired clusters, given as a vector (ex. [2,4,5]) or range (2:5)h::Integer: the height at which the tree is cut (optional)   "},{"title":"üîµ cluster‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-cluster","content":"cluster(::PopData, method::Function ; kwargs)  A convenience wrapper to perform clustering on a PopData object determined by a designated method (see below). The chosen method must also be supplied with the appropriate keyword arguments for that method. For more information on a specific method, see its docstring with ?methodname Clustering Methods kmeans: K-means++ clustering kwargs: k, iterations, matrixtype kmedoids: K-medoids clustering kwargs: k, iterations, distance, matrixtype hclust: Hierarchical clustering kwargs: linkage, branchorder, distance, matrixtype fuzzycmeans: Fuzzy C-means lustering kwargs: c, fuzziness, iterations, matrixtype dbscan: Density-based Spatial Clustering of Applications with Noise (DBSCAN) kwargs: radius, minpoints, distance, matrixtype  "},{"title":"üîµ dbscan‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-dbscan","content":"dbscan(::PopData; radius::Float64, minpoints::Int64 = 2, distance::PreMetric = euclidean, matrixtype::Symbol = :pca)  An expansion of Clustering.dbscan (from Clustering.jl) to perform Density-based Spatial Clustering of Applications with Noise (DBSCAN) on a PopData object. This is a convenience method which converts the PopData object to either an allele frequency or PCA matrix, and performs DBSCAN clustering on the distance matrix of that. Returns a DbscanResult object, which contains the assignments in the.assignments field. Keyword Arguments radius::Float64: the radius of a point neighborhoodminpoints::Int: the minimum number of a core point neighbors (default: 2)distance: type of distance matrix to calculate on matrixtype (default: euclidean) see Distances.jl for a list of options (e.g. sqeuclidean, etc.) matrixtype: type of input matrix (default: :pca) :pca: matrix of Principal Components:freq: matrix of allele frequencies   "},{"title":"üîµ fuzzycmeans‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-fuzzycmeans","content":"fuzzycmeans(data::PopData; c::Int64, fuzziness::Int64 = 2, iterations::Int64 = 100, matrixtype::Symbol = :pca)  An expansion of Clustering.fuzzy_cmeans (from Clustering.jl) to perform Fuzzy C-means clustering on a PopData object. This is a convenience method which converts the PopData object to either an allele frequency or PCA matrix, and performs Fuzzy C-means clustering on the Euclidean distance matrix of that. Returns a FuzzyCMeansResult object, which contains the assignment weights in the.weights field. Keyword Arguments c: the number of desired clusters, given as an Integerfuzziness::Integer: clusters' fuzziness, must be &gt;1 (default: 2) a fuzziness of 2 is common for systems with unknown numbers of clusters iterations::Int64: the maximum number of iterations to attempt to reach convergence (default: 100)matrixtype: type of input matrix to compute (default: :pca) :pca: matrix of Principal Components:freq: matrix of scaled allele frequencies   "},{"title":"üîµ hclust‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-hclust","content":"hclust(data::PopData; linkage::Symbol = :single, branchorder::Symbol = :r, distance::PreMetric = euclidean, matrixtype::Symbol = :pca)  An expansion of Clustering.hclust (from Clustering.jl) to perform hierarchical clustering on a PopData object. This is a convenience method which converts the PopData object to either an allele frequency or PCA matrix, converts that into a distance matrix, and performs hierarchical clustering on that distance matrix. Returns an Hclust object, which contains many metrics but does not include cluster assignments. Usecutree(::PopData, ::Hclust; krange...) to compute the sample assignments for a range of k clusters. Keyword Arguments linkage: defines how the distances between the data points are aggregated into the distances between the clusters (default: :single) :single: use the minimum distance between any of the cluster members:average: use the mean distance between any of the cluster members:complete: use the maximum distance between any of the members:ward: the distance is the increase of the average squared distance of a point to its cluster centroid after merging the two clusters:ward_presquared: same as :ward, but assumes that the distances in the distance matrix are already squared. branchorder: algorithm to order leaves and branches (default: :r) :r: ordering based on the node heights and the original elements order (compatible with R's hclust):optimal: branches are ordered to reduce the distance between neighboring leaves from separate branches using the &quot;fast optimal leaf ordering&quot; algorithm distance: type of distance matrix to calculate on matrixtype (default: euclidean) see Distances.jl for a list of options (e.g. sqeuclidean, etc.) matrixtype: type of input matrix (default: :pca) :pca: matrix of Principal Components:freq: matrix of allele frequencies   "},{"title":"üîµ kmeans‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-kmeans","content":"kmeans(data::PopData; k::Int64, iterations::Int64 = 100, matrixtype::Symbol = :pca)  Perform Kmeans clustering (using Kmeans++) on a PopData object. Returns a KmeansResultobject. Use the keyword argument iterations (default: 100) to set the maximum number of iterations allowed to achieve convergence. Interally, kmeans clustering is performed on either the principal components of the scaled allele frequencies, or just the scaled allele frequencies themselves. In both cases, missing values are replaced by the global mean allele frequency. Keyword Arguments k: the number of desired clusters, given as an Integeriterations::Int64: the maximum number of iterations to attempt to reach convergence (default: 100)matrixtype: type of input matrix to compute (default: :pca) :pca: matrix of Principal Components:freq: matrix of scaled allele frequencies  Example julia&gt; cats = @nancycats ; julia&gt; km = kmeans(cats, k = 2)   "},{"title":"üîµ kmedoids‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-kmedoids","content":"kmedoids(data::PopData; k::Int64, iterations::Int64 = 100, distance::PreMetric = euclidean, matrixtype::Symbol = :pca)  Perform Kmedoids clustering on a PopData object. Returns a KmedoidsResultobject. Use the keyword argument iterations (default: 100) to set the maximum number of iterations allowed to achieve convergence. Interally, kmeans clustering is performed on either the principal components of the scaled allele frequencies, or just the scaled allele frequencies themselves. In both cases, missing values are replaced by the global mean allele frequency. Keyword Arguments k: the number of desired clusters, given as an Integeriterations::Int64: the maximum number of iterations to attempt to reach convergence (default: 100)distance: type of distance matrix to calculate on matrixtype (default: euclidean) see Distances.jl for a list of options (e.g. sqeuclidean, etc.) matrixtype: type of input matrix to compute (default: :pca) :pca: matrix of Principal Components:freq: matrix of scaled allele frequencies   "},{"title":"üîµ show‚Äã","type":1,"pageTitle":"Clustering.jl","url":"/PopGen.jl/docs/api/PopGen/clustering#-show","content":"Base.show(io::IO, data::KMeansResults)  "},{"title":"FstByLocus.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/fstbylocus","content":"","keywords":""},{"title":"PopGen.jl/src/FStatistics/FstByLocus.jl‚Äã","type":1,"pageTitle":"FstByLocus.jl","url":"/PopGen.jl/docs/api/PopGen/fstbylocus#popgenjlsrcfstatisticsfstbylocusjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üì¶ _hudson_fst_lxl‚Äã","type":1,"pageTitle":"FstByLocus.jl","url":"/PopGen.jl/docs/api/PopGen/fstbylocus#-_hudson_fst_lxl","content":"_hudson_fst_lxl(data::PopData) _hudson_fst_lxl(population_1::T, population_2::T) where T&lt;:AbstractMatrix   "},{"title":"üì¶ _nei_fst_lxl‚Äã","type":1,"pageTitle":"FstByLocus.jl","url":"/PopGen.jl/docs/api/PopGen/fstbylocus#-_nei_fst_lxl","content":"_nei_fst_lxl(data::PopData) _nei_fst_lxl(population_1::T, population_2::T) where T&lt;:AbstractMatrix  "},{"title":"FstGlobal.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/fstglobal","content":"","keywords":""},{"title":"PopGen.jl/src/FStatistics/FstGlobal.jl‚Äã","type":1,"pageTitle":"FstGlobal.jl","url":"/PopGen.jl/docs/api/PopGen/fstglobal#popgenjlsrcfstatisticsfstglobaljl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ Hudson‚Äã","type":1,"pageTitle":"FstGlobal.jl","url":"/PopGen.jl/docs/api/PopGen/fstglobal#-hudson","content":"Hudson(data::PopData) Hudson(pop1::T, pop2::T) where T&lt;:GenoArray Hudson(population_1::T, population_2::T) where T&lt;:AbstractMatrix   "},{"title":"üîµ Nei‚Äã","type":1,"pageTitle":"FstGlobal.jl","url":"/PopGen.jl/docs/api/PopGen/fstglobal#-nei","content":"Nei(data::PopData) Nei(population_1::T, population_2::T) where T&lt;:AbstractMatrix   "},{"title":"üîµ WeirCockerham‚Äã","type":1,"pageTitle":"FstGlobal.jl","url":"/PopGen.jl/docs/api/PopGen/fstglobal#-weircockerham","content":"WeirCockerham(data::PopData) WeirCockerham(population_1::T, population_2::T) where T&lt;:AbstractMatrix  "},{"title":"DataExploration.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/dataexploration","content":"","keywords":""},{"title":"PopGen.jl/src/DataExplortation.jl‚Äã","type":1,"pageTitle":"DataExploration.jl","url":"/PopGen.jl/docs/api/PopGen/dataexploration#popgenjlsrcdataexplortationjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ allelefreqtable‚Äã","type":1,"pageTitle":"DataExploration.jl","url":"/PopGen.jl/docs/api/PopGen/dataexploration#-allelefreqtable","content":"allelefreqtable(data::PopData; by::String = &quot;global&quot;)  Return a table of the observed global (default) or population allele frequencies in a PopData object. Example julia&gt; cats = @nancycats ; julia&gt; allelefreqtable(cats) 108√ó4 DataFrame Row ‚îÇ locus allele count frequency ‚îÇ String Int16? Int64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 135 105 0.241935 2 ‚îÇ fca8 143 44 0.101382 3 ‚îÇ fca8 133 33 0.0760369 4 ‚îÇ fca8 137 83 0.191244 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 105 ‚îÇ fca37 226 2 0.00421941 106 ‚îÇ fca37 216 7 0.0147679 107 ‚îÇ fca37 224 2 0.00421941 108 ‚îÇ fca37 204 6 0.0126582 100 rows omitted julia&gt; allelefreqtable(cats, by = &quot;population&quot;) 839√ó5 DataFrame Row ‚îÇ locus population allele count frequency ‚îÇ String String Int16? Int64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 1 135 9 0.5625 2 ‚îÇ fca8 1 143 4 0.25 3 ‚îÇ fca8 1 133 2 0.125 4 ‚îÇ fca8 1 137 1 0.0625 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 836 ‚îÇ fca37 16 210 5 0.208333 837 ‚îÇ fca37 17 208 22 0.846154 838 ‚îÇ fca37 17 182 3 0.115385 839 ‚îÇ fca37 17 220 1 0.0384615 831 rows omitted   "},{"title":"üîµ genofreqtable‚Äã","type":1,"pageTitle":"DataExploration.jl","url":"/PopGen.jl/docs/api/PopGen/dataexploration#-genofreqtable","content":"genofreqtable(data::PopData; by::String = &quot;global&quot;)  Return a table of the observed global (default) or population genotype frequencies in a PopData object. Example julia&gt; cats = @nancycats ; julia&gt; genofreqtable(cats) 341√ó4 DataFrame Row ‚îÇ locus genotype count frequency ‚îÇ String Tuple‚Ä¶ Int64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 (135, 143) 16 0.0737327 2 ‚îÇ fca8 (133, 135) 9 0.0414747 3 ‚îÇ fca8 (135, 135) 23 0.105991 4 ‚îÇ fca8 (137, 143) 8 0.0368664 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 338 ‚îÇ fca37 (206, 220) 1 0.00421941 339 ‚îÇ fca37 (208, 218) 1 0.00421941 340 ‚îÇ fca37 (184, 184) 3 0.0126582 341 ‚îÇ fca37 (208, 210) 3 0.0126582 333 rows omitted julia&gt; genofreqtable(cats, by = &quot;population&quot;) 1094√ó5 DataFrame Row ‚îÇ locus population genotype count frequency ‚îÇ String String Tuple‚Ä¶ Int64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 1 (135, 143) 3 0.375 2 ‚îÇ fca8 1 (133, 135) 2 0.25 3 ‚îÇ fca8 1 (135, 135) 2 0.25 4 ‚îÇ fca8 1 (137, 143) 1 0.125 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 1091 ‚îÇ fca37 17 (208, 208) 10 0.769231 1092 ‚îÇ fca37 17 (182, 182) 1 0.0769231 1093 ‚îÇ fca37 17 (182, 208) 1 0.0769231 1094 ‚îÇ fca37 17 (208, 220) 1 0.0769231 1086 rows omitted   "},{"title":"üîµ missingdata‚Äã","type":1,"pageTitle":"DataExploration.jl","url":"/PopGen.jl/docs/api/PopGen/dataexploration#-missingdata","content":"missingdata(data::PopData; by::Union{String, Symbol} = &quot;sample&quot;)  Get missing genotype information in a PopData. Specify a mode of operation to return a DataFrame corresponding with that missing information. Modes &quot;sample&quot; - returns a count and list of missing loci per individual (default)&quot;population&quot; - returns a count of missing genotypes per population&quot;locus&quot; - returns a count of missing genotypes per locus&quot;locusxpopulation&quot; - returns a count of missing genotypes per locus per population Example missingdata(@gulfsharks, by = &quot;pop&quot;)   "},{"title":"üì¶ _missingdata‚Äã","type":1,"pageTitle":"DataExploration.jl","url":"/PopGen.jl/docs/api/PopGen/dataexploration#-_missingdata","content":"_missingdata(data::PopData, ::Val{:sample}) _missingdata(data::PopData, ::Val{:population}) _missingdata(data::PopData, ::Val{:locus}) _missingdata(data::PopData, ::Val{:locusxpopulation})   "},{"title":"üîµ pairwiseidentical‚Äã","type":1,"pageTitle":"DataExploration.jl","url":"/PopGen.jl/docs/api/PopGen/dataexploration#-pairwiseidentical","content":"pairwiseidentical(data::PopData)  Return a pairwise matrix of the percent of identical genotypes at each locus between all pairs of individuals. Example julia&gt; cats = @nancycats ; julia&gt; pairwiseidentical(cats) 237√ó237 Named Matrix{Float64} A ‚ï≤ B ‚îÇ N215 N216 ‚Ä¶ N289 N290 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ N215 ‚îÇ 1.0 0.5 ‚Ä¶ 0.142857 0.166667 N216 ‚îÇ 0.5 1.0 0.142857 0.166667 N217 ‚îÇ 0.25 0.125 0.125 0.142857 N218 ‚îÇ 0.375 0.25 0.25 0.142857 N219 ‚îÇ 0.375 0.375 0.25 0.142857 ‚ãÆ ‚ãÆ ‚ãÆ ‚ã± ‚ãÆ ‚ãÆ N296 ‚îÇ 0.5 0.333333 0.0 0.0 N297 ‚îÇ 0.166667 0.166667 0.428571 0.285714 N281 ‚îÇ 0.142857 0.142857 0.25 0.428571 N289 ‚îÇ 0.142857 0.142857 1.0 0.142857 N290 ‚îÇ 0.166667 0.166667 ‚Ä¶ 0.142857 1.0  pairwiseidentical(data::PopData, sample_names::Vector{String})  Return a pairwise matrix of the percent of identical genotypes at each nonmissing locus between all pairs of provided sample_names. Example julia&gt; cats = @nancycats ; julia&gt; interesting_cats = samplenames(cats)[1:5] 5-element Array{String,1}: &quot;N215&quot; &quot;N216&quot; &quot;N217&quot; &quot;N218&quot; &quot;N219&quot; julia&gt; pairwiseidentical(cats, interesting_cats) 5√ó5 Named Matrix{Float64} A ‚ï≤ B ‚îÇ N217 N218 N219 N220 N221 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ N217 ‚îÇ 1.0 0.0 0.111111 0.222222 0.111111 N218 ‚îÇ 0.0 1.0 0.333333 0.111111 0.444444 N219 ‚îÇ 0.111111 0.333333 1.0 0.111111 0.333333 N220 ‚îÇ 0.222222 0.111111 0.111111 1.0 0.222222 N221 ‚îÇ 0.111111 0.444444 0.333333 0.222222 1.0  "},{"title":"FstPermutations.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/fstpermutations","content":"","keywords":""},{"title":"PopGen.jl/src/FStatistics/FstPermutations.jl‚Äã","type":1,"pageTitle":"FstPermutations.jl","url":"/PopGen.jl/docs/api/PopGen/fstpermutations#popgenjlsrcfstatisticsfstpermutationsjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üì¶ _fst_permutate‚Äã","type":1,"pageTitle":"FstPermutations.jl","url":"/PopGen.jl/docs/api/PopGen/fstpermutations#-_fst_permutate","content":"_fst_permute(population_1::T, population_2::T) where T&lt;:AbstractMatrix  Returns two matrices with rows (samples) shuffled between them. Respects the number of rows of the original matrices (i.e. population sizes).  "},{"title":"üì¶ _fst_permutation‚Äã","type":1,"pageTitle":"FstPermutations.jl","url":"/PopGen.jl/docs/api/PopGen/fstpermutations#-_fst_permutation","content":"_fst_permution(data::PopData, method::Function, iterations::Int64)  Returns a PairwiseFST object containing a dataframe of Pairwise FST calculations. The contained dataframe has FST values below the diagonal and P values above it. This method is used internally and wrapped by the public API provided in pairwisefst(). "},{"title":"HardyWeinberg.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/hardyweinberg","content":"","keywords":""},{"title":"PopGen.jl/src/HardyWeinberg.jl‚Äã","type":1,"pageTitle":"HardyWeinberg.jl","url":"/PopGen.jl/docs/api/PopGen/hardyweinberg#popgenjlsrchardyweinbergjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üì¶ _chisqlocus‚Äã","type":1,"pageTitle":"HardyWeinberg.jl","url":"/PopGen.jl/docs/api/PopGen/hardyweinberg#-_chisqlocus","content":"_chisqlocus(locus::T) where T &lt;: GenotypeArray  Calculate the chi square statistic and p-value for a locus Returns a tuple with chi-square statistic, degrees of freedom, and p-value.  "},{"title":"üîµ hwetest‚Äã","type":1,"pageTitle":"HardyWeinberg.jl","url":"/PopGen.jl/docs/api/PopGen/hardyweinberg#-hwetest","content":"hwetest(data::PopData; by_pop::Bool = false; correction = &quot;none&quot;)  Calculate chi-squared test of HWE for each locus and returns observed and expected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use by_pop = true to perform this separately for each population (default: by_pop = false) and return a NamedTuple of DataFrames with the names corresponding to the population names. Use correction = to specify a P-value adjustment method for multiple testing. correction methods (case insensitive) &quot;bonferroni&quot; : Bonferroni adjustment&quot;holm&quot; : Holm adjustment&quot;hochberg&quot; : Hochberg adjustment&quot;bh&quot; : Benjamini-Hochberg adjustment&quot;by&quot; : Benjamini-Yekutieli adjustment&quot;bl&quot; : Benjamini-Liu adjustment&quot;hommel&quot; : Hommel adjustment&quot;sidak&quot; : ≈†id√°k adjustment&quot;forwardstop&quot; or &quot;fs&quot; : Forward-Stop adjustment&quot;bc&quot; : Barber-CandeÃÄs adjustment Example hwetest(@gulfsharks, correction = &quot;bh&quot;) hwetest(@gulfsharks, by_pop = true, correction = &quot;bh&quot;)  "},{"title":"KinshipMoments.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments","content":"","keywords":""},{"title":"PopGen.jl/src/Kinship/KinshipMoments.jl‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#popgenjlsrckinshipkinshipmomentsjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ Blouin‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-blouin","content":"Blouin(ind1::GenoArray, ind2::GenoArray)::Float64  Allele sharing index described by Blouin (1996) Single Locus Equation: The number of alleles shared between individuals over ploidy. If both allele positions are shared (e.g. AA x AA or AB x AB) then 1If one allele position is shared (e.g. AB x AC) then 0.5If neither allele position is shared (e.g. AB x CD) then 0 How to combine multiple loci: Single locus estimates are simply averaged togetherAssumes no inbreeding Blouin, M. S., Parsons, M., Lacaille, V., &amp; Lotz, S. (1996). Use of microsatellite loci to classify individuals by relatedness. Molecular ecology, 5(3), 393-401.  "},{"title":"üì¶ _blouin‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_blouin","content":"_blouin(geno1::NTuple{2,T}, geno2::NTuple{2,T})::Float64 where T&lt;:Union{Int16, Int8}   "},{"title":"üîµ LiHorvitz‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-lihorvitz","content":"LiHorvitz(ind1::GenoArray, ind2::GenoArray, locus_names::Vector{Symbol}; alleles::NamedTuple)  Allele sharing index described by Li and Horvitz (1953) Single Locus Equation: If all alleles are the same between individuals (eg. AA x AA) then 1. If two alleles are shared between individuals (eg. AA x AB or AB x AB) then 0.5.If only one allele is shared between individuals (eg. AB x AC) then 0.25.If no alleles are shared (eg. AB x CD) then 0. How to combine multiple loci: Single locus estimates are simply averaged togetherAssumes no inbreeding Li, C. C., &amp; Horvitz, D. G. (1953). Some methods of estimating the inbreeding coefficient. American journal of human genetics, 5(2), 107.  "},{"title":"üì¶ _lihorvitz‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_lihorvitz","content":"_lihorvitz(geno1::NTuple{2,T}, geno2::NTuple{2,T})::Float64 where T&lt;:Union{Int16, Int8}   "},{"title":"üîµ Loiselle‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-loiselle","content":"Loiselle(ind1::GenoArray, ind2::GenoArray, allelefrq::U; kwargs...) where U &lt;: Tuple  Calculates the moments based estimator of pairwise relatedness using the estimator propsed by Loiselle et al (1995) and modified to individual dyads by Heuertz et al. (2003). Multiple Locus Equation:Assumes no inbreeding See equations 22 in: Wang(2017) for variant of estimator used Loiselle, B. A., Sork, V. L., Nason, J., &amp; Graham, C. (1995). Spatial genetic structure of a tropical understory shrub, Psychotria officinalis (Rubiaceae). American journal of botany, 82(11), 1420-1425. Heuertz, M., Vekemans, X., Hausman, J. F., Palada, M., &amp; Hardy, O. J. (2003). Estimating seed vs. pollen dispersal from spatial genetic structure in the common ash. Molecular Ecology, 12(9), 2483-2495. Wang, J. (2017). Estimating pairwise relatedness in a small sample of individuals. Heredity, 119(5), 302-313.  "},{"title":"üì¶ _loiselle_num‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_loiselle_num","content":"_loiselle_num(geno1::NTuple{2,T}, geno2::NTuple{2,T}, frqdict::Dict{T, Float64})::Float64 where T&lt;:Union{Int16, Int8}   "},{"title":"üì¶ _loiselle_denom‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_loiselle_denom","content":"_loiselle_denom(freqs)::Float64   "},{"title":"üì¶ _lynch‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_lynch","content":"_lynch(geno1::NTuple{2,T}, geno2::NTuple{2,T})::Float64 where T&lt;:Union{Int16, Int8}   "},{"title":"üîµ Lynch‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-lynch","content":"Lynch(ind1::GenoArray, ind2::GenoArray)::Float64  Allele sharing index described by Lynch (1988) Single Locus Equation: If all alleles are the same between individuals (eg. AA x AA) then 1. If both individuals are heterozygous with the same alleles or one is homozygous for the shared allele (eg. AB x AB or AA x AB) then 0.75.If only one allele is shared between individuals (eg. AB x AC) then 0.5.If no alleles are shared (eg. AB x CD) then 0. How to combine multiple loci: Single locus estimates are simply averaged togetherAssumes no inbreeding Lynch, M. (1988). Estimation of relatedness by DNA fingerprinting. Molecular biology and evolution, 5(5), 584-599.  "},{"title":"üîµ LynchLi‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-lynchli","content":"LynchLi(ind1::T, ind2::T, alleles::U; kwargs...) where T &lt;: GenoArray where U &lt;: Tuple  Calculates the moments based estimator of pairwise relatedness by Lynch (1988) &amp; improved by Li et al. (1993). Single Locus Equation:How to combine multiple loci: Sum the difference between observed and expected similarity across all loci and then divide by the sum of 1 - the expected similarityAssumes no inbreeding See equations 13 - 16 in Wang (2017) for variant of estimator used Li, C. C., Weeks, D. E., &amp; Chakravarti, A. (1993). Similarity of DNA fingerprints due to chance and relatedness. Human heredity, 43(1), 45-52. Wang, J. (2017). Estimating pairwise relatedness in a small sample of individuals. Heredity, 119(5), 302-313.  "},{"title":"üì¶ _lynchli‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_lynchli","content":"_lynchli(geno1::NTuple{2,T}, geno2::NTuple{2,T})::Float64 where T&lt;:Union{Int16, Int8}   "},{"title":"üì¶ _lynchS0‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_lynchs0","content":"_lynchliS0(alleles)::Float64   "},{"title":"üîµ LynchRitland‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-lynchritland","content":"LynchRitland(ind1::GenoArray, ind2::GenoArray, locus_names::Vector{Symbol}; alleles::NamedTuple)  Calculates the moments based estimator of pairwise relatedness by Lynch and Ritland (1999). Single Locus Equation:How to combine multiple loci: Weighted average of each term seperately weighted by the sample variance (assuming zero relatedness) and subsequently divided by the average sampling varianceAssumes no inbreeding See equation 10 in Wang (2017) for variant of estimator used Lynch, M., &amp; Ritland, K. (1999). Estimation of pairwise relatedness with molecular markers. Genetics, 152(4), 1753-1766. Wang, J. (2017). Estimating pairwise relatedness in a small sample of individuals. Heredity, 119(5), 302-313.  "},{"title":"üì¶ _lynchritland‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_lynchritland","content":"_lynchritland(geno1::NTuple{2,T}, geno2::NTuple{2,T}, frqdict::Dict{T, Float64}) where T&lt;:Union{Int16, Int8}   "},{"title":"üîµ Moran‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-moran","content":"Moran(ind1::GenoArray, ind2::GenoArray, locus_names::Vector{Symbol}; alleles::NamedTuple)  Reinterpretation of Moran's I (commonly used for spatial autocorrelation) to estimate genetic relatedness by Hardy and Vekemans (1999) Multiple Locus Equation:Assumes no inbreeding Hardy, O. J., &amp; Vekemans, X. (1999). Isolation by distance in a continuous population: reconciliation between spatial autocorrelation analysis and population genetics models. Heredity, 83(2), 145-154.  "},{"title":"üì¶ _moran‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_moran","content":"_moran(geno1::NTuple{2,T}, geno2::NTuple{2,T}, frqdict::Dict{T, Float64}) where T&lt;:Union{Int16, Int8}   "},{"title":"üîµ QuellerGoodnight‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-quellergoodnight","content":"QuellerGoodnight(ind1::GenoArray, ind2::GenoArray, locus_names::Vector{Symbol}; alleles::NamedTuple)  Calculates the moments based estimator of pairwise relatedness developed by Queller &amp; Goodnight (1989). Single Locus Equation:How to combine multiple loci: Multiple loci are combined by independently summing the two numerator and two denominator terms before performing the final division and averaging the two components. Assumes no inbreeding See equation 3 in Wang (2017) for variant of estimator used. Queller, D. C., &amp; Goodnight, K. F. (1989). Estimating relatedness using genetic markers. Evolution, 43(2), 258-275. Wang, J. (2017). Estimating pairwise relatedness in a small sample of individuals. Heredity, 119(5), 302-313.  "},{"title":"üì¶ _quellergoodnight‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_quellergoodnight","content":"_quellergoodnight(geno1::NTuple{2,T}, geno2::NTuple{2,T}, frqdict::Dict{T, Float64}) where T&lt;:Union{Int16, Int8}   "},{"title":"üîµ Ritland‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-ritland","content":"Ritland(ind1::GenoArray, ind2::GenoArray, locus_names::Vector{Symbol}; alleles::NamedTuple)  Calculates the moments based estimator of pairwise relatedness proposed by Li and Horvitz (1953) and implemented/made popular by Ritland (1996). Single Locus Equation:How to combine multiple loci: A weighted average of individual locus specific estimates weighted by sampling varianceAssumes no inbreeding See equation 7 in: Wang (2017) for variant of estimator used Ritland, K. (1996). Estimators for pairwise relatedness and individual inbreeding coefficients. Genetics Research, 67(2), 175-185. Wang, J. (2017). Estimating pairwise relatedness in a small sample of individuals. Heredity, 119(5), 302-313.  "},{"title":"üì¶ _ritland‚Äã","type":1,"pageTitle":"KinshipMoments.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipmoments#-_ritland","content":"_ritland(geno1::NTuple{2,T}, geno2::NTuple{2,T}, frqdict::Dict{T, Float64}) where T&lt;:Union{Int16, Int8}   "},{"title":"Heterozygosity.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/heterozygosity","content":"","keywords":""},{"title":"PopGen.jl/src/Heterozygosity.jl‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#popgenjlsrcheterozygosityjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üì¶ counthet‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-counthet","content":"counthet(geno::T, allele::Int) where T&lt;:GenoArray counthet(geno::T, allele::AbstractVector{U}) where T&lt;:GenoArray where U&lt;:Integer  Given a GenoArray, count the number of times allele appears in the heterozygous state.  "},{"title":"üì¶ counthom‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-counthom","content":"counthom(geno::T, allele::Int) where T&lt;:GenoArray counthom(geno::T, allele::AbstractVector{U}) where T&lt;:GenoArray where U&lt;:Integer  Given a GenoArray, count the number of times allele appears in the homozygous state.  "},{"title":"üì¶ _genediversitynei87‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-_genediversitynei87","content":"_genediversitynei87(het_exp::T, het_obs::T, n::Union{Integer,T}; corr::Bool = true) where T&lt;: AbstractFloat _genediversitynei87(het_exp::AbstractFloat, het_obs::Missing, n::Union{Integer,AbstractFloat}; corr::Bool = true) _genediversitynei87(het_exp::Missing, het_obs::AbstractFloat, n::Union{Integer,AbstractFloat}; corr::Bool = true) _genediversitynei87(het_exp::Missing, het_obs::Missing, n::Union{Integer,AbstractFloat}; corr::Bool = true)  Calculate overall gene diversity with the adjustment/correction given by Nei: 1‚àí‚àëpÀâi2+Hsn~√ónp‚àíHobs2n~√ónp1-\\sum{\\bar{p}^2_i + \\frac{H_s}{\\tilde{n}\\times np} - \\frac{H_{obs}}{2\\tilde{n}\\times np}}1‚àí‚àëpÀâ‚Äãi2‚Äã+n~√ónpHs‚Äã‚Äã‚àí2n~√ónpHobs‚Äã‚Äã n~\\tilde{n}n~ is the number of genotypes for a locus for a populationnpnpnp is the number of genotypes of a locus across all populations, i.e. ‚àën~\\sum{\\tilde{n}}‚àën~pÀâi2\\bar{p}^2_ipÀâ‚Äãi2‚Äã is the observed homozygosity of a locus for that populationHsH_sHs‚Äã is the within population gene diversity given by:Hs=n~n~‚àí1√ó1‚àí(pÀâi2‚àíHobs2n~)H_s = \\frac{\\tilde{n}}{\\tilde{n}-1} \\times 1 - (\\bar{p}^2_i - \\frac{H_{obs}}{2\\tilde{n}})Hs‚Äã=n~‚àí1n~‚Äã√ó1‚àí(pÀâ‚Äãi2‚Äã‚àí2n~Hobs‚Äã‚Äã) Nei M. (1987) Molecular Evolutionary Genetics. Columbia University Press Use corr = false to ignore sample-size correction * n/(n-1)  "},{"title":"üì¶ _hetero_obs‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-_hetero_obs","content":"_hetero_obs(data::T) where T &lt;: GenoArray  Returns observed heterozygosity as a mean of the number of heterozygous genotypes, defined as genotypes returning true for _ishet(). This is numerically feasible becausetrue values are mathematically represented as 1, whereas false are represented as 0.  "},{"title":"üì¶ _hetero_exp‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-_hetero_exp","content":"_hetero_exp(allele_freqs::Vector{T}) where T &lt;: GenoArray  Returns the expected heterozygosity of an array of genotypes, calculated as 1 - sum of the squared allele frequencies.  "},{"title":"üîµ heterozygosity‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-heterozygosity","content":"heterozygosity(data::PopData; by::Union{Symbol,String} = &quot;locus&quot;)  Calculate observed and expected heterozygosity in a PopData object. For loci, heterozygosity is calculated in the Nei fashion, such that heterozygosity is calculated as the average over heterozygosity per locus per population. Modes &quot;locus&quot; : heterozygosity per locus (default)&quot;sample&quot; : heterozygosity per individual/sample&quot;population&quot;: heterozygosity per population Example heterozygosity(@nancycats, by = &quot;population&quot; )   "},{"title":"üì¶ _heterozygosity‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-_heterozygosity","content":"_heterozygosity(data::PopData, ::Val{:locus}) _heterozygosity(data::PopData, ::Val{:sample}) _heterozygosity(data::PopData, ::Val{:population})   "},{"title":"üîµ samplehet‚Äã","type":1,"pageTitle":"Heterozygosity.jl","url":"/PopGen.jl/docs/api/PopGen/heterozygosity#-samplehet","content":"samplehet(data::PopData, individual::String)  Calculate the observed heterozygosity for an individual in a PopData object. "},{"title":"PairwiseFST.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/pairwisefst","content":"","keywords":""},{"title":"PopGen.jl/src/FStatistics/PairwistFST.jl‚Äã","type":1,"pageTitle":"PairwiseFST.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisefst#popgenjlsrcfstatisticspairwistfstjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ Base.show‚Äã","type":1,"pageTitle":"PairwiseFST.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisefst#-baseshow","content":"Base.show(io::IO, data::PairwiseFST)   "},{"title":"üîµ PairwiseFST‚Äã","type":1,"pageTitle":"PairwiseFST.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisefst#-pairwisefst","content":"PairwiseFST results::DataFrame method::String  A convenience data structure which stores the results and method of a pairwisefst analysis. The object pretty-prints a bit more information to the console, especially when doing a global pairwise FST.  "},{"title":"üîµ pairwisefst‚Äã","type":1,"pageTitle":"PairwiseFST.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisefst#-pairwisefst-1","content":"pairwisefst(data::PopData; method::Function, by::String = &quot;global&quot;, iterations::Int64)  Calculate pairwise FST between populations in a PopData object. Set iterationsto a value greater than 0 to perform a single-tailed permutation test to obtain P-values of statistical significance. Use by = &quot;locus&quot; to perform a locus-by-locus FST for population pairs (iterations and significance testing ignored). Returns a PairwiseFST object, stores a DataFrame of the results, along with the method used to obtain the estimates. Methods:‚Äã Hudson: Hudson et al. (1992) method (only for biallelic data)Nei: Nei (1987) methodWeirCockerham : Weir &amp; Cockerham (1984) method (default) Examples data = @nancycats wc = pairwise_fst(data, method = WeirCockerham) wc_sig = pairwise_fst(data, iterations = 1000)  "},{"title":"KinshipPostHocs.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/kinshipposthocs","content":"","keywords":""},{"title":"PopGen.jl/src/Kinship/KinshipPostHocs.jl‚Äã","type":1,"pageTitle":"KinshipPostHocs.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipposthocs#popgenjlsrckinshipkinshipposthocsjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üì¶ sig_within‚Äã","type":1,"pageTitle":"KinshipPostHocs.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipposthocs#-sig_within","content":"sig_within(data::PopData, results::DataFrame, population::String, iterations::Int = 20000)  "},{"title":"üîµ kinshipposthoc‚Äã","type":1,"pageTitle":"KinshipPostHocs.jl","url":"/PopGen.jl/docs/api/PopGen/kinshipposthocs#-kinshipposthoc","content":"kinshipposthoc(::PopData, results::Union{DataFrame, NamedTuple}; iterations::Int)  Performs a posthoc analysis using the resulting DataFrame or NamedTuple from kinship(). This analysis uses permutations to test if a population has significantly higher within-population kinship than between-population kinship. The results object must have been generated from the provided PopData. Use iterations = to specify the number of iterations for the permutation tests (default = 20000). Recommendedthat you use MultipleTesting.jl to correct resulting P-values. Example julia&gt; cats = @nancycats ; julia&gt; rel_out = kinship(cats, method = [Ritland, Moran], iterations = 100); julia&gt; kinshipposthoc(cats, rel_out) 17x3 DataFrame Row ‚îÇ population Ritland_P Moran_P ‚îÇ String Float64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ 1 5.0e-5 5.0e-5 2 ‚îÇ 2 5.0e-5 5.0e-5 3 ‚îÇ 3 5.0e-5 5.0e-5 4 ‚îÇ 4 5.0e-5 5.0e-5 5 ‚îÇ 5 5.0e-5 5.0e-5 6 ‚îÇ 6 5.0e-5 5.0e-5 7 ‚îÇ 7 5.0e-5 5.0e-5 8 ‚îÇ 8 5.0e-5 5.0e-5 9 ‚îÇ 9 5.0e-5 5.0e-5 10 ‚îÇ 10 5.0e-5 5.0e-5 11 ‚îÇ 11 5.0e-5 5.0e-5 12 ‚îÇ 12 5.0e-5 5.0e-5 13 ‚îÇ 13 5.0e-5 5.0e-5 14 ‚îÇ 14 5.0e-5 5.0e-5 15 ‚îÇ 15 5.0e-5 5.0e-5 16 ‚îÇ 16 5.0e-5 5.0e-5 17 ‚îÇ 17 5.0e-5 5.0e-5  "},{"title":"PCA.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/pca","content":"","keywords":""},{"title":"PopGen.jl/src/PCA.jl‚Äã","type":1,"pageTitle":"PCA.jl","url":"/PopGen.jl/docs/api/PopGen/pca#popgenjlsrcpcajl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ pca‚Äã","type":1,"pageTitle":"PCA.jl","url":"/PopGen.jl/docs/api/PopGen/pca#-pca","content":"pca(data::PopData; maxpc::Int = 0, method::Symbol = :svd, missings::String = &quot;mean&quot;, pratio::Float64 = 0.99, center::Bool = false, scale::Bool = true)  Perform a Principal Component Analysis on a PopData object. Returns an indexible MultivariateStats.PCA object. Arguments data::PopData: a PopData object Keyword Arguments method::Symbol: The PCA method to use (default: :svd) :cov: based on covariance matrix decomposition:svd: based on Singular Value Decomposition of the input data maxpc::Int: The maximum number of principal components to retain (default: 0 = (min(d, ncol-1)))missings::String: How to treat missing genotypes in the allele frequency matrix (default: mean) &quot;mean&quot;: replace missing values with the mean frequency for that allele in that locus&quot;missing&quot;: keep missing values as they are&quot;zero&quot;: replace missing values with 0 pratio::Float64: The maxium ratio of variances preserved in the principal subspace (default = 0.99)center::Bool: whether to center the allele frequency matrix (default: false)scale::Bool: whether to Z-score scale the allele frequency matrix (default: true) "},{"title":"PairwiseKinship.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship","content":"","keywords":""},{"title":"PopGen.jl/src/Kinship/PairwiseKinship.jl‚Äã","type":1,"pageTitle":"PairwiseKinship.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship#popgenjlsrckinshippairwisekinshipjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ kinship‚Äã","type":1,"pageTitle":"PairwiseKinship.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship#-kinship","content":"kinship(data::PopData; method::Function, iterations::Int = 0, interval::Vector{Float64} = [0.025, 0.975]) kinship(data::PopData, samplenames::AbstractVector{T}; method::Function, iterations::Int = 0, interval::Vector{Float64} = [0.025, 0.975]) where T&lt;:AbstractString  Calculate pairwise relatedness estimates for all or specific individuals in a PopData object using the specified method (see below). Returns a NamedMatrix if not performing bootstrapping, otherwise returns a DataFrame (since bootstrapping provides more output information). To calculate means, median, standard error, and confidence intervals using bootstrapping, set iterations = n where n is an integer greater than 0 (the default) corresponding to the number of bootstrap iterations you wish to perform for each pair. The default confidence interval is [0.0275, 0.975] (i.e. 95%), however that can be changed by supplying a Vector{Float64} of [low, high] to the keyword interval. Note: samples must be diploid. Arguments data : A PopData objectsamplenames: Vector of sample names (optional) Keyword Arguments method::Function : A method function (see below)iterations::Int64 : The number of iterations to perform bootstrapping (default: 0, will not perform bootstrapping)interval::Vector{Float64} : A Vector of [low, high] indicating the confidence intervals you would like for bootstrapping (default: [0.275, 0.975], i.e. 95%) Methods| Method | Type | Method Call | |:----|:-----|:-----| | Blouin 1996 | moments-based | Blouin | | Li &amp; Horvitz 1953| moments-based | LiHorvitz | | Loiselle 1995 | moments-based | Loiselle | | Lynch 1988 | moments-based | Lynch | | Lynch/Li 1993 | moments-based | LynchLi | | Lynch &amp; Ritland 1999 | moments-based | LynchRitland | | Moran 1950 | moments-based | Moran | | Queller &amp; Goodnight 1989 | moments-based | QuellerGoodnight | | Ritland 1996 | moments-based | Ritland | julia&gt; cats = @nancycats ; julia&gt; kin = kinship(cats, method = Moran) 237√ó237 Named Matrix{Float64} A ‚ï≤ B ‚îÇ N215 N216 ‚Ä¶ N289 N290 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ N215 ‚îÇ 8.13724e-316 1.62338 ‚Ä¶ 1.04589 1.15351 N216 ‚îÇ 1.62338 0.29485 0.957724 1.1637 N217 ‚îÇ 0.673577 0.587163 0.547427 0.709887 N218 ‚îÇ 0.896935 0.72942 0.919448 0.791255 ‚ãÆ ‚ãÆ ‚ãÆ ‚ã± ‚ãÆ ‚ãÆ N297 ‚îÇ 0.757915 0.858834 1.15432 1.2677 N281 ‚îÇ 0.686057 0.604236 0.942749 1.08762 N289 ‚îÇ 1.04589 0.957724 0.0 1.104 N290 ‚îÇ 1.15351 1.1637 ‚Ä¶ 1.104 0.0 julia&gt; kinship(cats, method = Moran, iterations = 100) 27966√ó7 DataFrame Row ‚îÇ sample1 sample2 Moran bootmean std CI_lower CI_upper ‚îÇ String String Float64 Float64 Float64 Float64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ N215 N216 1.62338 0.376626 0.27286 0.00274863 0.916719 2 ‚îÇ N215 N217 0.673577 0.202888 0.20094 0.00105976 0.59871 3 ‚îÇ N215 N218 0.896935 0.206272 0.232048 7.58373e-5 0.786113 4 ‚îÇ N215 N219 0.988931 0.236503 0.221345 -0.00053018 0.718204 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 27964 ‚îÇ N281 N289 0.942749 0.220475 0.200358 0.001656 0.799307 27965 ‚îÇ N281 N290 1.08762 0.285053 0.289967 0.000299019 1.09343 27966 ‚îÇ N289 N290 1.104 0.277445 0.235519 0.00186445 0.858206 27959 rows omitted   "},{"title":"üì¶ _kinship_noboot_nofreq‚Äã","type":1,"pageTitle":"PairwiseKinship.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship#-_kinship_noboot_nofreq","content":"_kinship_noboot_nofreq(data::PopData, method::Function)   "},{"title":"üì¶ _kinship_noboot_freq‚Äã","type":1,"pageTitle":"PairwiseKinship.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship#-_kinship_noboot_freq","content":"_kinship_noboot_freq(data::PopData, method::Function)   "},{"title":"üì¶ _kinship_boot_nofreq‚Äã","type":1,"pageTitle":"PairwiseKinship.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship#-_kinship_boot_nofreq","content":"_kinship_boot_nofreq(data::PopData, method::Function, iterations::Int, interval::Vector{Float64} = [0.025, 0.975])  "},{"title":"üì¶ _kinship_boot_freq‚Äã","type":1,"pageTitle":"PairwiseKinship.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship#-_kinship_boot_freq","content":"_kinship_boot_freq(data::PopData, method::Function, iterations::Int, interval::Vector{Float64} = [0.025, 0.975])  "},{"title":"üîµ kinshiptotable‚Äã","type":1,"pageTitle":"PairwiseKinship.jl","url":"/PopGen.jl/docs/api/PopGen/pairwisekinship#-kinshiptotable","content":"kinshiptotable(kinshipresults::T, methd::Symbol) where T&lt;:NamedMatrix  Converts the NamedMatrix result from the non-bootstrapped kinship() results into a DataFrame. The second positonal argument (methd) is the name of the value column (default: kinship). For better analysis workflow, it would be useful to specify the method for this column, to keep track of which estimator was used (e.g., Blouin, LynchLi, etc.)Example julia&gt; cats = @nancycats ; kin = kinship(cats, method = Moran) ; julia&gt; kinshiptotable(kin, :Moran) 22366√ó3 DataFrame Row ‚îÇ sample1 sample2 Moran ‚îÇ String String Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ cc_001 cc_002 0.00688008 2 ‚îÇ cc_001 cc_003 -0.0286812 3 ‚îÇ cc_001 cc_005 -0.000749142 4 ‚îÇ cc_001 cc_007 0.0516361 5 ‚îÇ cc_001 cc_008 0.0261128 6 ‚îÇ cc_001 cc_009 -0.00187027 7 ‚îÇ cc_001 cc_010 0.0182852 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ 22361 ‚îÇ seg_028 seg_029 -0.0472928 22362 ‚îÇ seg_028 seg_030 -0.0172853 22363 ‚îÇ seg_028 seg_031 -0.00240921 22364 ‚îÇ seg_029 seg_030 -0.0278483 22365 ‚îÇ seg_029 seg_031 0.0297876 22366 ‚îÇ seg_030 seg_031 -0.0371295 22353 rows omitted  "},{"title":"TSNE.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/tsne","content":"","keywords":""},{"title":"PopGen.jl/src/SummaryInfo.jl‚Äã","type":1,"pageTitle":"TSNE.jl","url":"/PopGen.jl/docs/api/PopGen/tsne#popgenjlsrcsummaryinfojl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ tsne‚Äã","type":1,"pageTitle":"TSNE.jl","url":"/PopGen.jl/docs/api/PopGen/tsne#-tsne","content":"tsne(data::PopData, args...; kwargs...)  Perform t-SNE (t-Stochastic Neighbor Embedding) on a PopData object, returning a DataFrame. Converts the PopData object into a matrix of allele frequencies with missing values replaced with the global mean frequency of that allele. First performs PCA on that matrix, retainingreduce_dims dimensions of the PCA prior to t-SNE analysis. The positional and keyword arguments are the same as tsne from TSne.jl. Arguments data: a PopData objectndims: Dimension of the embedded space (default: 2)reduce_dims the number of the first dimensions of X PCA to use for t-SNE, if 0, all available dimension are used (default: 0)max_iter: Maximum number of iterations for the optimization (default: 1000)perplexity: The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. Different values can result in significantly different results (default: 30) Keyword Arguments (optional) distance: type Function or Distances.SemiMetric, specifies the function to use for calculating the distances between the rowspca_init: whether to use the first ndims of the PCA as the initial t-SNE layout, if false (the default), the method is initialized with the random layoutmax_iter: how many iterations of t-SNE to doverbose: output informational and diagnostic messagesprogress: display progress meter during t-SNE optimization (default: true)min_gain: eta: initial_momentum, final_momentum, momentum_switch_iter,stop_cheat_iter: cheat_scale low-level parameters of t-SNE optimizationextended_output: if true, returns a tuple of embedded coordinates matrix, point perplexities and final Kullback-Leibler divergence "},{"title":"SummaryInfo.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/summaryinfo","content":"","keywords":""},{"title":"PopGen.jl/src/SummaryInfo.jl‚Äã","type":1,"pageTitle":"SummaryInfo.jl","url":"/PopGen.jl/docs/api/PopGen/summaryinfo#popgenjlsrcsummaryinfojl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üîµ alleleaverage‚Äã","type":1,"pageTitle":"SummaryInfo.jl","url":"/PopGen.jl/docs/api/PopGen/summaryinfo#-alleleaverage","content":"alleleaverage(data::PopData, rounding::Bool = true)  Returns a NamedTuple of the average number of alleles ('mean') and standard deviation (stdev) of a PopData. Use rounding = false to not round results. Default (true) roundsto 4 digits. Example alleleaverage(@nancycats, rounding = false)   "},{"title":"üîµ richness‚Äã","type":1,"pageTitle":"SummaryInfo.jl","url":"/PopGen.jl/docs/api/PopGen/summaryinfo#-richness","content":"richness(data::PopData)  Calculates various allelic richness and returns a table of per-locus allelic richness. Use populations = true to calculate richness by locus by population.  "},{"title":"üîµ summary‚Äã","type":1,"pageTitle":"SummaryInfo.jl","url":"/PopGen.jl/docs/api/PopGen/summaryinfo#-summary","content":"summary(data::PopData; by::String = &quot;global&quot;)  Provides summary statistics for a PopData object. Use by = &quot;locus&quot; for summary information by locus. Global values are given as unweighted means of the per-locus parameters. Het_obs‚Äã observed heterozygosity given as: 1 - ‚àë‚Çñ ‚àë·µ¢ P‚Çñ·µ¢·µ¢/np where Pkii represents the proportion of homozygote i in sample k and npis the number of samples in that population HT‚Äã overall gene diversity given as: 1 - ‚àë·µ¢(pÃÑ·µ¢¬≤ + (HS / (nÃÉ √ó np)) - Het_obs / (2 √ó nÃÉ √ó np)) where pÃÑ·µ¢ = ‚àë‚Çñp‚Çñ·µ¢ / np HS‚Äã within population gene diversity given as: 1 - ‚àë·µ¢(p·µ¢¬≤ + HS / (nÃÉ √ó np) - Het_obs / (2 √ó nÃÉ √ó np)) where nÃÉ = np / ‚àë‚Çñ(1/n‚Çñ) where pÃÑ·µ¢¬≤ = ‚àë‚Çñ(p·µ¢‚Çñ¬≤ / np) DST‚Äã amount of gene diversity among samples given as: HT - HS DST‚Ä≤‚Äã amount of gene diversity among samples adjusted for sample size given as: (np / (np-1)) √ó Dst HT‚Ä≤‚Äã overall gene diversity adjusted for sample size given as: HS + DST‚Ä≤ FST‚Äã proportion of the total genetic variance in subpopulations relative to the total genetic variance given as: DST / HT FST‚Ä≤‚Äã proportion of the total genetic variance in subpopulations relative to the total genetic variance, adjusted for heterozygosity given as: DST‚Ä≤ / HT‚Ä≤ FIS‚Äã proportion of the genetic variance in a locus relative to the genetic variance within subpopulations given as: 1 - (Het_obs / HS) DEST‚Äã population differentiation (Jost 2008) given as: (np/(np-1)) √ó (Ht'-Hs) / (1-Hs) "},{"title":"AlleleFreq.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/allelefreq","content":"","keywords":""},{"title":"PopGenCore.jl/src/AlleleFreq.jl‚Äã","type":1,"pageTitle":"AlleleFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelefreq#popgencorejlsrcallelefreqjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ allelefreq‚Äã","type":1,"pageTitle":"AlleleFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelefreq#-allelefreq","content":"allelefreq(genos::GenoArray, allele::Int)  Return the frequency of a specific allele from a vector of Genotypes genos. Example ncats = @nancycats; ncats_sub = ncats[(ncats.genodata.locus .== &quot;fca8&quot;) .&amp; (ncats.genodata.genotype .!== missing)] pop_grp = groupby(ncats_sub, :population) DataFrames.combine(pop_grp, :genotype =&gt; (geno -&gt; allelefreq(137, geno)) =&gt; :freq_137)   allelefreq(geno::Genotype)  Return a Dict of allele frequencies of the alleles within a single Genotype in a PopDataobject.  allelefreq(locus::T) where T&lt;:GenotypeArray  Return a Dict of allele frequencies of a single locus in a PopDataobject.  allelefreq(data::PopData, locus::String; population::Bool = false)  Return a Dict of allele frequencies of a single locus in a PopDataobject. Use population = true to return a table of allele frequencies of that locus per population. Example cats = @nancycats allelefreq(cats, &quot;fca8&quot;) allelefreq(cats, &quot;fca8&quot;, population = true)   "},{"title":"üü™ avg_allelefreq‚Äã","type":1,"pageTitle":"AlleleFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelefreq#-avg_allelefreq","content":"avg_allelefreq(allele_dicts::AbstractVector{Dict{T, Float64}}, power::Int = 1) where T&lt;:Signed  Takes a Vector of Dicts generated by allelefreq and returns a Dict of the average allele frequencies raised to the power (exponent) specified (default: 1). This is typically done to calculate average allele frequencies across populations. Example cats = @nancycats; alleles_df = DataFrames.combine( groupby(cats.genodata, [:locus, :population]), :genotype =&gt; allelefreq =&gt; :alleles ); DataFrames.combine( groupby(alleles_df, :locus), :alleles =&gt; (i -&gt; sum(avg_allelefreq(i, 2))) =&gt; :avg_freq )   "},{"title":"üü™ allelefreq_vec‚Äã","type":1,"pageTitle":"AlleleFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelefreq#-allelefreq_vec","content":"allelefreq_vec(locus::T) where T&lt;:GenotypeArray  Return a Vector of allele frequencies of a single locus in a PopData object. Similar to allelefreq(), except it returns only the frequencies, without the allele names, meaning they can be in any order. This can be useful for getting the expected genotype frequencies. "},{"title":"Utils.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGen/utils","content":"","keywords":""},{"title":"PopGen.jl/src/Utils.jl‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGen/utils#popgenjlsrcutilsjl","content":"üì¶ not exported\tüîµ exported by PopGen.jl "},{"title":"üì¶ _adjacency_matrix‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGen/utils#-_adjacency_matrix","content":"_adjacency_matrix(data::PopData)   "},{"title":"üì¶ _p_adjust‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGen/utils#-_p_adjust","content":"_p_adjust(pvals::Vector{T}, method::String) where T &lt;: Union{Missing, &lt;:AbstractFloat}  Modification to MultipleTesting.adjust to include missing values in the returned array. See MultipleTesting.jl docs for full more detailed information. Example julia&gt; _p_adjust([0.1, 0.01, 0.005, 0.3], &quot;bh&quot;)  correction methods (case insensitive) &quot;bonferroni&quot; : Bonferroni adjustment&quot;holm&quot; : Holm adjustment&quot;hochberg&quot; : Hochberg adjustment&quot;bh&quot; : Benjamini-Hochberg adjustment&quot;by&quot; : Benjamini-Yekutieli adjustment&quot;bl&quot; : Benjamini-Liu adjustment&quot;hommel&quot; : Hommel adjustment&quot;sidak&quot; : ≈†id√°k adjustment&quot;forwardstop&quot; or &quot;fs&quot; : Forward-Stop adjustment&quot;bc&quot; : Barber-CandeÃÄs adjustment &quot;&quot;&quot;  "},{"title":"üì¶ feature_req‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGen/utils#-feature_req","content":"feature_req()  Returns the text: Please open an Issue or Pull Request on https://www.github.com/biojulia/PopGen.jl if you would like this feature implemented "},{"title":"CBaypass.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/baypass","content":"","keywords":""},{"title":"PopGenCore.jl/src/io/Baypass.jl‚Äã","type":1,"pageTitle":"CBaypass.jl","url":"/PopGen.jl/docs/api/PopGenCore/baypass#popgencorejlsrciobaypassjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üì¶ _setcounts_biallelic‚Äã","type":1,"pageTitle":"CBaypass.jl","url":"/PopGen.jl/docs/api/PopGenCore/baypass#-_setcounts_biallelic","content":"_setcounts_biallelic(q, r)  Returns a vector of counts of alleles from Genotypes q in allele vector r. This is distinct from setcounts in that missing values are preserved as 0 instead of -1  "},{"title":"üì¶ countmatrix_biallelic‚Äã","type":1,"pageTitle":"CBaypass.jl","url":"/PopGen.jl/docs/api/PopGenCore/baypass#-countmatrix_biallelic","content":"countmatrix_biallelic(data::PopData)  Create a matrix of allele count per genotype where rows are samples and columns are the occurence count of an allele for that locus in that sample.missing values are preserved as `0``.  "},{"title":"üü™üîµ baypass‚Äã","type":1,"pageTitle":"CBaypass.jl","url":"/PopGen.jl/docs/api/PopGenCore/baypass#-baypass","content":"baypass(data::PopData; filename::Union{String, Nothing} = nothing)  Convert a PopData object into a Baypass-format matrix. The required input format for the software requires biallelic data. By default, it returns just the Baypass-format matrix; use the keyword argument filename to specify a file to write the matrix to. This function does not perform a Baypass analysis, but instead creates the input matrix necessary for it. The matrix specification is: rows = loci each row is a different locus columns = allele counts per population - each pair of columns correspond to the alleles' counts (2 alleles, 2 columns) for a population - as a result, there should be 2 √ó n_populations columns - e.g. row 1, columns 1:2 are the allele counts for locus 1 in population 1 Baypass information: http://www1.montpellier.inra.fr/CBGP/software/baypass/ "},{"title":"AlleleMatrices.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/allelematrices","content":"","keywords":""},{"title":"PopGenCore.jl/src/AlleleMatrices.jl‚Äã","type":1,"pageTitle":"AlleleMatrices.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelematrices#popgencorejlsrcallelematricesjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ matrix‚Äã","type":1,"pageTitle":"AlleleMatrices.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelematrices#-matrix","content":"matrix(data::PopData, matrixtype::String = &quot;frequency&quot;; missings = &quot;mean&quot;, scale = false, center = false)  Return a matrix of allele counts or frequencies per genotype where rows are samples and columns are the occurence count or frequency of an allele for that locus in that sample. Loci and alleles are sorted alphanumerically. The scale and center keywords are only relevant for allele frequencies, not counts. Positional Arguments data: a PopData objectmatrixtype: a String or Symbol of count or frequency (default: frequency) Keyword Arguments missings: a String denoting how to handle missing values when outputting frequency (default: mean) &quot;missing&quot;: fallback method to keep missing values as they are&quot;zero&quot;: replace missing values with 0&quot;mean&quot;: replace missing values with the mean frequency for that allele in that locus scale: a 'Bool' of whether to z-score scale allele frequencies (default: false)center: a Bool of whether to center the allele frequencies (default: 'false') Example julia&gt; cats = @nancycats ; julia&gt; cnts = matrix(cats, &quot;count&quot;) ; cnts[1:5,1:6] 5√ó6 Matrix{Union{Missing, Int8}}: missing missing missing missing missing missing missing missing missing missing missing missing 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 julia&gt; frq = matrix(cats, &quot;frequency&quot;) ; frq[1:5,1:6] 5√ó6 Matrix{Union{Missing, Float32}}: 0.00460829 0.00460829 0.0276498 0.133641 0.00460829 0.0921659 0.00460829 0.00460829 0.0276498 0.133641 0.00460829 0.0921659 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 julia&gt; frq = matrix(cats, :frequency, missings = &quot;zero&quot;) ; frq[1:5,1:6] 5√ó6 Matrix{Float64}: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 julia&gt; frq = matrix(cats, missings = &quot;mean&quot;, scale = true, center = true) ; frq[1:5,1:6] 5√ó6 Matrix{Float32}: 7.17017f-9 7.17017f-9 0.0 0.0 7.17017f-9 0.0 7.17017f-9 7.17017f-9 0.0 0.0 7.17017f-9 0.0 -0.0709577 -0.0709577 -0.175857 -0.394198 -0.0709577 -0.300797 -0.0709577 -0.0709577 -0.175857 -0.394198 -0.0709577 -0.300797 -0.07   "},{"title":"üì¶ _setcounts‚Äã","type":1,"pageTitle":"AlleleMatrices.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelematrices#-_setcounts","content":" "},{"title":"üì¶ _matrix‚Äã","type":1,"pageTitle":"AlleleMatrices.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelematrices#-_matrix","content":"_matrix(data::PopData, ::Val{:count})  Create a matrix of allele count per genotype where rows are samples and columns are the occurence count of an allele for that locus in that sample. Missing values are preserved as -1.  _matrix(data::PopData, ::Val{:frequencyzero})  Create a matrix of allele frequencies per genotype where rows are samples and columns are the frequency of an allele for that locus in that sample. Missing values are replaced by zeros.  _matrix(data::PopData, ::Val{:frequencymean})  Create a matrix of allele frequencies per genotype where rows are samples and columns are the frequency of an allele for that locus in that sample. Missing values are replaced by the global mean allele frequency.  _matrix(data::PopData, ::Val{:frequencymissing})  Create a matrix of allele frequencies per genotype where rows are samples and columns are the frequency of an allele for that locus in that sample. Missing values are kept as missing.  "},{"title":"üü™ featurematrix‚Äã","type":1,"pageTitle":"AlleleMatrices.jl","url":"/PopGen.jl/docs/api/PopGenCore/allelematrices#-featurematrix","content":"featurematrix(data::PopData, matrixtype::Union{String, Symbol} = &quot;genotype&quot;)  Positional Arguments - `data`: a PopData object - `matrixtype`: a `String` or `Symbol` of `genotype`, or `allele` (default: `genotype`)  genotype feature matrix Return a matrix of dummy-encoded genotypes (0,1,2...), where rows correspond with samples and columns correspond to loci. Missing genotypes are encoded as -1. For biallelic loci, 0 encodes homozygous for allele 1, 1 encodes for a heterozygote, and 2 encodes for homozygous allele 2. allele feature matrix Return a matrix of dummy-encoded alleles (0,1), where rows correspond with samples and columns correspond to alleles within loci, such that there are as many columns per locus as alleles for that locus. Missing alleles (from missing genotypes) are encoded as -1. Example julia&gt; cats = @nancycats ; julia&gt; featurematrix(cats) 237√ó9 Matrix{Int8}: -1 0 0 0 0 0 0 0 0 -1 1 1 1 0 0 1 0 0 0 0 2 2 1 1 2 0 1 1 2 3 3 2 0 0 1 0 1 3 4 4 3 0 3 0 0 ‚ãÆ ‚ãÆ 49 0 1 -1 36 0 0 -1 13 48 6 8 -1 25 1 2 -1 0 29 9 23 -1 7 3 26 14 0 3 5 8 -1 2 1 3 14 0 29 10 16 -1 4 3 2 -1 0 julia&gt; featurematrix(cats, &quot;allele&quot;) 237√ó108 Matrix{Int8}: -1 -1 -1 -1 -1 ‚Ä¶ 0 0 0 0 0 0 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ‚ãÆ ‚ã± ‚ãÆ 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ‚Ä¶ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   _featurematrix(data::PopData, ::Val{:genotype})  Return a matrix of dummy-encoded genotypes (0,1,2...), where rows correspond with samples and columns correspond to loci. Missing genotypes are encoded as -1. For biallelic loci, 0 encodes homozygous for allele 1, 1 encodes for a heterozygote, and 2 encodes for homozygous allele 2.  _featurematrix(data::PopData, ::Val{:allele})  Return a matrix of dummy-encoded alleles (0,1,2...), where rows correspond with samples and columns correspond to loci. Missing genotypes are encoded as -1. "},{"title":"Datasets.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/datasets","content":"","keywords":""},{"title":"PopGenCore.jl/src/Datasets.jl‚Äã","type":1,"pageTitle":"Datasets.jl","url":"/PopGen.jl/docs/api/PopGenCore/datasets#popgencorejlsrcdatasetsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üì¶ dataset‚Äã","type":1,"pageTitle":"Datasets.jl","url":"/PopGen.jl/docs/api/PopGenCore/datasets#-dataset","content":"dataset(::String)  Load an example dataset from either &quot;gulfsharks&quot; (SNP) or &quot;nancycats&quot; (microsatellite). Can also use &quot;sharks&quot; and &quot;cats&quot;as shorthands. Use ?@nancycats and ?@gulfsharks to learn more about these datasets. Example ncats = dataset(&quot;nancycats&quot;) gsharks = dataset(&quot;sharks&quot;)   "},{"title":"üü™üîµ @nancycats‚Äã","type":1,"pageTitle":"Datasets.jl","url":"/PopGen.jl/docs/api/PopGenCore/datasets#-nancycats","content":"@nancycats  Returns a PopObj of corresponding &quot;nancycats&quot; dataset as featured in the R package adegenet. This is microsatellite data of 9 loci in 237 individuals across 17 populations. Example ncats = @nancycats   "},{"title":"üü™üîµ @gulfsharks‚Äã","type":1,"pageTitle":"Datasets.jl","url":"/PopGen.jl/docs/api/PopGenCore/datasets#-gulfsharks","content":"@gulfsharks  Returns a PopObj corresponding the Blacknose shark dataset as used in Dimens et al. 2019. This is a mid-sized SNP dataset of 2213 SNPs in 212 individuals, across 7 populations. Example sharks = @gulfsharks  "},{"title":"Conditionals.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/conditionals","content":"","keywords":""},{"title":"PopGenCore.jl/src/Conditionals.jl‚Äã","type":1,"pageTitle":"Conditionals.jl","url":"/PopGen.jl/docs/api/PopGenCore/conditionals#popgencorejlsrcconditionalsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™üîµ isbiallelic‚Äã","type":1,"pageTitle":"Conditionals.jl","url":"/PopGen.jl/docs/api/PopGenCore/conditionals#-isbiallelic","content":"isbiallelic(data::GenoArray)  Returns true if the GenoArray is biallelic, false if not.  isbiallelic(data::DataFrame)   isbiallelic(data::PopData)  Returns true all the loci in the PopData are biallelic, false if not.  "},{"title":"üü™üîµ ishom‚Äã","type":1,"pageTitle":"Conditionals.jl","url":"/PopGen.jl/docs/api/PopGenCore/conditionals#-ishom","content":"ishom(locus::T) where T &lt;: GenoArray ishom(locus::Genotype) ishom(locus::Missing)  A series of methods to test if a locus or loci are homozygous and return true if it is, false if it isn't (or missing). For calculations, we recommend using _ishom(), which returns missing if the genotype is missing. The vector version simply maps the function over the elements.  ishom(locus::Genotype, allele::Signed) ishom(loci::GenoArray, allele::Signed) ishom(geno::Missing, allele::Signed)  Returns true if the locus/loci is/are homozygous for the specified allele. "},{"title":"üü™ _ishom‚Äã","type":1,"pageTitle":"Conditionals.jl","url":"/PopGen.jl/docs/api/PopGenCore/conditionals#-_ishom","content":"_ishom(locus::T) where T &lt;: GenoArray _ishom(locus::Genotype) _ishom(locus::Missing)  Returns true if the locus/loci is/are homozygous for the specified allele andmissing if the genotype is missing. "},{"title":"üü™üîµ ishet‚Äã","type":1,"pageTitle":"Conditionals.jl","url":"/PopGen.jl/docs/api/PopGenCore/conditionals#-ishet","content":"ishet(locus::T) where T &lt;: GenoArray ishet(locus::Genotype) ishet(locus::Missing)  A series of methods to test if a locus or loci are heterozygous and return true if it is, false if it isn't. The vector version simply broadcasts the function over the elements. Under the hood, this function is simply !ishom. function ishet(locus::Genotype) ishet(locus::Genotype, allele::Signed) ishet(loci::GenoArray, allele::Signed)  Returns true if the locus/loci is/are heterozygous for the specified allele. "},{"title":"üü™ _ishet‚Äã","type":1,"pageTitle":"Conditionals.jl","url":"/PopGen.jl/docs/api/PopGenCore/conditionals#-_ishet","content":"_ishet(locus::T) where T &lt;: GenoArray _ishet(locus::Genotype) _ishet(locus::Missing)  Returns true if the locus/loci is/are heterozygous for the specified allele andmissing if the genotype is missing. "},{"title":"Genepop.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/genepop","content":"","keywords":""},{"title":"PopGenCore.jl/src/io/Genepop.jl‚Äã","type":1,"pageTitle":"Genepop.jl","url":"/PopGen.jl/docs/api/PopGenCore/genepop#popgencorejlsrciogenepopjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ genepop‚Äã","type":1,"pageTitle":"Genepop.jl","url":"/PopGen.jl/docs/api/PopGenCore/genepop#-genepop","content":"genepop(infile::String; kwargs...)  Load a Genepop format file into memory as a PopData object. infile::String : path to Genepop file Keyword Arguments digits::Integer: number of digits denoting each allele (default: 3)popsep::String : word that separates populations in infile (default: &quot;POP&quot;)diploid::Bool : whether samples are diploid for parsing optimizations (default: true)silent::Bool : whether to print file information during import (default: true)allow_monomorphic : whether to keep monomorphic loci in the dataset (default: false) File must follow standard Genepop formatting First line is a comment (and skipped)Loci are listed after first line as one-per-line without commas or in single comma-separated rowA line with a particular keyword (default POP) must delimit populationsSample name is immediately followed by a commaFile is tab or space delimted (but not both!) Genepop file example: wasp_hive.gen: Wasp populations in New York \\n Locus1 Locus2 Locus3 pop Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 pop Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120  Example waspsNY = genepop(&quot;wasp_hive.gen&quot;, digits = 3, popsep = &quot;pop&quot;)   genepop(data::PopData; filename::String = &quot;output.gen&quot;, digits::Int = 3, format::String = &quot;vertical&quot;)  Writes a PopData object to a Genepop-formatted file data: the PopData object you wish to convert to a Genepop file Keyword arguments filename: a String of the output filenamedigits : an Integer indicating how many digits to format each allele as (e.g. (1, 2) =&gt; 001002 for digits = 3)format : a String indicating whether loci should be formatted vertically (&quot;v&quot; or &quot;vertical&quot;)hortizontally (&quot;h&quot;, or &quot;horizontal&quot;)Genepop Isolation-By-Distance (&quot;ibd&quot;) where each sample is a population with long/lat data prepended Example cats = @nancycats; fewer_cats = omit_samplenames(cats, samplenames(cats)[1:10]); julia&gt; genepop(fewer_cats, filename = &quot;filtered_nancycats.gen&quot;, digits = 3, format = &quot;h&quot;)  "},{"title":"Delimited.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/delimited","content":"","keywords":""},{"title":"PopGenCore.jl/src/io/Delimited.jl‚Äã","type":1,"pageTitle":"Delimited.jl","url":"/PopGen.jl/docs/api/PopGenCore/delimited#popgencorejlsrciodelimitedjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ delimited‚Äã","type":1,"pageTitle":"Delimited.jl","url":"/PopGen.jl/docs/api/PopGenCore/delimited#-delimited","content":"delimited(infile::String; delim::Union{Char,String,Regex} = &quot;auto&quot;, digits::Int64 = 3, silent::Bool = false)  Load a delimited-type file into memory as a PopData object. There should be no empty cells in your file Arguments‚Äã infile : path to file Keyword Arguments‚Äã delim : delimiter characters. By default uses auto-parsing of CSV.Filedigits : number of digits denoting each allele (default: 3)diploid : whether samples are diploid for parsing optimizations (default: true)silent : whether to print file information during import (default: true)allow_monomorphic : whether to keep monomorphic loci in the dataset (default: false) File formatting:‚Äã The first row is column names (names don't matter)The columns must be in this order: sample namepopulation namelongitudelatitudelocus_1 genotypeslocus_2 genotypesetc... Missing data‚Äã Genotypes‚Äã Missing genotypes can be formatted as all-zeros 000000, left empty, or negative-nine -9 Location data‚Äã If location data is missing for a sample (which is ok!), make sure the value is blank, otherwise there will be transcription errors! (look at line 3 in the example below) Example lizardsCA = delimited(&quot;CA_lizards.csv&quot;, digits = 3);  Formatting example‚Äã name,population,long,lat,Locus1,Locus2,Locus3 sierra_01,mountain,11.11,-22.22,001001,-9,001001 sierra_02,mountain,11.12,-22.21,001001,001001,001002 snbarb_01,coast,,,001001,001001,001002 snbarb_02,coast,11.14,-22.24,001001,001001,001001 snbarb_03,coast,11.15,,001002,001001,001001  Example lizardsCA = delimited(&quot;CA_lizards.csv&quot;, digits = 3);   delimited(data::PopData; filename::String, delim::String = &quot;,&quot;, digits::Integer = 3, format::String = &quot;wide&quot;)  Write PopData to a text-delimited file. Keyword Arguments‚Äã filename: a String of the output filenamedigits : an Integer indicating how many digits to format each allele as (e.g. (1, 2) =&gt; 001002 for digits = 3)format : a String indicating whether to output in&quot;wide&quot; or &quot;long&quot; (aka &quot;tidy&quot;) format delim : the String delimiter to use for writing the file.  Example cats = @nancycats; fewer_cats = omit_samplenames(cats, samplenames(cats)[1:10]); delimited(fewer_cats, filename = &quot;filtered_nancycats.csv&quot;, digits = 3, format = &quot;wide&quot;, delim = &quot; &quot;)  "},{"title":"GenoFreq.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/genofreq","content":"","keywords":""},{"title":"PopGenCore.jl/src/GenoFreq.jl‚Äã","type":1,"pageTitle":"GenoFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/genofreq#popgencorejlsrcgenofreqjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ genocount_observed‚Äã","type":1,"pageTitle":"GenoFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/genofreq#-genocount_observed","content":"genocount_observed(locus::T) where T&lt;:GenotypeArray  Return a Dict of genotype counts of a single locus in aPopData object.  "},{"title":"üü™ genocount_expected‚Äã","type":1,"pageTitle":"GenoFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/genofreq#-genocount_expected","content":"genocount_expected(locus::T) where T&lt;:GenotypeArray  Return a Dict of the expected genotype counts of a single locus in aPopData object. Expected counts are calculated as the product of observed allele frequencies multiplied by the number of non-missing genotypes.  "},{"title":"üü™ genofreq‚Äã","type":1,"pageTitle":"GenoFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/genofreq#-genofreq","content":"genofreq(locus::T) where T&lt;:GenotypeArray `PopData` object.  Return a Dict of genotype frequencies of a single locus in a  genofreq(data::PopData, locus::String; population::Bool = false)  Return a Dict of genotype frequencies of a single locus in a PopDataobject. Use population = true to return a table of genotype frequencies of that locus per population. cats = @nancycats genofreq(cats, &quot;fca8&quot;) genofreq(cats, &quot;fca8&quot;, population = true)   "},{"title":"üü™ genofreq_expected‚Äã","type":1,"pageTitle":"GenoFreq.jl","url":"/PopGen.jl/docs/api/PopGenCore/genofreq#-genofreq_expected","content":"genofreq_expected(locus::T) where T&lt;:GenotypeArray  Return a Dict of the expected genotype frequencies of a single locus in a PopData object. Expected frequencies are calculated as the product of observed allele frequencies.  genofreq_expected(data::PopData, locus::String; population::Bool = false)  Return a Dict of expected genotype frequencies of a single locus in aPopData object. Use population = true to return a table of expected genotype frequencies of that locus per population. Example cats = @nancycats genofreq_expeced(cats, &quot;fca8&quot;) genofreq_expected(cats, &quot;fca8&quot;, population = true)  "},{"title":"GeneralUtils.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/generalutils","content":"","keywords":""},{"title":"PopGenCore.jl/src/Utils/GeneralUtils.jl‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#popgencorejlsrcutilsgeneralutilsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™üîµ Base.copy‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-basecopy","content":"Base.copy(data::PopData)   "},{"title":"üü™üîµ Base.size‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-basesize","content":"Base.size(data::PopData)   "},{"title":"üü™üîµ Base.sort‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-basesort","content":"Base.sort(x::NTuple{N,T}) where N where T &lt;: Signed  Sort the integers within a Tuple and return the sorted Tuple.  "},{"title":"üü™ convertcoord‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-convertcoord","content":"convertcoord(coordinate::String)  Takes non-decimal-degree format as a String and returns it as a decimal degreeFloat32. Can be broadcasted over an array of coordinate strings to convert them. Formatting requirements‚Äã Coordinates as a String separated by spaces (&quot;11 43 41&quot;) or colons (&quot;11:43:41&quot;)Must use negative sign (&quot;-11 43.52&quot;) or single-letter cardinal direction (&quot;11 43.52W&quot;)Missing data should be coded as the string &quot;missing&quot; (can be accomplished with replace!())Can mix colons and spaces (although it's bad practice) Example julia&gt; convertcoord(&quot;-41 31.52&quot;) -41.5253f0 julia&gt; convertcoord.([&quot;-41 31.52&quot;, &quot;25 11:54S&quot;]) 2-element Array{Float32,1}: -41.5253 -25.1983   "},{"title":"üü™üîµ dropmonomorphic‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-dropmonomorphic","content":"dropmonomorphic(data::PopData; silent::Bool = false)  Return a PopData object omitting any monomorphic loci. Will inform you which loci were removed.  "},{"title":"üü™üîµ dropmonomorphic!‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-dropmonomorphic-1","content":"dropmonomorphic!(data::PopData; silent::Bool = false)  Edit a PopData object in place by omitting any monomorphic loci. Will inform you which loci were removed.  "},{"title":"üü™üîµ dropmultiallelic(data::PopData)‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-dropmultiallelicdatapopdata","content":"dropmultiallelic  Return a PopData object omitting loci that are not biallelic.  "},{"title":"üü™üîµ dropmultiallelic!(data::PopData)‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-dropmultiallelicdatapopdata-1","content":"dropmultiallelic!  Edit a PopData object in place, removing loci that are not biallelic.  "},{"title":"üì¶ truncatepath‚Äã","type":1,"pageTitle":"GeneralUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/generalutils#-truncatepath","content":"truncatepath(text::String)  "},{"title":"GenotypeUtils.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils","content":"","keywords":""},{"title":"PopGenCore.jl/src/Utils/GenotypeUtils.jl‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#popgencorejlsrcutilsgenotypeutilsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ alleles‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#-alleles","content":"allelecount(locus::T) where T&lt;:GenoArray  Return the number of unique alleles present at a locus.  "},{"title":"üü™ alleles‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#-alleles-1","content":"alleles(locus::T) where T&lt;:GenoArray  Return an array of all the non-missing alleles of a locus.  "},{"title":"üü™ alleles‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#-alleles-2","content":"alleles(locus::T, miss::Bool = false) where T&lt;:GenoArray  Return an array of all the non-missing alleles of a locus. Use the second positional argument as true to include missing values.  "},{"title":"üü™ uniquealleles‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#-uniquealleles","content":"uniquealleles(locus::T) where T&lt;:GenoArray  Return an array of all the unique non-missing alleles of a locus.  "},{"title":"üü™ locidataframe‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#-locidataframe","content":"locidataframe(data::PopData)  Return a wide DataFrame of samples as columns, ommitting population information. Example julia&gt; locidataframe(@nancycats) 9√ó237 DataFrame. Omitted printing of 232 columns ‚îÇ Row ‚îÇ N215 ‚îÇ N216 ‚îÇ N217 ‚îÇ N218 ‚îÇ N219 ‚îÇ ‚îÇ ‚îÇ Tuple‚Ä¶? ‚îÇ Tuple‚Ä¶? ‚îÇ Tuple‚Ä¶? ‚îÇ Tuple‚Ä¶? ‚îÇ Tuple‚Ä¶? ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ 1 ‚îÇ missing ‚îÇ missing ‚îÇ (135, 143) ‚îÇ (133, 135) ‚îÇ (133, 135) ‚îÇ ‚îÇ 2 ‚îÇ (136, 146) ‚îÇ (146, 146) ‚îÇ (136, 146) ‚îÇ (138, 138) ‚îÇ (140, 146) ‚îÇ ‚îÇ 3 ‚îÇ (139, 139) ‚îÇ (139, 145) ‚îÇ (141, 141) ‚îÇ (139, 141) ‚îÇ (141, 145) ‚îÇ ‚îÇ 4 ‚îÇ (116, 120) ‚îÇ (120, 126) ‚îÇ (116, 116) ‚îÇ (116, 126) ‚îÇ (126, 126) ‚îÇ ‚îÇ 5 ‚îÇ (156, 156) ‚îÇ (156, 156) ‚îÇ (152, 156) ‚îÇ (150, 150) ‚îÇ (152, 152) ‚îÇ ‚îÇ 6 ‚îÇ (142, 148) ‚îÇ (142, 148) ‚îÇ (142, 142) ‚îÇ (142, 148) ‚îÇ (142, 148) ‚îÇ ‚îÇ 7 ‚îÇ (199, 199) ‚îÇ (185, 199) ‚îÇ (197, 197) ‚îÇ (199, 199) ‚îÇ (193, 199) ‚îÇ ‚îÇ 8 ‚îÇ (113, 113) ‚îÇ (113, 113) ‚îÇ (113, 113) ‚îÇ (91, 105) ‚îÇ (113, 113) ‚îÇ ‚îÇ 9 ‚îÇ (208, 208) ‚îÇ (208, 208) ‚îÇ (210, 210) ‚îÇ (208, 208) ‚îÇ (208, 208) ‚îÇ   "},{"title":"üü™ locimatrix‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#-locimatrix","content":"locimatrix(data::PopData)  Return a matrix of genotypes with dimensions samples √ó loci. Rows are samples and columns are loci. Will return an error if ploidy varies between samples. Example julia&gt; locimatrix(@nancycats) 237√ó9 Array{Union{Missing, Tuple{Int16,Int16}},2}: missing (136, 146) (139, 139) ‚Ä¶ (199, 199) (113, 113) (208, 208) missing (146, 146) (139, 145) (185, 199) (113, 113) (208, 208) (135, 143) (136, 146) (141, 141) (197, 197) (113, 113) (210, 210) (133, 135) (138, 138) (139, 141) (199, 199) (91, 105) (208, 208) (133, 135) (140, 146) (141, 145) (193, 199) (113, 113) (208, 208) (135, 143) (136, 146) (145, 149) ‚Ä¶ (193, 195) (91, 113) (208, 208) (135, 135) (136, 146) (139, 145) (199, 199) (105, 113) (208, 208) (135, 143) (136, 146) (135, 149) (193, 197) (91, 91) (208, 212) (137, 143) (136, 146) (139, 139) (197, 197) (105, 113) (208, 212) (135, 135) (132, 132) (141, 145) (197, 197) (91, 105) (208, 208) (137, 141) (130, 136) (137, 145) ‚Ä¶ (193, 199) (91, 91) (182, 182) (129, 133) (130, 136) (135, 145) (193, 199) (91, 113) (182, 208) ‚ãÆ ‚ã± (133, 135) (136, 136) (135, 139) ‚Ä¶ (199, 199) (113, 113) (182, 182) (133, 141) (136, 136) (135, 139) (197, 197) (113, 113) (182, 208) (133, 141) (130, 146) (141, 141) (191, 199) missing (208, 208) (123, 133) (138, 138) (141, 145) (191, 197) missing (208, 208) (123, 133) (138, 138) (139, 139) (197, 199) missing (208, 208) (133, 141) (136, 146) (139, 139) ‚Ä¶ (197, 197) missing (208, 208) (133, 141) (130, 136) (139, 145) (191, 199) missing (208, 208) (133, 141) (136, 146) (139, 145) (199, 199) missing (208, 220) (133, 143) (130, 130) (135, 145) (197, 197) missing (208, 208) (135, 141) (136, 144) (143, 143) (191, 197) (113, 117) (208, 208) (137, 143) (130, 136) (135, 145) ‚Ä¶ (193, 199) (113, 117) (208, 208) (135, 141) (130, 146) (135, 139) (197, 197) missing (208, 208)   "},{"title":"üü™ phasedmatrix‚Äã","type":1,"pageTitle":"GenotypeUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/genotypeutils#-phasedmatrix","content":"phasedmatrix(data::PopData)  Return a Vector of length ploidy composed of allele matrices with dimensions samples √ó loci. Rows are samples and columns are loci. Will return an error if ploidy varies between samples. Example julia&gt; mtx = phasedmatrix(@nancycats) 2-element Array{Array{Union{Missing, Int16},2},1}: [missing 136 ‚Ä¶ 113 208; missing 146 ‚Ä¶ 113 208; ‚Ä¶ ; 137 130 ‚Ä¶ 113 208; 135 130 ‚Ä¶ missing 208] [missing 146 ‚Ä¶ 113 208; missing 146 ‚Ä¶ 113 208; ‚Ä¶ ; 143 136 ‚Ä¶ 117 208; 141 146 ‚Ä¶ missing 208] julia&gt; mtx[1] 237√ó9 Array{Union{Missing, Int16},2}: missing 136 139 116 156 142 199 113 208 missing 146 139 120 156 142 185 113 208 135 136 141 116 152 142 197 113 210 133 138 139 116 150 142 199 91 208 133 140 141 126 152 142 193 113 208 135 136 145 120 150 148 193 91 208 135 136 139 116 152 142 199 105 208 135 136 135 120 154 142 193 91 208 137 136 139 116 150 142 197 105 208 135 132 141 120 150 148 197 91 208 137 130 137 128 152 142 193 91 182 129 130 135 126 144 140 193 91 182 ‚ãÆ ‚ãÆ 133 136 135 missing 146 142 199 113 182 133 136 135 missing 150 142 197 113 182 133 130 141 missing 148 142 191 missing 208 123 138 141 missing 148 142 191 missing 208 123 138 139 missing 150 142 197 missing 208 133 136 139 missing 150 142 197 missing 208 133 130 139 missing 152 142 191 missing 208 133 136 139 missing 150 142 199 missing 208 133 130 135 missing 148 142 197 missing 208 135 136 143 missing 144 142 191 113 208 137 130 135 missing 150 142 193 113 208 135 130 135 missing 150 142 197 missing 208  "},{"title":"ioUtils.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/ioutils","content":"","keywords":""},{"title":"PopGenCore.jl/src/Utils/ioUtils.jl‚Äã","type":1,"pageTitle":"ioUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/ioutils#popgencorejlsrcutilsioutilsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üì¶ isbinary‚Äã","type":1,"pageTitle":"ioUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/ioutils#-isbinary","content":"isbinary(filepath::String)  Returns true if the filepath is a binary file.  "},{"title":"üü™ findploidy‚Äã","type":1,"pageTitle":"ioUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/ioutils#-findploidy","content":"findploidy(genotypes::T) where T&lt;:AbstractVector  Used internally in the genepop and delimited file parsers to scan the genotypes of a sample and return the ploidy of the first non-missing locus.  "},{"title":"üü™ phase‚Äã","type":1,"pageTitle":"ioUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/ioutils#-phase","content":"phase(loc::T, type::DataType, digit::Int) where T&lt;:AbstractString phase(loc::Missing, type::DataType, digit::Int) = missing phase(loc::T, type::DataType, digits::T) where T&lt;:Integer  Takes a String of numbers or Integers and returns a typed locus appropriate for PopGen.jl as used in thegenepop and csv file parsers. Use type to specify output type (Int8 or Int16), and digit to specify the number of digits/characters used per allele in a locus. Examples ph_locus = phase(&quot;128114&quot;, Int16, 3) map(i -&gt; phase(i, Int16, 3), [&quot;112131&quot;, &quot;211112&quot;, &quot;001003&quot;, &quot;516500&quot;]) # or # [phase(i, Int8, 2) for i in [&quot;0101&quot;, &quot;0103&quot;, &quot;0202&quot;, &quot;0103&quot;]]   "},{"title":"üü™ unphase‚Äã","type":1,"pageTitle":"ioUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/ioutils#-unphase","content":"unphase(geno::T; digits::Int = 3, ploidy::Int = 2, miss::Int = 0) where T &lt;: Genotype unphase(geno::Missing; digits::Int = 3, ploidy::Int, miss::Int = 0)  Takes a Genotype (e.g. (131, 94)) and returns a string of concatenated alleles padded with n number of zeroes, where n is given by digits = .missing values are returned as either a string of 'digits √ó ploidy' zeroes (miss = 0) or &quot;-9&quot; (miss = -9). The ploidy flag is only relevant for unphasing missing genotypes and not used otherwise. Example unphase((1,2,3,4), digits = 3) &quot;001002003004&quot; unphase(missing, digits = 2, ploidy = 2, miss = -9) &quot;-9&quot; unphase(missing, digits = 2, ploidy = 2, miss = 0) &quot;0000&quot;  "},{"title":"Iterators.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/iterators","content":"","keywords":""},{"title":"PopGenCore.jl/src/Iterators.jl‚Äã","type":1,"pageTitle":"Iterators.jl","url":"/PopGen.jl/docs/api/PopGenCore/iterators#popgencorejlsrciteratorsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ partitionarray‚Äã","type":1,"pageTitle":"Iterators.jl","url":"/PopGen.jl/docs/api/PopGenCore/iterators#-partitionarray","content":"partitionarray(array::AbstractArray, steps::AbstractVector{&lt;:Integer})  Like Base.Iterators.Partition, except you can apply arbitrary sizes to partition the array by. The steps must add up to the total row length of the array. Example julia&gt; partitionarray(rand(20,5), [10,3,4,3]) .|&gt; size [(10, 5), (3, 5), (4, 5), (3, 5)]   "},{"title":"üü™üîµ pairwisepairs‚Äã","type":1,"pageTitle":"Iterators.jl","url":"/PopGen.jl/docs/api/PopGenCore/iterators#-pairwisepairs","content":"pairwisepairs(smp_names::Vector{T}) where T  Given a vector, returns a lazy iterator of tuples of unique all x all combinations of element pairs, excluding self-comparisons. Example julia&gt; colors = [&quot;red_1&quot;, &quot;red_2&quot;, &quot;blue_1&quot;, &quot;blue_2&quot;] ; julia&gt; pairwisepairs(colors) |&gt; collect 6-element Array{Tuple{String,String},1}: (&quot;red_1&quot;, &quot;red_2&quot;) (&quot;red_1&quot;, &quot;blue_1&quot;) (&quot;red_1&quot;, &quot;blue_2&quot;) (&quot;red_2&quot;, &quot;blue_1&quot;) (&quot;red_2&quot;, &quot;blue_2&quot;) (&quot;blue_1&quot;, &quot;blue_2&quot;)   "},{"title":"üü™ simpairs‚Äã","type":1,"pageTitle":"Iterators.jl","url":"/PopGen.jl/docs/api/PopGenCore/iterators#-simpairs","content":"simpairs(data::Vector{String})  Takes a Vector of sample names and returns a Tuple of sample pairs, grouped by simulation number. This is an internal function used for isolating sibship pairs from simulated shipship pairs (via PopGenSims.jl) to perform relatedness estimates only on those pairs.Example julia&gt; a = [&quot;sim1_off1&quot;, &quot;sim1_off2&quot;, &quot;sim2_off1&quot;, &quot;sim2_off2&quot;] ; julia&gt; simpairs(a) (&quot;sim1_off1&quot;, &quot;sim1_off2&quot;) (&quot;sim2_off1&quot;, &quot;sim2_off2&quot;)   "},{"title":"üü™ skipinf‚Äã","type":1,"pageTitle":"Iterators.jl","url":"/PopGen.jl/docs/api/PopGenCore/iterators#-skipinf","content":"skipinf(itr)  Return an iterator over the elements in itr skipping Inf and -Inf values. The returned object can be indexed using indices of itr if the latter is indexable. Indices corresponding to Inf values are not valid: they are skipped by keys and eachindex, and a MissingException is thrown when trying to use them. This is effectively skipmissingfor Inf and -Inf values. Use collect to obtain an Array containing the non-Inf values in itr. Note that even if itr is a multidimensional array, the result will always be a Vector since it is not possible to remove Infs while preserving dimensions of the input.  "},{"title":"üü™ skipnan‚Äã","type":1,"pageTitle":"Iterators.jl","url":"/PopGen.jl/docs/api/PopGenCore/iterators#-skipnan","content":"skipnan(itr)  Return an iterator over the elements in itr skipping NaN values. The returned object can be indexed using indices of itr if the latter is indexable. Indices corresponding to NaN values are not valid: they are skipped by keys and eachindex, and a MissingException is thrown when trying to use them. This is effectively skipmissingfor NaN values. Use collect to obtain an Array containing the non-NaN values in itr. Note that even if itr is a multidimensional array, the result will always be a Vector since it is not possible to remove NaNs while preserving dimensions of the input.  "},{"title":"üü™ skipinfnan‚Äã","type":1,"pageTitle":"Iterators.jl","url":"/PopGen.jl/docs/api/PopGenCore/iterators#-skipinfnan","content":"skipinfnan(itr)  Return an iterator over the elements in itr skipping NaN, Inf and -Inf values. See the docstrings of skipinf and skipnan more details. "},{"title":"MathUtils.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/mathutils","content":"","keywords":""},{"title":"PopGenCore.jl/src/Utils/MathUtils.jl‚Äã","type":1,"pageTitle":"MathUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/mathutils#popgencorejlsrcutilsmathutilsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ countnonzeros‚Äã","type":1,"pageTitle":"MathUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/mathutils#-countnonzeros","content":"countnonzeros(x::AbstractVector{T}) where T&lt;:Real  Return the number of non-zero values in a vector  "},{"title":"üü™ reciprocal‚Äã","type":1,"pageTitle":"MathUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/mathutils#-reciprocal","content":"reciprocal(num::T) where T &lt;: Signed  Returns the reciprocal (1/number) of a number. Will return 0 when the number is 0 instead of returning Inf.  "},{"title":"üü™ reciprocalsum‚Äã","type":1,"pageTitle":"MathUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/mathutils#-reciprocalsum","content":"reciprocalsum(x::AbstractVector{T}) where T&lt;:Real  Return the sum of the reciprocal values of x, skipping the Inf values resulting from divide-by-zero errors. "},{"title":"Manipulate.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/manipulate","content":"","keywords":""},{"title":"PopGenCore.jl/src/Manipulate.jl‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#popgencorejlsrcmanipulatejl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™üîµ sampleinfo!‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-sampleinfo","content":"sampleinfo!(::PopData, metadata::Pair{Symbol, Vector}; categorical::Bool = false) sampleinfo!(::PopData, metadata::Pair{String, Vector}; categorical::Bool = false)  Add an additional sample information to PopData metadata. Mutates PopData in place. Metadata must be in the same order as the samples in sampleinfo(popdata). Arguments‚Äã metadata : A Pair of :ColumnName =&gt; [Values] Keyword Arguments‚Äã categorical : Boolean of whether the metadata being added is categorical aka &quot;factors&quot; (default: false)Example cats = @nancycats sampleinfo!(cats, :whiskerlength =&gt; rand(cats.metadata.samples)) sampleinfo!(cats, &quot;tailcolor&quot; =&gt; rand([&quot;orange&quot;, &quot;brown&quot;], metadata(cats).samples), categorical = true) cats PopData{Diploid, 9 Microsatellite loci} Samples: 237 Populations: 17 Other Info: [&quot;whiskerlength&quot;, &quot;tailcolor&quot;]   "},{"title":"üü™üîµ locusinfo!‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-locusinfo","content":"locusinfo!(::PopData, metadata::Pair{Symbol, Vector}; categorical::Bool = false) locusinfo!(::PopData, metadata::Pair{String, Vector}; categorical::Bool = false)  Add an additional locus information to PopData metadata. Mutates PopData in place. Metadata must be in the same order as the samples in locusinfo(PopData). Arguments‚Äã metadata : A Pair of :ColumnName =&gt; [Values] Keyword Arguments‚Äã categorical : Boolean of whether the metadata being added is categorical aka &quot;factors&quot; (default: false)Example cats = @nancycats locusinfo!(cats, :quality =&gt; rand(metadata(cats).loci)) cats PopData{Diploid, 9 Microsatellite loci} Samples: 237 Populations: 17 Other Info: [&quot;quality&quot;]   "},{"title":"üü™üîµ locationdata!‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-locationdata","content":"locationdata!(data::PopData; longitude::Vector{Float64}, latitude::Vector{Float64})  Replaces existing PopData geographic coordinate data. Takes decimal degrees as a Vector of any AbstractFloat. Formatting requirements‚Äã Decimal Degrees format: -11.431Must use negative sign - instead of cardinal directionsLocation data must be in the order that samples appear in your PopDataMissing data should be coded as missing values of type Missing (can be accomplished with replace!()) Example ncats = @nancycats ; x = rand(237) ; y = rand(237) locationdata!(ncats, longitude = x, latitude = y)   locationdata!(data::PopData; longitude::Vector{String}, latitude::Vector{String})  Replaces existing PopData geographic coordinate data. Takesdecimal minutes or degrees minutes seconds format as a Vector of String. Recommended to use CSV.readfrom CSV.jl to import your spatial coordinates from a text file. Formatting requirements‚Äã Coordinates as a String separated by spaces (&quot;11 43 41&quot;) or colons (&quot;11:43:41&quot;)Must use negative sign (&quot;-11 43.52&quot;) or single-letter cardinal direction (&quot;11 43.52W&quot;)Missing data should be coded as the string &quot;missing&quot; (can be accomplished with replace!())Can mix colons and spaces (although it's bad practice) NOTE‚Äã If you read in the coordinate data as 4 vectors (longitude degrees, longitude minutes, latitude degrees, latitude minutes), then the easiest course of action would be to merge them into two vectors of strings (one for longitude, one for latitude): long_string = string.(lat_deg, &quot; &quot;, lat_min) lat_string = string.(long_deg, &quot; &quot;, long_min)  and use these as inputs into locations! Example ncats = @nancycats; x = fill(&quot;11 22.33W&quot;, 237) ; y = fill(&quot;-41 31.52&quot;, 237) locationdata!(ncats, longitude = x, latitude = y)   locationdata!(data::PopData, longitude::Vector{String}, latitude::Vector{String}) locationdata!(data::PopData; kwargs...)   "},{"title":"üü™üîµ populations!‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-populations","content":"# Replace by matching populations!(data::PopData, rename::Dict) populations!(data::PopData, rename::Vector{String}) populations!(data::PopData, samples::Vector{String}, populations::Vector{String})  Multiple methods to rename or reassign population names to a PopData. Rename using a Dictionary‚Äã Rename existing population ID's of PopData using a Dict ofpopulation_name =&gt; replacement Example potatopops = Dict(&quot;1&quot; =&gt; &quot;Idaho&quot;, &quot;2&quot; =&gt; &quot;Russet&quot;) populations!(potatoes, potatopops)  Rename using a Vector of Strings‚Äã If the number of new names is equal to the number of current unique population names, the method will rename the existing populations in the order with which they appear via unique(). If the number of new population names is equal to the number of samples, the method will instead assign new population names to every sample in the order with which they appear in sampleinfo(popdata). Example # rename (2) existing populations potatopops = [&quot;Idaho&quot;, &quot;Russet&quot;] populations!(potatoes, potatopops) # assign new names to all [44] samples potatopops = repeat([&quot;Idaho&quot;, &quot;Russet&quot;], inner = 22) ; populations!(potatoes, potatopops)  Reassign using samples and new population assignments‚Äã Completely reassign populations for each individual. Takes two vectors of strings as input: one of the sample names, and the other with their new corresponding population name. This can be useful to change population names for only some individuals. Example populations!(potatoes, [&quot;potato_1&quot;, &quot;potato_2&quot;], [&quot;north&quot;, &quot;south&quot;])   "},{"title":"üü™üîµ exclude!‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-exclude","content":"exclude!(data::PopData, kwargs...)  Edit a PopData object in-place by excluding all occurences of the specified information. The keywords can be used in any combination. Synonymous with omit! and remove!. All values are converted to String for filtering, so Symbol and numbers will also work. This can be considered a simpler and more rudimentary syntax for subsetting or filtering PopData. Keyword Arguments‚Äã locus‚Äã A String or Vector{String} of loci you want to remove from the PopData. The keyword loci also works. population‚Äã A String or Vector{String} of populations you want to remove from the PopDataThe keyword populations also works. name‚Äã A String or Vector{String} of samples you want to remove from the PopDataThe keywords names, sample, and samples also work. Examples cats = @nancycats; exclude!(cats, name = &quot;N100&quot;, population = 1:5) exclude!(cats, name = [&quot;N100&quot;, &quot;N102&quot;, &quot;N211&quot;], locus = [&quot;fca8&quot;, &quot;fca23&quot;]) exclude!(cats, name = &quot;N102&quot;, locus = :fca8, population = &quot;3&quot;)  const omit! = exclude! const remove! = exclude!   "},{"title":"üü™üîµ exclude‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-exclude-1","content":"exclude(data::PopData, kwargs...)  Returns a new PopData object excluding all occurrences of the specified keywords. The keywords can be used in any combination. Synonymous with omit and remove. All values are converted to String for filtering, so Symbol and numbers will also work. This can be considered a simpler and more rudimentary syntax for subsetting or filtering PopData. Keyword Arguments‚Äã locus‚Äã A String or Vector{String} of loci you want to remove from the PopData. population‚Äã A String or Vector{String} of populations you want to remove from the PopData. name‚Äã A String or Vector{String} of samples you want to remove from the PopData. Examples cats = @nancycats; exclude(cats, name = &quot;N100&quot;, population = 1:5) exclude(cats, name = [&quot;N100&quot;, &quot;N102&quot;, &quot;N211&quot;], locus = [&quot;fca8&quot;, &quot;fca23&quot;]) exclude(cats, name = &quot;N102&quot;, locus = :fca8, population = &quot;3&quot;)  const omit = exclude const remove = exclude   "},{"title":"üü™üîµ keep!‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-keep","content":"keep!(data::PopData, kwargs...)  Edit a PopData object in-place by keeping only the occurrences of the specified keywords. If using multiple fields, they will be chained together as &quot;or&quot; statements. All values are converted to String for filtering, so Symbol and numbers will also work. This can be considered a simpler and more rudimentary syntax for subsetting or filtering PopData. Keyword Arguments‚Äã locus‚Äã A String or Vector{String} of loci you want to keep in the PopData. population‚Äã A String or Vector{String} of populations you want to keep in the PopData. name‚Äã A String or Vector{String} of samples you want to keep in the PopData. Examples cats = @nancycats; keep!(cats, population = 1:5) # keep 4 populations and 3 specific samples keep!(cats, name = [&quot;N100&quot;, &quot;N102&quot;, &quot;N211&quot;]) # keep 2 loci, 2 populations, and 10 specific individuals keep!(cats, locus = [:fca8, &quot;fca37&quot;], population = [7,8], name = samplenames(cats)[1:10])   "},{"title":"üü™üîµ keep‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-keep-1","content":"keep(data::PopData, kwargs...)  Returns a new PopData object keeping only the occurrences of the specified keyword. Unlike exclude(). only one keyword can be used at a time. All values are converted to String for filtering, so Symbol and numbers will also work. This can be considered a simpler and more rudimentary syntax for subsetting or filtering PopData. Keyword Arguments‚Äã locus‚Äã A String or Vector{String} of loci you want to keep in the PopData. population‚Äã A String or Vector{String} of populations you want to keep in the PopData. name‚Äã A String or Vector{String} of samples you want to keep in the PopData. Examples cats = @nancycats; keep(cats, population = 1:5) # equivalent to cats[cats.genodata.population .‚àà Ref(string.(1:5)), :] keep(cats, name = [&quot;N100&quot;, &quot;N102&quot;, &quot;N211&quot;]) # equivalent to cats[cats.genodata.name .‚àà Ref([&quot;N100&quot;, &quot;N102&quot;, &quot;N211&quot;]), :] keep(cats, locus = [:fca8, &quot;fca37&quot;]) # equivalent to cats[cats.genodata.locus .‚àà Ref([&quot;fca8&quot;, &quot;fca37&quot;]), :]   "},{"title":"üü™üîµ filter‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-filter","content":"filter(data::PopData, args...)  A drop-in replacement for DataFrames.filter where PopData is the first argument and the filtering conditions are the second argument. Returns a new PopData. Note the argument order is opposite of that from DataFrames.jl.Example x = @nancycats ; y = filter(x, :name =&gt; i -&gt; i ‚àà samplenames(x)[1:10]) ; show(x) PopData{Diploid, 9 Microsatellite loci} Samples: 237 Populations: 17 show(y) PopData{Diploid, 9 Microsatellite loci} Samples: 10 Populations: 1   "},{"title":"üü™üîµ filter!‚Äã","type":1,"pageTitle":"Manipulate.jl","url":"/PopGen.jl/docs/api/PopGenCore/manipulate#-filter-1","content":"filter!(data::PopData, args...)  A drop-in replacement for the DataFrames.filter! where PopData is the first argument and the filtering conditions are the second argument. Mutates thePopData in place and returns it. Note the argument order is opposite of that from DataFrames.jl. Example x = @nancycats ; filter!(x, :name =&gt; i -&gt; i ‚àà samplenames(x)[1:10]) ; show(x) PopData{Diploid, 9 Microsatellite loci} Samples: 10 Populations: 1  "},{"title":"MissingUtils.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/missingutils","content":"","keywords":""},{"title":"PopGenCore.jl/src/Utils/MissingUtils.jl‚Äã","type":1,"pageTitle":"MissingUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/missingutils#popgencorejlsrcutilsmissingutilsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ nonmissing‚Äã","type":1,"pageTitle":"MissingUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/missingutils#-nonmissing","content":"nonmissing(vec::T) where T&lt;:AbstractArray  Convenience function to count the number of non-missing values in a vector.  nonmissing(data::PopData, locus::String)  Convenience function to count the number of non-missing samples at a locus.  "},{"title":"üü™ nonmissings‚Äã","type":1,"pageTitle":"MissingUtils.jl","url":"/PopGen.jl/docs/api/PopGenCore/missingutils#-nonmissings","content":"nonmissings(vec1::AbstractVector, vec2::AbstractVector)  Return a vector of indices where neither input vectors have a missing value, i.e. an intersection of the indices of their non-missing elements. "},{"title":"Permutations.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/permutations","content":"","keywords":""},{"title":"PopGenCore.jl/src/Permutations.jl‚Äã","type":1,"pageTitle":"Permutations.jl","url":"/PopGen.jl/docs/api/PopGenCore/permutations#popgencorejlsrcpermutationsjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™ permuteloci!‚Äã","type":1,"pageTitle":"Permutations.jl","url":"/PopGen.jl/docs/api/PopGenCore/permutations#-permuteloci","content":"permuteloci!(data::PopData)  Edits PopData in place with loci permuted across populations within the .genodata dataframe.  "},{"title":"üü™ permutesamples!‚Äã","type":1,"pageTitle":"Permutations.jl","url":"/PopGen.jl/docs/api/PopGenCore/permutations#-permutesamples","content":"permutesamples!(data::PopData; meta::Bool = false)  Edits PopData in place with samples permuted across populations within the .genodata dataframe. Since performance is important for many permutations, the default is to only edit the .genodata table in place; use meta = trueif you also require the .sampleinfo dataframe edited in place.  "},{"title":"üü™ permutegenotypes!‚Äã","type":1,"pageTitle":"Permutations.jl","url":"/PopGen.jl/docs/api/PopGenCore/permutations#-permutegenotypes","content":"permutegenotypes!(data::PopData; by::String = &quot;locus&quot;)  Edits PopData in place with genotypes permuted across individuals within the .genodata dataframe. Use by = &quot;population&quot; (or &quot;pop&quot;) to permute genotypes within populations.  "},{"title":"üü™ permutealleles!‚Äã","type":1,"pageTitle":"Permutations.jl","url":"/PopGen.jl/docs/api/PopGenCore/permutations#-permutealleles","content":"permutealleles!(data::PopData; ploidy::Union{Nothing, Int} = nothing, by::String = &quot;locus&quot;)  Edits PopData in place with alleles permuted and reconstructed into genotypes for each locus within the .genodata dataframe. Use by = &quot;population&quot; (or &quot;pop&quot;) to permute alleles within populations. If ploidy is not provided (default ploidy = nothing), then ploidy will be identified from the PopData. If performance is important, it would be best to identify ploidy in advance and set it to a specific integer. "},{"title":"üü™ strictshuffle‚Äã","type":1,"pageTitle":"Permutations.jl","url":"/PopGen.jl/docs/api/PopGenCore/permutations#-strictshuffle","content":"strictshuffle(x::T) where T &lt;: AbstractArray  Shuffle only the non-missing values of a Vector and return a copy of the vector, keeping the missing values at their original locations. Use strictshuffle! to edit in-place instead of returning a copy.  "},{"title":"üü™ strictshuffle!‚Äã","type":1,"pageTitle":"Permutations.jl","url":"/PopGen.jl/docs/api/PopGenCore/permutations#-strictshuffle-1","content":"strictshuffle!(x::T) where T &lt;: AbstractArray  Shuffle only the non-missing values of a Vector, keeping themissing values at their original locations. Use strictshuffleto return a copy instead of editing in-place. "},{"title":"Plink.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/plink","content":"","keywords":""},{"title":"PopGenCore.jl/src/io/Plink.jl‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#popgencorejlsrcioplinkjl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üì¶ _plinkindex‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#-_plinkindex","content":"_plinkindex(s::Matrix{UInt8}, i::Integer, j::Integer) _plinkindex(s::Matrix{UInt8})  Tthis function copies the getindex tool OpenMendel/SnpArrays.jl uses to pull out the byte values from the compressed hex genotypes Repo: https://github.com/OpenMendel/SnpArrays.jl  "},{"title":"üì¶ _SNP‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#-_snp","content":"_SNP(genotype::UInt8) _SNP(genomatrix::AbstractArray{UInt8})  00 Homozygous for first allele (0x00)01 Missing genotype (0x01)10 Heterozygous (0x02)11 Homozygous for second allele in .bim file (0x03)  "},{"title":"üì¶ _plinkped‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#-_plinkped","content":"_plinkped(infile::String, keepfields::Union{Symbol,Vector{Symbol}} = :all, silent::Bool = false)   "},{"title":"üì¶ _plinkbed‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#-_plinkbed","content":"_plinkbed(infile::String, famfields::Union{Symbol,Vector{Symbol}} = :all, bimfields::Union{Symbol,Vector{Symbol}} = :all, silent::Bool = false)   "},{"title":"üì¶ _genoconversion‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#-_genoconversion","content":"_genoconversion(genotype::T) where T&lt;:Genotype = join(genotype, &quot; &quot;) _genoconversion(genotype::Missing) = &quot;0 0&quot;   "},{"title":"üü™üîµ plink‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#-plink","content":"plink(infile::String; famfields::Union{Symbol,Vector{Symbol}} = :all, bimfields::Union{Symbol,Vector{Symbol}} = :all, silent::Bool = false)  Read a PLINK .ped or binary .bed file into memory as a PopData object. Requires an accompanying .fam file in the same directory, but an accompanying .bim file is optional. infile::String : path to .ped or .bed file "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#keyword-arguments","content":"famfields::Symbol|Vector{Symbol} : which additional fields to import from the .fam file :all [default]:noneany one or combination of [:sire, :dam, :sex, :phenotype] bimfields::Symbol|Vector{Symbol} : which additional fields to import from the optional .bim file :all [default]:noneany one or combination of [:chromosome, :cm, :bp] silent::Bool : whether to print file information during import (default: false) "},{"title":"Example‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#example","content":"parakeet = plink(&quot;datadir/parakeet.ped&quot;, famfields = :sex) parrot = plink(&quot;datadir/parrot.bed&quot;, famfields = [:sire, :dam], bimfields = :chromosome)   plink(data::PopData; filename::String)  Write a biallelic PopData object to PLINK .ped format with an accompanying.fam file. Genotypes are coded by the PLINK standard: Integers are the alleles0 encodes missingAfter column 6, every two numbers indicate a diploid genotype. "},{"title":"Example‚Äã","type":1,"pageTitle":"Plink.jl","url":"/PopGen.jl/docs/api/PopGenCore/plink#example-1","content":"sharks = dropmultiallelic(@gulfsharks) ; plink(sharks, filename = &quot;biallelic_sharks.ped&quot;)  "},{"title":"PopDataWrappers.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers","content":"","keywords":""},{"title":"üü™üîµ info‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-info","content":"info(::PopData)  Display the metadata (PopDataInfo) of a PopData object.  "},{"title":"üü™üîµ metadata‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-metadata","content":"metadata(::PopData)  Display the metadata (PopDataInfo) of a PopData object.  "},{"title":"üü™üîµ sampleinfo‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-sampleinfo","content":"sampleinfo(::PopData)  Show the sample information found within the metadata of a PopData object. Returns a view of a dataframe  "},{"title":"üü™üîµ genodata‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-genodata","content":"genodata(::PopData)  Method to show the genotype information of a PopData object. Returns a view of a dataframe.  "},{"title":"üü™üîµ locusinfo‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-locusinfo","content":"locusinfo(::PopData)  Show the locus information found within the metadata of a PopData object. Returns a view of a dataframe  "},{"title":"üü™üîµ locationdata‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-locationdata","content":"locationdata(data::PopData)  View the longitude and latitude data in a PopData object. Returns a table derived from the PopData. Changes made to this table will not alter the sourcePopData object. Use locations! to add spatial data to a PopData object.  "},{"title":"üü™üîµ loci‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-loci","content":"loci(data::PopData)  Returns an array of strings of the loci names in a PopData object.  "},{"title":"üü™üîµ samplenames‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-samplenames","content":"samplenames(data::PopData)  View individual/sample names in a PopData  "},{"title":"üü™üîµ genotypes‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-genotypes","content":"genotypes(data::PopData, samplelocus::String)  Return a vector of all the genotypes of a sample (or locus) in a PopData object. cats = @nancycats genotypes(cats, &quot;N115&quot;) genotypes(cats, &quot;fca8&quot;)   genotypes(data::PopData, samplelocus::Pair{String, String}) ::DataFrame genotypes(data::PopData, samplelocus::Pair{Vector{String}, String}) ::DataFrame genotypes(data::PopData, samplelocus::Pair{String, Vector{String}}) ::DataFrame  Return a genotype or dataframe of genotypes for one or more samples/loci in a PopData object. Uses the Pair notation of samples =&gt; loci. Examples cats = @nancycats; genotypes(cats, &quot;N115&quot; =&gt; &quot;fca8&quot;) genotypes(cats, [&quot;N115&quot;, &quot;N7&quot;] =&gt; &quot;fca8&quot;) genotypes(cats, &quot;N115&quot; =&gt; [&quot;fca8&quot;, &quot;fca37&quot;]) genotypes(cats, [&quot;N1&quot;, &quot;N2&quot;] =&gt; [&quot;fca8&quot;, &quot;fca37&quot;])   "},{"title":"üü™üîµ populations‚Äã","type":1,"pageTitle":"PopDataWrappers.jl","url":"/PopGen.jl/docs/api/PopGenCore/popdatawrappers#-populations","content":"populations(data::PopData; counts::Bool = false)  View unique population ID's and/or their counts in PopData. counts returns a dataframe of samples per population instead (default = false) "},{"title":"ReadWrite.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/read","content":"","keywords":""},{"title":"PopGenCore.jl/src/io/ReadWrite.jl‚Äã","type":1,"pageTitle":"ReadWrite.jl","url":"/PopGen.jl/docs/api/PopGenCore/read#popgencorejlsrcioreadwritejl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üì¶ read‚Äã","type":1,"pageTitle":"ReadWrite.jl","url":"/PopGen.jl/docs/api/PopGenCore/read#-read","content":"PopGen.read(infile::String; kwargs...)  Wraps the individual file importers to read a file in as a PopData object. File type is inferred from the file extension (case insensitive): File Format\tExtensions\tDocstringdelimited\t.csv, .txt, .tsv\t?delimited genepop\t.gen, .genepop\t?genepop structure\t.str, .structure\t?structure plink\t.bed, .ped\t?plink variant call format (vcf)\t.vcf, .vcf.gz\t?vcf variant call format (bcf)\t.bcf, .bcf.gz\t?bcf This function uses the same keyword arguments (and defaults) as the file importing functions it wraps; please see their respective docstrings in the Julia help console. for specific usage details (e.g. ?genepop). Examples PopGen.read(&quot;cavernous_assfish.gen&quot;, digits = 3) PopGen.read(&quot;juglans_nigra.vcf&quot;)   "},{"title":"üì¶ write‚Äã","type":1,"pageTitle":"ReadWrite.jl","url":"/PopGen.jl/docs/api/PopGenCore/read#-write","content":"PopGen.write(data::PopData, filename::String, kwargs...) PopGen.write(data::PopData; filename::String, kwargs...)  Writes PopData to a specified file type inferred from the extension of filename = (case insensitive). Additional keyword arguments kwargs... are specific to the intended file type, and are listed in the docstrings of the specific file writer with the format ?filetype. For example, to find the appropriate keywords for a conversion to Genepop format, call up the ?genepop docstring. File Format\tExtensions\tDocstringgenepop\t.gen, .genepop\t?genepop delimited\t.csv, .txt, .tsv\t?delimited structure\t.str, .structure\t?structure Example cats = @nancycats; fewer_cats = omit(cats, name = samplenames(cats)[1:10]); PopGen.write(fewer_cats, filename = &quot;filtered_nancycats.gen&quot;, digits = 3, format = &quot;h&quot;)  "},{"title":"Structure.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/structure","content":"","keywords":""},{"title":"PopGenCore.jl/src/io/Structure.jl‚Äã","type":1,"pageTitle":"Structure.jl","url":"/PopGen.jl/docs/api/PopGenCore/structure#popgencorejlsrciostructurejl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üì¶ phase_structure‚Äã","type":1,"pageTitle":"Structure.jl","url":"/PopGen.jl/docs/api/PopGenCore/structure#-phase_structure","content":"phase_structure(datatype::DataType, args...)  Takes a DataType (such as Int8) and a series of integers to return a sorted Tuple of those integers converted to that DataType. i.e. takes a series of alleles and returns a genotype. Returns missing if args aremissing. Used internally in PopGen.structure file reader. Example‚Äã phase_structure(Int8, 1,2,3,4,3,4,6,1) (1, 1, 2, 3, 3, 4, 4, 6) phase_structure(Int16, missing, missing) missing   "},{"title":"üü™ structure‚Äã","type":1,"pageTitle":"Structure.jl","url":"/PopGen.jl/docs/api/PopGenCore/structure#-structure","content":"structure(infile::String; kwargs...)  Load a Structure format file into memory as a PopData object. infile::String : path to Structure file Keyword Arguments‚Äã extracols::Integer: how many additional optional columns there are beyond Stucture's POPDATA the reader needs to ignore (default: 0) these include POPFLAG, LOCDATA, or anything else you might have added extrarows::Integer : how many additional optional rows there are beyond the first row of locus names (default: 0)missingval::String : the value used to identify missing values in the data (default: &quot;-9&quot;)silent::Bool : whether to print file information during import (default: false)allow_monomorphic::Bool : whether to keep monomorphic loci in the dataset (default: false)faststructure::Bool: whether the file is fastStructure format (default: false) File must follow this Structure format:‚Äã the file is tab or space delimited but not bothfirst row is locus names separated by the delimiter leading/trailing whitespaces are toleratedoptional rows allowed after the locus names number of rows per sample = ploidy e.g. if diploid, that sample would have 2 rowsmulti-column variant not supported first data column is sample namesecond data column is population ID optional columns allowed after the population ID (2nd) column remaining columns are the genotype for that individual for that locus Structure file example:‚Äã locus_1 locus_2 locus_3 locus_4 locus_5 walnut_01 1 -9 145 66 0 92 walnut_01 1 -9 -9 64 0 94 walnut_02 1 106 142 68 1 92 walnut_02 1 106 148 64 0 94 walnut_03 2 110 145 -9 0 92 walnut_03 2 110 148 66 1 -9  fastStructure file format:‚Äã the file is tab or space delimited but not bothno first row of loci namesnumber of rows per sample = ploidy e.g. if diploid, that sample would have 2 rows first data column is sample namesecond data column is population IDremaining columns are the genotype for that individual for that locususually, first 6 colums are empty (but not necessary)no extra rows or columns. fastStructure file example:‚Äã chestnut_01 1 -9 145 66 0 92 chestnut_01 1 -9 -9 64 0 94 chestnut_02 1 106 142 68 1 92 chestnut_02 1 106 148 64 0 94 chestnut_03 2 110 145 -9 0 92 chestnut_03 2 110 148 66 1 -9  Example walnuts = structure(&quot;juglans_nigra.str&quot;, extracols = 0, extrarows = 0)   structure(data::PopData; filename::String, faststructure::Bool, delim::String)  Write a PopData object to a Stucture format file data: the PopData object you wish to convert to a Structure file keyword arguments‚Äã filename: a String of the output filenamedelim : a String of either &quot;tab&quot; or &quot;space&quot; indicating the delimiter (default: &quot;tab&quot;)faststructure: true/false of whether the output should be formatted for fastStructure (default: false) Example cats = @nancycats; fewer_cats = omit(cats, name = samplenames(cats)[1:10]); structure(fewer_cats, filename = &quot;filtered_nancycats.str&quot;, faststructure = true)  "},{"title":"PopData.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/types","content":"","keywords":""},{"title":"PopGenCore.jl/src/PopData.jl‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#popgencorejlsrcpopdatajl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üü™üîµ PopObj‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-popobj","content":"PopObj::AbstractType  Generic AbstractType for use in PopGen.jl  "},{"title":"üü™üîµ PopDataInfo‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-popdatainfo","content":"mutable struct PopDataInfo samples::Int64 sampeinfo::DataFrame loci::Int64 locusinfo::DataFrame populations::Int64 ploidy::Union{Int8, Vector{Int8}} biallelic::Bool end  The data struct used internally as PopData.metadata fields to store basic information about the PopData for easy access. PopDataInfo(genodf::DataFrame)  constructor format using just the genodata dataframe  "},{"title":"üü™üîµ PopData‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-popdata","content":"PopData metadata::PopDataInfo genodata::DataFrame  The data struct used for the PopGen population genetics ecosystem. You arestrongly discouraged from manually creating tables to pass into a PopData, and instead should use the provided file importers and utilities. - `metadata` PopDataInfo of data information - `samples` - the number of samples in the data - `sampleinfo` - DataFrame of sample names,populations, ploidy, etc. - `loci` - the number of loci in the data - `locusinfo` - DataFrame of locus names, chromosome, physical position, etc. - `populations` - the number of populations in the data - `ploidy` - the ploidy (or ploidies) present in the data - `biallelic` - if all the markers are biallelic - `genodata` DataFrame of sample genotype records - `name` - the individual/sample names [`PooledArray`] - `population` - population names [`PooledArray`] - `locus` - locus names [`PooledArray`] - `genotype` - genotype values [`NTuple{N,Signed}`]  PopData(data::DataFrame)Contructor using just a genodata dataframe.  "},{"title":"üü™üîµ PopDataInfo!‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-popdatainfo-1","content":"PopDataInfo!(data::PopData)  This method is used to update PopDataInfo from PopData, all in one swoop PopDataInfo!(popdatainfo::PopDataInfo, genodata::DataFrame)  Method to update preexisting PopDataInfo with new genodata, useful for getindex and creating new PopData from that  "},{"title":"üü™üîµ Genotype‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-genotype","content":"Genotype::DataType  For convenience purposes, an alias for NTuple{N, &lt;:Signed} where N, which is the type describing individual genotypes in PopData. Specifically, there existSNP as an alias for NTuple{N, Int8} and MSat for NTuple{N, Int16}  "},{"title":"üü™üîµ SNP‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-snp","content":"SNP::DataType  An alias for NTuple{N, Int8}  "},{"title":"üì¶ _SNP‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-_snp","content":"SNP(geno)  Contstructor for SNP  "},{"title":"üü™üîµ MSat‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-msat","content":"MSat::DataType  An alias for NTuple{N, Int16}  "},{"title":"üì¶ _MSat‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-_msat","content":"_MSat(geno)  Constructor for MSat  "},{"title":"üü™üîµ GenoArray‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-genoarray","content":"GenoArray::DataType  An alias for an AbstractVector of elements Missingand Genotype, which itself is of type NTuple{N, &lt;:Integer} where N. The definition as an AbstractVector adds flexibility for SubArraycases.  "},{"title":"üì¶ _ploidy2text‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-_ploidy2text","content":"_ploidy2text(ploidy::Int8) _ploidy2text(ploidy::Vector{Int8})   "},{"title":"üü™üîµ Base.show‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-baseshow","content":"Base.show(io::IO, data::PopData) Base.show(io::IO, data::PopDataInfo)   "},{"title":"üü™üîµ Base.getindex‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-basegetindex","content":"Base.getindex(data::PopData, idx::Symbol) Base.getindex(data::PopData, args) Base.getindex(data::PopData, expression, cols)   "},{"title":"üü™üîµ Base.getproperty‚Äã","type":1,"pageTitle":"PopData.jl","url":"/PopGen.jl/docs/api/PopGenCore/types#-basegetproperty","content":"getproperty(data::PopData, field::Symbol)  A convenience method to access certain elements in a PopData with fewer keystrokes. Essentially a standard getproperty call, except sampleinfo accesses metadata.sampleinfo,locusinfo accesses metadata.locusinfo, and info is an alias for metadata. Example cats = @nancycats ; cats.metadata == cats.info cats.metadata.sampleinfo == cats.sampleinfo cats.metadata.locusinfo == cats.locusinfo  "},{"title":"VariantCall.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenCore/variantcall","content":"","keywords":""},{"title":"PopGenCore.jl/src/io/VariantCall.jl‚Äã","type":1,"pageTitle":"VariantCall.jl","url":"/PopGen.jl/docs/api/PopGenCore/variantcall#popgencorejlsrciovariantcalljl","content":"üì¶ not exported\tüü™ exported by PopGenCore.jl\tüîµ exported by PopGen.jl "},{"title":"üì¶ openvcf‚Äã","type":1,"pageTitle":"VariantCall.jl","url":"/PopGen.jl/docs/api/PopGenCore/variantcall#--openvcf","content":"openvcf(::String)  Open VCF file (.vcf(.gz) or .bcf(.gz)) and return an IO stream in reading mode &quot;r&quot;.  "},{"title":"üü™ bcf‚Äã","type":1,"pageTitle":"VariantCall.jl","url":"/PopGen.jl/docs/api/PopGenCore/variantcall#-bcf","content":"bcf(infile::String; ; rename_loci::Bool, silent::Bool, allow_monomorphic::Bool)  Load a BCF file into memory as a PopData object. Population information needs to be provided separately. infile : path to BCF file (can be gzipped) Keyword Arguments rename_loci : true/false of whether to simplify loci names to &quot;snp_#&quot; (default: false)allow_monomorphic : true/false of whether to keep monomorphic loci (default: false)silent: true/false of whether to print extra file information (default: false). Alleles are recoded according to the following schema: Base\tA\tT\tC\tGAllele\t1\t2\t3\t4 Mixed-ploidy data‚Äã If importing mixed-ploidy data (such as poolseq), you will need to perform an additional step to convert the genotype column into the correct GenoArray type: julia&gt; mydata = bcf(&quot;path/to/file.bcf&quot;, silent = true, rename_loci = true) ; julia&gt; mydata.genodata.genotype = mydata.genodata.genotype |&gt; Array{Union{Missing, NTuple}}   "},{"title":"üü™ vcf‚Äã","type":1,"pageTitle":"VariantCall.jl","url":"/PopGen.jl/docs/api/PopGenCore/variantcall#-vcf","content":"vcf(infile::String; ; rename_loci::Bool, silent::Bool, allow_monomorphic::Bool)  Load a VCF file into memory as a PopData object. Population information needs to be provided separately. infile : path to VCF file (can be gzipped) Keyword Arguments rename_loci : true/false of whether to simplify loci names to &quot;snp_#&quot; (default: false)allow_monomorphic : true/false of whether to keep monomorphic loci (default: false)silent: true/false of whether to print extra file information (default: false). Alleles are recoded according to the following schema: Base\tA\tT\tC\tGAllele\t1\t2\t3\t4 Mixed-ploidy data‚Äã If importing mixed-ploidy data (such as poolseq), you will need to perform an additional step to convert the genotype column into the correct GenoArray type: julia&gt; mydata = vcf(&quot;path/to/file.vcf&quot;, silent = true, rename_loci = true) ; julia&gt; mydata.genodata.genotype = mydata.genodata.genotype |&gt; Array{Union{Missing, NTuple}}  "},{"title":"Cross.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_cross","content":"","keywords":""},{"title":"PopGenSims.jl/src/Cross.jl‚Äã","type":1,"pageTitle":"Cross.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_cross#popgensimsjlsrccrossjl","content":"üì¶ not exported\tüü™ exported by PopGenSims.jl "},{"title":"üì¶ sample_genotype‚Äã","type":1,"pageTitle":"Cross.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_cross#-sample_genotype","content":"sample_genotype(geno::T, n_alleles::Int) where T&lt;:Genotype  sample_genotype(geno::Missing, n_alleles::Int)   "},{"title":"üì¶ haploid_cross!`‚Äã","type":1,"pageTitle":"Cross.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_cross#-haploid_cross","content":"haploid_cross!(data::DataFrame, p1::T, p2::T; n::Int) where T &lt;: GenoArray   "},{"title":"üì¶ polyploid_cross!‚Äã","type":1,"pageTitle":"Cross.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_cross#-polyploid_cross","content":"polyploid_cross!(data::DataFrame, p1::T, p2::T; n::Int, ploidy::Int) where T &lt;: GenoArray   "},{"title":"üü™ cross‚Äã","type":1,"pageTitle":"Cross.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_cross#-cross","content":"cross(data::PopData, parent1::String, parent2::String; n::Int = 100, generation::String = &quot;F1&quot;)  Simulate a breeding cross between individuals parent1 and parent2 from a PopData object. Returns PopData consisting of n offspring resulting from the cross. Keyword Arguments‚Äã n : Integer of number of offspring to generate (default: 100)generation : A string to assign population identity to the offspring (default: &quot;F1&quot;) cross(parent_1::Pair, parent_2::Pair, n::Int = 100, generation::String = &quot;F1&quot;)  Simulate a breeding cross between individuals parent and parent2 from two different PopData objects. Returns PopData consisting of n offspring resulting from the cross. parent_1_data and parent_2_dataare positional arguments, therefore they must be written without keywords and in the order of parents 1, parent 2. Keyword Arguments‚Äã parent_1 : Pair of PopData =&gt; &quot;Parent1Name&quot;parent_2 : Pair of PopData =&gt; &quot;Parent1Name&quot;n : Integer of number of offspring to generate (default: 100)generation : A string to assign population identity to the offspring (default: &quot;F1&quot;) "},{"title":"Sibship.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship","content":"","keywords":""},{"title":"PopGenSims.jl/src/Sibship.jl‚Äã","type":1,"pageTitle":"Sibship.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship#popgensimsjlsrcsibshipjl","content":"üì¶ not exported\tüü™ exported by PopGenSims.jl "},{"title":"üì¶ _cross‚Äã","type":1,"pageTitle":"Sibship.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship#-_cross","content":"_cross(parent1::Vector{Vector{T}}, parent2::Vector{Vector{T}}) where T &lt;: Signed  Simulate a mating cross between two parents, generating one offspring with the same ploidy as parent1. This variant of cross is used internally for simulatekin.  "},{"title":"üì¶ _parentoffspring‚Äã","type":1,"pageTitle":"Sibship.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship#-_parentoffspring","content":"parentoffspring(data::PopData; n::Int, ploidy::Int)   "},{"title":"üì¶ fullsib‚Äã","type":1,"pageTitle":"Sibship.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship#-fullsib","content":"fullsib(data::PopData; n::Int, ploidy::Int)   "},{"title":"üì¶ halfsib‚Äã","type":1,"pageTitle":"Sibship.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship#-halfsib","content":"halfsib(data::PopData; n::Int, ploidy::Int)   "},{"title":"üì¶ unrelated‚Äã","type":1,"pageTitle":"Sibship.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship#-unrelated","content":"unrelated(data::PopData; n::Int, ploidy::Int)   "},{"title":"üü™ simulatekin‚Äã","type":1,"pageTitle":"Sibship.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_sibship#-simulatekin","content":"simulatekin(data::PopData; fullsib::Int, halfsib::Int, unrelated::Int, parentoffspring::Int, ploidy::Signed)  Simulate mating crosses to generate sample pairs with any combination of the specified relationships, returning a PopData object. The simulations will first generate parents of a givenploidy (inferred or specified) by drawing alleles from a global allele pool derived from the given data (i.e. weighted by their frequencies). Relationship‚Äã Simulated parents will be crossed to generate offspring depending on the relationship: fullsib : 2 parents generate 2 full-sibling offspring, return 2 offspringhalfsib : 3 parents generate 2 half-sibling offspring, returns 2 offspringunrelated : returns 2 randomly generated individuals from the global allele poolsparentoffspring : 2 parents generate 1 offspring, returns 1 offspring and 1 parent Identifying pairs The relationship between the newly generated samples can be identified by: Sample names will specify their simulation number, relationship, and whether parent or offspring Naming convention: [simulation #][relationship][offspring #]example: sim005fullsib_1 = [simulation 005][full sibling]_[offspring 1] Their population name will be that of their relationship (e.g. &quot;fullsib&quot;) Ploidy If the samples in your PopData are of a single ploidy, then ploidy = 0 (the default) will infer the ploidy and generate parents and offspring according to the ploidy of your data. If you have mixed-ploidy data or wish to generate parents and offspring of a ploidy different than the source PopData you can specify the ploidy with which to simulate parents and offspring. For example, if your PopData is diploid, but you wish to generate triploid or octoploid parents and offspring, you would specify ploidy = 3 or ploidy = 8 repectively. Odd ploidy If trying to create offspring with an odd ploidy (3,5, etc.), each parent has a 50% chance of contributing (¬Ω √ó ploidy) + 1 alleles for all loci to the offspring. In other words, if ploidy = 3, there's a 50% chance parent_1 will give 2 alleles for every locus for that simulated cross. Example julia&gt; cats = @nanycats ; julia&gt; cat_sims = simulatekin(cats, fullsib = 10, halfsib = 50) PopData{Diploid, 9 Microsatellite loci} Samples: 120 Populations: 2 julia&gt; cat_sims.sampleinfo 120√ó3 DataFrame Row ‚îÇ name population ploidy ‚îÇ String String Int64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ sim01_fullsib_1 fullsib 2 2 ‚îÇ sim01_fullsib_2 fullsib 2 3 ‚îÇ sim02_fullsib_1 fullsib 2 4 ‚îÇ sim02_fullsib_2 fullsib 2 5 ‚îÇ sim03_fullsib_1 fullsib 2 6 ‚îÇ sim03_fullsib_2 fullsib 2 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ 115 ‚îÇ sim48_halfsib_1 halfsib 2 116 ‚îÇ sim48_halfsib_2 halfsib 2 117 ‚îÇ sim49_halfsib_1 halfsib 2 118 ‚îÇ sim49_halfsib_2 halfsib 2 119 ‚îÇ sim50_halfsib_1 halfsib 2 120 ‚îÇ sim50_halfsib_2 halfsib 2 108 rows omitted  "},{"title":"Samples.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_samples","content":"","keywords":""},{"title":"PopGenSims.jl/src/Samples.jl‚Äã","type":1,"pageTitle":"Samples.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_samples#popgensimsjlsrcsamplesjl","content":"üì¶ not exported\tüü™ exported by PopGenSims.jl "},{"title":"üì¶ sample_locus‚Äã","type":1,"pageTitle":"Samples.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_samples#-sample_locus","content":"sample_locus(locus::Dict, n::Int, ploidy::Signed)  Internal function used by simulate to take a Dict of alleles =&gt; frequencies of a locus and returnn number of genotypes (n_alleles = ploidy) by using weighted sampling of the allele-frequency pairs. Example d = Dict(133 =&gt; 0.125,135 =&gt; 0.5625,143 =&gt; 0.25,137 =&gt; 0.0625) julia&gt; sample_locus(d, 3, 2) 5-element Array{Tuple{Int16,Int16},1}: (133, 135) (135, 135) (143, 137) julia&gt; sample_locus(d, 3, 3) 5-element Array{Tuple{Int16,Int16,Int16},1}: (135, 135, 133) (143, 135, 133) (137, 135, 135)   "},{"title":"üì¶ _simulatearbitrary‚Äã","type":1,"pageTitle":"Samples.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_samples#-_simulatearbitrary","content":"_simulatearbitrary(data::PopData, n::Dict{String, Int})   "},{"title":"üì¶ _simulateflat‚Äã","type":1,"pageTitle":"Samples.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_samples#-_simulateflat","content":"_simulateflat(data::PopData, n::Int)   "},{"title":"üì¶ _simulatescale‚Äã","type":1,"pageTitle":"Samples.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_samples#-_simulatescale","content":"_simulatescale(data::PopData, scale::Int)   "},{"title":"üü™ simulate‚Äã","type":1,"pageTitle":"Samples.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_samples#-simulate","content":"simulate(data::PopData; n::Int)  Simulate n number of individuals per population using per-population allele frequencies derived from a PopData object. Returns a new PopData object with n * n_populations samples. Example julia&gt; cats = @nanycats; julia&gt; sims = simulate(cats, n = 100) PopData{Diploid, 9 Microsatellite Loci} Samples: 1700 Populations: 17   simulate(data::PopData; n::Dict{String, Int})  Simulate an arbitrary number of samples per populations specified in the Dict n, given by Population =&gt; #samples. Uses per-population allele frequencies derived from a PopData object. julia&gt; cats = @nancycats; julia&gt; simscheme = Dict(&quot;1&quot; =&gt; 5, &quot;8&quot; =&gt; 3, &quot;11&quot; =&gt; 20) ; julia&gt; simulate(cats, n = simscheme) PopData{Diploid, 9 Microsatellite loci} Samples: 28 Populations: 3   simulate(data::PopData; scale::Int)  Simulate individuals per population in the same proportions they appear in the PopData using per-population allele frequencies. Simulation volume can be multiplied using scale, i.e. if you want to keep the same proportions but generate twice the number of samples, scalewould be 2. Returns a new PopData object with n_samples * scale samples. julia&gt; cats = @nanycats; julia&gt; sims_prop = simulate(cats, scale = 3) PopData{Diploid, 9 Microsatellite Loci} Samples: 711 Populations: 17  "},{"title":"Utils.jl","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_utils","content":"","keywords":""},{"title":"PopGenSims.jl/src/Utils.jl‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_utils#popgensimsjlsrcutilsjl","content":"üì¶ not exported\tüü™ exported by PopGenSims.jl "},{"title":"üü™ append!‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_utils#-append","content":"append!(data::PopData, data2::PopData)  Add the rows of data2 to the end of data. This will add the samples present in the second PopData object to the first PopData object (mutating it).Note that this is a simple appending, and you risk corrupting your PopData if the two PopData objects do not have identical loci. Example julia&gt; cats = @nancycats PopData{Diploid, 9 Microsatellite Loci} Samples: 237 Populations: 17 julia&gt; purrfect_pairs = cross(cats, &quot;N200&quot;, &quot;N7&quot;, generation = &quot;F1&quot;) PopData{Diploid, 9 Microsatellite Loci} Samples: 100 Populations: 1 julia&gt; append!(cats, purrfect_pairs); julia&gt; cats PopData{Diploid, 9 Microsatellite Loci} Samples: 337 Populations: 18   "},{"title":"üü™ append‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_utils#-append-1","content":"append(data::PopData, data2::PopData)  Add the rows of data2 to the end of data. This will combine the samples present in both PopData objects and return a new PopData object. Note that this is a simple appending, and you risk corrupting your PopData if the two PopDataobjects do not have identical loci. Example julia&gt; cats = @nanycats PopData{Diploid, 9 Microsatellite Loci} Samples: 237 Populations: 17 julia&gt; purrfect_pairs = cross(cats, &quot;N200&quot;, &quot;N7&quot;, generation = &quot;F1&quot;) PopData{Diploid, 9 Microsatellite Loci} Samples: 100 Populations: 1 julia&gt; merged_cats = append(cats, purrfect_pairs) PopData{Diploid, 9 Microsatellite Loci} Samples: 337 Populations: 18  "},{"title":"üì¶ allele_pool‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_utils#-allele_pool","content":"allele_pool(locus::T) where T &lt;: GenoArray allele_pool(data::PopData)   "},{"title":"üì¶ simulate_sample‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_utils#-simulate_sample","content":"simulate_sample(alleles::Dict{String,NTuple}, loc::Vector{String}; ploidy::Int)  Using a global allele pool given by a Dict{loci,alleles} and a list of loci (loc), simulate an individual with a given ploidy. Returns a Vector of genotypes. Example julia&gt; cats = @nancycats ; julia&gt; loc, alleles = allele_pool(cats) ; julia&gt; simulate_sample(alleles, loc, ploidy = 2) 9-element Array{Array{Int16,1},1}: [139, 129] [146, 146] [145, 141] [126, 126] [150, 148] [148, 140] [185, 199] [91, 113] [208, 208]  "},{"title":"üì¶ feature_req‚Äã","type":1,"pageTitle":"Utils.jl","url":"/PopGen.jl/docs/api/PopGenSims/popgensims_utils#-feature_req","content":"feature_req  Returns the text: &quot;Please open an Issue or Pull Request on https://www.github.com/pdimens/PopGenSims.jl if you would like this feature implemented&quot; "},{"title":"About","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/gettingstarted/about","content":"","keywords":""},{"title":"Goal‚Äã","type":1,"pageTitle":"About","url":"/PopGen.jl/docs/gettingstarted/about#goal","content":"To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility. SanitySensibilityAccessibility Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. The first argument for all functions is the input data without keywords. Always. If a function has a very obvious name, then it likely it won't need keyword arguments. "},{"title":"Why Julia (and not Python or R)?‚Äã","type":1,"pageTitle":"About","url":"/PopGen.jl/docs/gettingstarted/about#why-julia-and-not-python-or-r","content":""},{"title":"Speed and syntax‚Äã","type":1,"pageTitle":"About","url":"/PopGen.jl/docs/gettingstarted/about#speed-and-syntax","content":"The speed can be comparable to C when coded using best practices. Also, has Python-like syntax with optional tabs. Not convinced? Check out our comparison benchmarks. We are also fans of 1-indexing, but that's more of a perk. "},{"title":"A modern language for modern problems‚Äã","type":1,"pageTitle":"About","url":"/PopGen.jl/docs/gettingstarted/about#a-modern-language-for-modern-problems","content":"Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future work). "},{"title":"Community & contribution‚Äã","type":1,"pageTitle":"About","url":"/PopGen.jl/docs/gettingstarted/about#community--contribution","content":"Julia's internals attempt to solve what's known as the &quot;two language problem&quot;. That is, languages that are easy to write in (like Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (like C, C++, Fortran). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because things work and they are easy to use. But, it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are kind of helpless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! So, if we write everything in Julia, and you use everything in Julia, users can themselves diagnose these things if they so choose. We want the community to have the power to make sure that all the math and logic checks out. This means anyone can contribute to the overall health and accuracy of this package. Yes, that means that we might be getting more Issues opened up (ugh), but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA using PopData? Send us a pull request (please!)! Or join the Slack group! "},{"title":"Package manager‚Äã","type":1,"pageTitle":"About","url":"/PopGen.jl/docs/gettingstarted/about#package-manager","content":"It's just such a delight to use. Installing PopGen.jl should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia. "},{"title":"Style Guide","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/doc1","content":"","keywords":""},{"title":"Markdown Syntax‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#markdown-syntax","content":"To serve as an example page when styling markdown based Docusaurus sites. "},{"title":"Headers‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#headers","content":"H1 - Create the best documentation "},{"title":"H2 - Create the best documentation‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#h2---create-the-best-documentation","content":""},{"title":"H3 - Create the best documentation‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#h3---create-the-best-documentation","content":"H4 - Create the best documentation‚Äã H5 - Create the best documentation‚Äã H6 - Create the best documentation‚Äã  "},{"title":"Emphasis‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#emphasis","content":"Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this.  "},{"title":"Lists‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#lists","content":"First ordered list itemAnother item Unordered sub-list. Actual numbers don't matter, just that it's a number Ordered sub-list And another item. Unordered list can use asterisks Or minuses Or pluses  "},{"title":"Links‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#links","content":"I'm an inline-style link I'm an inline-style link with title I'm a reference-style link You can use numbers for reference-style link definitions Or leave it empty and use the link text itself. URLs and URLs in angle brackets will automatically get turned into links. http://www.example.com/ or http://www.example.com/ and sometimes example.com (but not on GitHub, for example). Some text to show that the reference links can follow later.  "},{"title":"Images‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#images","content":"Here's our logo (hover to see the title text): Inline-style:  Reference-style:   "},{"title":"Code‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#code","content":"var s = 'JavaScript syntax highlighting'; alert(s);  s = &quot;Python syntax highlighting&quot; print(s)  No language indicated, so no syntax highlighting. But let's throw in a &lt;b&gt;tag&lt;/b&gt;.  function highlightMe() { console.log('This line can be highlighted!'); }   "},{"title":"Tables‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#tables","content":"Colons can be used to align columns. Tables\tAre\tCoolcol 3 is\tright-aligned\t$1600 col 2 is\tcentered\t$12 zebra stripes\tare neat\t$1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown\tLess\tPrettyStill\trenders\tnicely 1\t2\t3  "},{"title":"Blockquotes‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#blockquotes","content":"Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote.  "},{"title":"Inline HTML‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#inline-html","content":"Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags.  "},{"title":"Line Breaks‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#line-breaks","content":"Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph.  "},{"title":"Admonitions‚Äã","type":1,"pageTitle":"Style Guide","url":"/PopGen.jl/docs/doc1#admonitions","content":"note This is a note tip This is a tip info This is important caution This is a caution danger This is a warning "},{"title":"Community","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/gettingstarted/community","content":"","keywords":""},{"title":"Join the Julia Slack workspace!‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#join-the-julia-slack-workspace","content":"Have questions, want to talk population genetics, or have ideas, then join the official Julia Slack workspace and navigate to the #Biology channel!  Community Standards The PopGen.jl community is committed to maintaining a welcoming, inclusive, civil, and constructive environment. We expect the following standards to be observed and upheld by all participants during all forms of communication. Be respectful and inclusive‚Äã Do not attack anyone based on any aspect of personal identity, including but not limited to: gender, sexuality, politics, religion, ethnicity, race, age, or ability. Refrain from making prejudiced or sexual jokes and comments or using overtly sexual language or imagery. If you believe one of these standards has been violated, you can either file an issue on an appropriate repository or confidentially contact Pavel in the Slack workspace. Although many mistakes are due to ignorance rather than malice, violation of these standards may result in the removal of an individual or individuals from the workspace. Please do your part in helping the community and the package grow. Adopted from the Julia Community Standards. "},{"title":"The PopGen.jl \"ecosystem\"‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#the-popgenjl-ecosystem","content":"The general approach to Julia is smaller packages that do specific things, with the goal of composability (interoperability) with other packages. Likewise, starting from version 0.7.0, PopGen.jl has been split into a series of packages. Unless explicitly stated, &quot;PopGen.jl&quot; broadly refers to these packages. The current roster‚Äã PopGenCore.jl: Core functionality for reading/writing files, PopData and other formats, PopData manipulation. Required by the other packages.PopGen.jl: The general toolset for population genetic analyses, like FST, relatedness, PCA, etc.PopGenSims.jl: Sample and siblingship simulations. "},{"title":"Contributing‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#contributing","content":"We absolutely welcome contributors to this package/project! See below for ways you can help PopGen.jl grow. "},{"title":"Improving available code‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#improving-available-code","content":"By nature, most (if not all) users of PopGen.jl will be biologists, and will not come from a strong computational background. Heck, the co-creators of the package don't even have a strong computation background (we're very good at nodding and smiling). There are various best-practices documented in Julia that help users write code to get the best performance out of the language, and sometimes a function that gets written isn't as performant as it can be. If you come up with faster and/or more memory efficient alternatives to the functions in PopGen.jl, we wholeheartedly encourage you to open up a issue or pull request and we'll try to integrate that into the PopGen.jl ecosystem. "},{"title":"Pointing out bugs‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#pointing-out-bugs","content":"No one is perfect (except maybe Betty White), so it's very possible that mistakes get made, especially as more users begin adopting and contributing to PopGen.jl (we hope). If something isn't functioning correctly, please open an issue that includes a minimum working example. We definitely want to figure out what's going on, and we need as much information as possible to try to diagnose issues as they come up. Julia's overall performance is rooted in really clever dispatching to the LLVM compiler, and the underlying system benefits most from stricter typing, wherever we can enforce it, and we expect that this strictness may result in extra issues being raised from niche use-cases. Testing your data against the available code‚Äã During PopGen.jl's development, we generally use nancycats and gulfsharks for just about everything. Those two datasets cover the range of what we expect are common use-cases; a smaller microsatellite dataset (nancycats) and a medium sized SNP dataset (gulfsharks). However, we know better than to put all of our faith into n = 2, so please use your own data and mess around with PopGen.jl and let us know if something doesn't jive. "},{"title":"Writing new functions or methods for existing functions‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#writing-new-functions-or-methods-for-existing-functions","content":"By all means, extend PopGen.jl to include all sorts of analyses! GST, Tajima's D, AMOVA, SAMOVA, porting BOTTLENECK, coalescence, etc. Yes please! Part of the intent behind PopGen.jl is to have it act as a sort of sandbox to play around in, which is why most of the package's basic calculations are modularized (see the hidden API). As a design choice, it made the most sense to have written the package in this way, because many population genetic calculations are built on top of other ones (like allele frequency or heterozygosity). "},{"title":"Writing or editing the docs‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#writing-or-editing-the-docs","content":"The documentation of PopGen.jl must be approachable and helpful. Helpful in the sense that if someone was tasked with &quot;looking for siblings&quot; in their data and didn't know exactly how, that the documentation for the relatedness command would provide some kind of context as to what it does and how, with figures, and with helpful in-line links to the source publications or more in-depth online resources. This package is not intended for only expert-level users, which means that the documentation needs to be accessible to entry-level users. By no means will the documentation be the ultimate compendium of all population genetics knowledge, but it will be helpful beyond simply stating a command, its arguments, and a one-liner of what it does. If you want to contribute but don't feel comfortable with the programming side of things, then we encourage you to help grow the documentation. Clarify the language in some sections, or maybe provide a useful diagram where one doesn't exist. Or typos. There are always typoes. "},{"title":"Spreading the word‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#spreading-the-word","content":"The very soul of open-source projects relies on people wanting to get involved. Spread the word üòÉ. If you are into social media, give us a shoutout. We can't imagine why you'd want to, but if you insisted on using a hashtag, then #PopGenjl is probably the sensible choice. "},{"title":"Kindness and encouragement‚Äã","type":1,"pageTitle":"Community","url":"/PopGen.jl/docs/gettingstarted/community#kindness-and-encouragement","content":"This stuff can be hard. As the package grows, we expect that we'll be dealing with a growing number of issues/complaints. A little thumbs-up üëç or prayer-hands üôè emoji (Pavel's personal favorite) can go a long way. Or cook up your own cactus graphic (like the one below) and send it to us. Who doesn't love adorable cactuses doing human things?  "},{"title":"Provided datasets","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/gettingstarted/datasets","content":"","keywords":""},{"title":"datasets‚Äã","type":1,"pageTitle":"Provided datasets","url":"/PopGen.jl/docs/gettingstarted/datasets#datasets","content":"PopGen.dataset(::String)  Returns a PopData object of the dataset you would like to retrieve by calling the dataset as a string by name. Example: sharks = PopGen.dataset(&quot;gulfsharks&quot;) cats = PopGen.dataset(&quot;nancycats&quot;)  "},{"title":"nancycats‚Äã","type":1,"pageTitle":"Provided datasets","url":"/PopGen.jl/docs/gettingstarted/datasets#nancycats","content":"We include the familiar nancycats microsatellite data, as featured in adegenet, for easy importing into PopGen.jl as PopData. As an alternative to datasets, you can invoke the @nancycats macro. julia&gt; cats = @nancycats PopData{Diploid, 9 Microsatellite loci} Samples: 237 Populations: 17  The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know! "},{"title":"gulfsharks‚Äã","type":1,"pageTitle":"Provided datasets","url":"/PopGen.jl/docs/gettingstarted/datasets#gulfsharks","content":"We also include the SNP dataset used in Dimens et al. 2019 since it was already on hand. Like nancycats, we provide a convenient function to load these data into PopGen.jl as PopData. As an alternative to dataset, you can invoke the @gulfsharks macro. julia&gt; sharks = @gulfsharks PopData{Diploid, 2209 SNP loci} Samples: 212 Populations: 7 Other Info: [&quot;longitude&quot;, &quot;latitude&quot;]  "},{"title":"Comparison","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/gettingstarted/comparison","content":"","keywords":""},{"title":"Benchmarks‚Äã","type":1,"pageTitle":"Comparison","url":"/PopGen.jl/docs/gettingstarted/comparison#benchmarks","content":"To make this a practical comparison, we're going to use the gulfsharks data because it is considerably larger (212 samples x 2209 loci) than nancycats (237 x 9) and a bit more of a &quot;stress test&quot;. All benchmarks in R are performed using the microbenchmark package, and BenchmarkTools are used for Julia. load Julia packagesload R packages using BenchmarkTools, PopGen  As a note, the reported benchmarks are being performed on a 64-bit Manjaro Linux system on a nothing-special Lenovo Thinkbook 14S with 8gigs of RAM and a 8th gen Intel i5 mobile processor. Note: all of the Julia benchmarks, unless explicitly stated, are performed single-threaded (i.e. not parallel, distributed, or GPU). "},{"title":"Reading in data‚Äã","type":1,"pageTitle":"Comparison","url":"/PopGen.jl/docs/gettingstarted/comparison#reading-in-data","content":"Since gulfsharks is provided in PopGenCore.jl, we will just load it with genepop(). If you would like to try this yourself in R, find the gulfsharks.gen file in the package repository under /data/source/gulfsharks.gen. Since the file importer now uses CSV.jl to read files, there is one step of the genepop parser that is multithreaded. However, the majority of the data parsing (formatting the raw data into a correct PopData structure) occurs using a single thread. This R benchmark will take a few minutes. Consider making some tea while you wait. JuliaR @benchmark sharks = genepop(&quot;data/source/gulfsharks.gen&quot;, silent = true) BenchmarkTools.Trial: 10 samples with 1 evaluation. Range (min ‚Ä¶ max): 472.671 ms ‚Ä¶ 526.777 ms ‚îä GC (min ‚Ä¶ max): 0.00% ‚Ä¶ 5.75% Time (median): 507.187 ms ‚îä GC (median): 5.00% Time (mean ¬± œÉ): 501.984 ms ¬± 17.301 ms ‚îä GC (mean ¬± œÉ): 3.47% ¬± 2.99% ‚ñÅ ‚ñÅ ‚ñÅ ‚ñÅ ‚ñÅ ‚ñÅ ‚ñà ‚ñÅ ‚ñÅ ‚ñà‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñà‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñà‚ñÅ‚ñÅ‚ñÅ‚ñà‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñà‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñà‚ñÅ‚ñà‚ñÅ‚ñÅ‚ñÅ‚ñà‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñà ‚ñÅ 473 ms Histogram: frequency by time 527 ms &lt; Memory estimate: 172.46 MiB, allocs estimate: 2246870.   Comparing averages, Julia (via PopGen.jl) clocks in at 507ms versus R (via adegenet) at 6.745s , so ~13.3x faster. "},{"title":"PopData vs genind size‚Äã","type":1,"pageTitle":"Comparison","url":"/PopGen.jl/docs/gettingstarted/comparison#popdata-vs-genind-size","content":"It was pretty tricky to come up with a sensible/efficient/convenient data structure for PopGen.jl, and while the two-DataFrames design might not seem like it took a lot of effort, we ultimately decided that the column-major style and available tools, combined with careful genotype Typing was a decent &quot;middle-ground&quot; of ease-of-use vs performance. Anyway, it's important to understand how much space your data will take up in memory (your RAM) when you load it in, especially since data's only getting bigger! Keep in mind that gulfsharks in PopGen.jl also provides lat/long data, which should inflate the size of the object somewhat compared to the genind, which we won't add any location data to. JuliaR julia&gt; Base.summarysize(sharks) 3452870 #bytes   The original genepop file is 3.2mb (the vertical line), and our PopData object takes up ~3.45mb in memory (300kb larger than the source file) versus the ~5.3mb of a genind, which is ~1.5x larger than the source file. That's quite a big difference! "},{"title":"Summary statistics‚Äã","type":1,"pageTitle":"Comparison","url":"/PopGen.jl/docs/gettingstarted/comparison#summary-statistics","content":"The obvious hallmark of population genetics is heterozygosity values and F-statistics. Here we'll compare the basic summary statistics that can be produced using hierfstat and PopGen.jl. JuliaR julia&gt; @benchmark summary(sharks, by = &quot;global&quot;) BenchmarkTools.Trial: memory estimate: 88.42 MiB allocs estimate: 1307128 -------------- minimum time: 151.963 ms (0.00% GC) median time: 171.484 ms (7.60% GC) mean time: 172.456 ms (6.08% GC) maximum time: 186.606 ms (7.04% GC) -------------- samples: 29 evals/sample: 1   Comparing averages, PopGen.jl clocks in at ~171ms versus hierfstat's 4.6s, which is ~27x faster on these data. However, when testing on a data that was 401 samples x 5331 loci (not shown), PopGen.jl performed 36.6x faster. This gap seems to increase the larger the data is, but we have not tested the upper limits of this. "},{"title":"Chi-squared test for HWE‚Äã","type":1,"pageTitle":"Comparison","url":"/PopGen.jl/docs/gettingstarted/comparison#chi-squared-test-for-hwe","content":"This is a classic population genetics test and a relatively simple one. The R benchmark will take a while again, so if you're following along, this would be a good time to reconnect with an old friend. JuliaR julia&gt; @benchmark hwe_test(sharks) BenchmarkTools.Trial: memory estimate: 46.22 MiB allocs estimate: 1050525 -------------- minimum time: 145.476 ms (0.00% GC) median time: 179.146 ms (4.35% GC) mean time: 176.142 ms (3.56% GC) maximum time: 204.813 ms (0.00% GC) -------------- samples: 29 evals/sample: 1   Comparing averages, PopGen.jl clocks in at ~176ms versus adegenet's 6.3s, so ~35.8x faster on these data(!) "},{"title":"Pairwise FST‚Äã","type":1,"pageTitle":"Comparison","url":"/PopGen.jl/docs/gettingstarted/comparison#pairwise-fst","content":"You all know it, you all love it. What's population genetics without a little pairwise FST sprinkled in? This benchmark compairs the Weir &amp; Cockerham pairwise FST calculation in PopGen.jl against hierfstat JuliaJulia (parallel)R We will add the extra keywords samples and seconds to the benchmark macro so we can get a full 100 evaluations. You will need to start Julia with 1 available threads via julia --threads 1 (julia &gt;= v1.5) or JULIA_NUM_THREADS=1 (&lt; v1.5). julia&gt; @benchmark pairwise_fst(sharks) samples = 100 seconds = 700 BenchmarkTools.Trial: memory estimate: 869.93 MiB allocs estimate: 6090633 -------------- minimum time: 557.995 ms (9.29% GC) median time: 571.297 ms (11.26% GC) mean time: 580.627 ms (12.59% GC) maximum time: 754.451 ms (31.41% GC) -------------- samples: 100 evals/sample: 1   On a single thread, pairwise FST in PopGen.jl is ~340x faster than in hierfstat, and a whopping 665x faster using 6 threads with the optimized matrix-based implementation. "},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/gettingstarted/quickstart","content":"","keywords":""},{"title":"1. Install PopGen‚Äã","type":1,"pageTitle":"Quick Start","url":"/PopGen.jl/docs/gettingstarted/quickstart#1-install-popgen","content":"REPL/JunoJupyter/nteract Invoke the package manager with ] in the REPL and use add PopGen  "},{"title":"2. Invoke the package‚Äã","type":1,"pageTitle":"Quick Start","url":"/PopGen.jl/docs/gettingstarted/quickstart#2-invoke-the-package","content":"Simply run: julia&gt; using PopGen  "},{"title":"3. Start playing around‚Äã","type":1,"pageTitle":"Quick Start","url":"/PopGen.jl/docs/gettingstarted/quickstart#3-start-playing-around","content":"To help get started, you can call ?PopGen and be greeted with some information to help you get started: julia&gt; ?PopGen Population genetics analyses in Julia Repository: https://www.github.com/biojulia/PopGen.jl/ Documentation: https://biojulia.net/PopGen.jl/ A few things things you can do to get started: Import Data - PopGen.read(filename; kwargs...) - genepop(infile; kwargs...) or similar file-specific importer - use available @gulfsharks or @nancycats datasets Explore PopData - populations(PopData) to view population information - loci(PopData) to view locus names - samplenames(PopData) to view sample names - missing(PopData, by = ...) to view missing information Manipulate PopData - populations!(PopData, ...) to rename populations - locationdata!(PopData, ...) to add geographical coordinates - exclude!(PopData; kwargs...) to selectively remove data Analyses - richness(PopData) to calculate allelic richness - kinship(PopData, method = ...) to get pairwise relatedness of individuals - summary(PopData) to calculate F-statistics, heterozygosity, etc. - hwetest(PopData) to test for Hardy-Weinberg Equilibrium - pairwisefst(PopData) to calculate FST between pairs of populations  "},{"title":"PopGen.jl tips","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/gettingstarted/tips","content":"","keywords":""},{"title":"PopGen vs PopGenCore‚Äã","type":1,"pageTitle":"PopGen.jl tips","url":"/PopGen.jl/docs/gettingstarted/tips#popgen-vs-popgencore","content":"TLDR PopGen is for analyses, PopGenCore is for everything else PopGen.jl is now intended exclusively for population genetic analyses, and PopGenCore.jl is the &quot;core&quot; package where just about every utility lives relating to working with PopData that isn't an analysis. The recent split of PopGen and PopGenCore means PopGenCore is now a great standalone package for data viewing and manipulation. If you don't need higher order analyses (which is what PopGen.jl provides), then PopGenCore.jl should be enough. "},{"title":"Internal functions‚Äã","type":1,"pageTitle":"PopGen.jl tips","url":"/PopGen.jl/docs/gettingstarted/tips#internal-functions","content":"TLDR functions you aren't expected to use start with underscores _ It's pretty common to have a series of user-facing functions in a package (the ones that get exported) along with a series of unexported ones that are useful for development or are helper functions for the exported ones. If you see a function that starts with an underscore, like _adjacency_matrix, then you (as a user) aren't expected to know or worry about it, let alone use it. You totally can, but not all of them have docstrings. "},{"title":"Function names‚Äã","type":1,"pageTitle":"PopGen.jl tips","url":"/PopGen.jl/docs/gettingstarted/tips#function-names","content":"TLDR all user functions in PopGen.jl (not including PopGenCore.jl) are lowercase and use no underscores In an effort to be consistent with the Julia language and just consistent overall, user-facing functions are named with three main principals: as verbose of a name as is reasonableno underscores between wordsall lowercase, always, unless it's a DataType or method keyword option (like the kinship or series) These decisions are because of years-long frustration with the swirling chaos that is R function names. Where it is possible and reasonable to do so, function names are verbose and descriptive. For example, if you wanted to perform a pairwise FST, the function is called pairwisefst -- not fst, FST,pairwise_fst, pairwise_FST, or pairwiseFST. This is an ongoing effort, so if you spot something that doesn't fit this mold, please submit a Pull Request! "},{"title":"Argument names‚Äã","type":1,"pageTitle":"PopGen.jl tips","url":"/PopGen.jl/docs/gettingstarted/tips#argument-names","content":"TLDR all user functions in PopGen.jl have descriptive keyword argument names This too is driven by frustration with the shortened and/or truncated keyword arguments of just about every R function. As if learning another language wasn't enough of a task, memorizing nonintuitive keywords is a completely unneccessary stumbling block. To the best of our abilities, we try to name keywords using entire words, and hopefully words that are intuitive if you were just trying to guess before calling up the docstring. "},{"title":"Dev tips‚Äã","type":1,"pageTitle":"PopGen.jl tips","url":"/PopGen.jl/docs/gettingstarted/tips#dev-tips","content":"TLDR Avoid allocations when possibleFirst drafts don't need to be efficient or performantWhen in doubt, roll your own helper functions If you plan on extending PopGen.jl, here are some useful tips we learned the hard way: Most basic (non-mathematic) or fundamental operations live in PopGenCore.jlMath and analyses live in PopGen.jlIt's ok to write something functional but not efficient. Things we can always be improved later!Allocations are the enemy Ignore this recommendation if the goal is a first draft or proof of conceptCreating Arrays is costly and that cost scales tremendously with core operations occurring thousands/millions of timesIf the goal is to be performant, aim for as few allocations as possibleEmbrace loops if statements inside loops slow them down But if they are small or simple enough, can still be faster and more efficient than allocating Arrays Sometimes Base (or others) don't have the performance you need There's no harm in writing a small helper function if it's an improvement Incrementing a variable inside a loop with += or similar (example 1) is a lot more performant that doing so with a list comprehension (example 2), even though it requires more lines of code. # example 1: Incrementing inside for loop # performant n = 0 for i in 1:something n += 1 end # example 2: Incrementing inside list comprehension # not as performant n = 0 [n+= 1 for i:something]  "},{"title":"A quick Julia primer","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/gettingstarted/juliaprimer","content":"","keywords":""},{"title":"Using Julia‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#using-julia","content":"TLDR Work with Julia using VSCode, Jupyter, Pluto.jl, command line Everyone has their own particular workflows, and if you're new to Julia, you might not have established one yet. Julia can be used rather comfortably using its built-in interpreter. For an RStudio-like experience, we recommend using the VScode Julia extension. If you're a fan of Jupyter notebooks, then all you need is to install the IJulia package in Julia and you have full Jupyter support for Julia! Alternatively, you can use the built-in Jupyter engine inside VScode with the Jupyter and Julia VScode extensions. You can also use the new reactive notebooks provided by Pluto.jl. Trivia If you didn't already know, the name &quot;Jupyter&quot; is actually a concatenation of Ju (julia) Pyt (python) and eR (R). ü§Ø "},{"title":"First-time Performance‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#first-time-performance","content":"TLDR Non standard-library packages (like this one) often have a bit of lag when running a function the first time. If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). It's worth mentioning that this lag is &quot;compilation overhead&quot;. What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia&gt; @time using PopGen 11.870878 seconds (27.83 M allocations: 1.389 GiB, 5.26% gc time) julia&gt; @time using PopGen 0.000272 seconds (406 allocations: 21.375 KiB)  "},{"title":"Semicolons‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#semicolons","content":"TLDR Semicolons after a command suppress output, and between commands are like a &quot;newline&quot; for brevity. Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different things depending on where they are. "},{"title":"At the end of a command‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#at-the-end-of-a-command","content":"When you see a semicolon after invoking a function, what that means is &quot;don't show me the output&quot;. Example: julia&gt; x = 2 + 2 4 julia&gt; x = 10 + 2 ; julia&gt; x 12  Julia will still process the command and assign 10 + 2 to x, but it won't show you the output. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back large volumes of text. These semicolons are optional "},{"title":"In between assignment commands‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#in-between-assignment-commands","content":"If you see a semicolon in between two variable assignments or commands, like so: julia&gt; x = [1,2] ; y = [3,4]  that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: julia&gt; x = [1,2] julia&gt; y = [3,4]  We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you! "},{"title":"Help mode‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#help-mode","content":"TLDR Activate help mode (to read docstrings) with ? on an empty line. To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?&gt; for you to type in a function. help?&gt;population  search: population populations population! populations! population(data::PopData; counts::Bool = false) View unique population ID's and their counts in a `PopData`. - `counts = true` : displays the number of samples per population  "},{"title":"Type information‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#type-information","content":"TLDR Types have the format variable::type in function singatures. &lt;: is a shorthand for &quot;is a subtype of&quot;, and {T} where T is a shorthand for broadening or restricting type signatures. Unions allow for multiple types. Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is variable::type. This format is a type declaration, so in the function population, which looks like: population(data::PopData; counts::Bool = false)  data is a positional argument of type PopData counts is a keyword argument (because of the semicolon, see below) of type Bool (Boolean) meaning it only takes true or false without quotes, and the default value is set to false "},{"title":"Type Unions‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#type-unions","content":"You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of allowable types. For example, if something was of type ::Union{String,Integer}, that means that either a String or Integer works. "},{"title":"Subtypes‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#subtypes","content":"The julia language is abound with types (and you can create your own!), and has a hierarchical system of supertypes and subtypes. As you can probably guess, a supertype can contain multiple subtypes, such as Signed being a supertype of (among other things) Int64, Int32, Int16, Int8. All vectors are subtypes of AbstractVector. If you want to try it yourself, use the supertype() command on your favorite Type, like supertype(Float32). You will occasionally see &lt;: instead of ::, which means &quot;is a subtype of&quot;. This is used for condtional evaluation, like typeof(something) &lt;: Signed, and in some function methods like function(var1::T) where T &lt;: Supertype, which leads us to: where T‚Äã This looks weird at first, but it's actually very simple. When we do method definitions, we can define methods with strict types, like funct(data:PopData, arg1::Int8), or we can generalize it with where T, which looks like : function funct1(data::PopData, thing1::T) where T  This will auto-create a method for any possible Type for thing1. That's really convenvient, but sometimes it's problematic, as incorrect input can lead to obscure errors (e.g. multiplying integers with strings?!). Instead, you can constrain the types for T like this: function funct2(data::PopData, thing1::T) where T &lt;: Signed  With the constraint above, it will generate methods for all cases where thing1 is a subtype of Signed, which includes all the numerical Types (integers, Floats, etc.). This will make sure that the function will behave correctly for a range of input types. You can also use this type of notation to clean up a method definition where multiple arguments have the same Type specification: function funct3(data::PopData, thing1::T, thing2::T, thing3::T) where T&lt;:AbstractFloat  So, instead of writing thing1::Float64, thing2::Float64, thing3::Float64, we just use T as a placeholder and assign it as a subtype of something at the end. It ends up being pretty handy! "},{"title":"Functions vs. Methods‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#functions-vs-methods","content":"TLDR A function is made up of mulitple methods. They all share the same name and differ in the input types/order. A MethodError means you're trying to use a known function but your inputs don't match any of its methods. As part of Julia's type-safe paradigm and multiple dispatch (see &quot;ERROR: MethodError: no method matching&quot; below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. Best Practice As a rule of thumb, for loops with if conditions in them slow down the compiler, so best-practice often encourages us to write type-specific methods. In practice, this looks like: # combine two numbers julia&gt; function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia&gt; function add(x::String, y::String) x*y end add (generic function with 2 methods) julia&gt; add(1,2) 3 julia&gt; add(&quot;water&quot;, &quot;melon&quot;) &quot;watermelon&quot;  Multiple dispatch therefor leads to a unique type of possible error: the MethodError "},{"title":"ERROR: MethodError: no method matching‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#error-methoderror-no-method-matching","content":"Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String: julia&gt; add(1,&quot;melon&quot;) ERROR: MethodError: no method matching add(::Int64, ::String) Closest candidates are: add(::String, ::String) at none:2 add(::Integer, ::Integer) at none:2 Stacktrace: [1] top-level scope at none:0  This error is telling us &quot;there is no such method called add, who's inputs are an Integer followed by a String&quot;. But, it does offer us some alternatives, like the two add methods we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see &quot;Functions with and without keywords&quot; below). Sometimes you might include an argument with a keyword when there isn't one, or include an argument without a keyword when there needs to be one (honestly, we make that mistake too and we wrote this stuff). To help minimize those mistakes, please read below about which arguments have keywords and which don't. MethodErrors MethodError's can definitely get annoying, but they are more commonly the result of incorrect inputs versus being bugs. If you double-checked your inputs and things still don't work, please submit an issue. Thanks! "},{"title":"Functions with and without keywords‚Äã","type":1,"pageTitle":"A quick Julia primer","url":"/PopGen.jl/docs/gettingstarted/juliaprimer#functions-with-and-without-keywords","content":"TLDR arguments before a semicolon have no keyword and follow an explicit orderarguments after a semicolon have a keyword argument = value and their order doesn't matterMethodError: no methods matching is often a user error and not a bug, but if it is, please open an issue! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term &quot;keywords&quot; refers to an input argument that has the format argument = value. This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. 1. No semicolon in argument list2. Semicolon in argument list function function_name(var1::type, var2::type, var3::type) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name(var1::String, var2::Float64, var3::Array{String,1}) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}). Even if some of the arguments have a default values, like var2::Float64 = 6.66, the order of arguments/types has to be respected as declared. "},{"title":"Baypass","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/io/baypass","content":"","keywords":""},{"title":"baypass‚Äã","type":1,"pageTitle":"Baypass","url":"/PopGen.jl/docs/io/baypass#baypass","content":"baypass(data::PopData; filename::Union{String, Nothing} = nothing)  Convert a PopData object into a Baypass-format matrix. The input format for the Baypass software requires biallelic data. By default, it returns just the Baypass-format matrix; use the keyword argument filename to specify a file to write the matrix to. This function does not perform a Baypass analysis, but instead creates the input matrix necessary for it. The matrix specification is: rows = loci each row is a different locus columns = allele counts per population each pair of columns correspond to the alleles' counts (2 alleles, 2 columns) for a populationas a result, there should be 2 √ó n_populations columnse.g. row 1, columns 1:2 are the allele counts for locus 1 in population 1 "},{"title":"Keyword arguments‚Äã","type":1,"pageTitle":"Baypass","url":"/PopGen.jl/docs/io/baypass#keyword-arguments","content":"filename: a String of the name of the output file. If nothing, then this function just returns the Baypass input matrix without writing to a file. (default: nothing) Example julia&gt; sharks = @gulfsharks; julia&gt; dropmultiallelic!(sharks) julia&gt; baypass(sharks, filename = &quot;gulfsharks.baypass&quot;) ;  "},{"title":"Delimited","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/io/delimited","content":"","keywords":""},{"title":"Import a delimited file as PopData‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#import-a-delimited-file-as-popdata","content":"delimited(infile::String; kwargs...)  "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#arguments","content":"infile::String : path to the input file, in quotes "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#keyword-arguments","content":"delim::String : delimiter characters. The default (&quot;auto&quot;) uses auto-parsing of CSV.File digits::Integer : the number of digits used to denote an allele (default: 3) diploid::Bool : whether samples are diploid for parsing optimizations (default: true) silent::Bool : whether to print file information during import (default: false) "},{"title":"Example‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#example","content":"lizardsCA = delimited(&quot;CA_lizards.csv&quot;, digits = 3);  "},{"title":"Format‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#format","content":"First row is column names, and they occur in this order: namepopulationlongitudelatitudelocus_1_namelocus_2_nameetc... Formatting example: raw csvtable view name,population,longitude,latitude,Locus1,Locus2,Locus3 sierra_01,mountain,11.11,-22.22,001001,-9,001001 sierra_02,mountain,11.12,-22.21,001001,001001,001002 snbarb_01,coast,,,001001,001001,001002 snbarb_02,coast,11.14,-22.24,001001,001001,001001 snbarb_03,coast,11.15,,001002,001001,001001  "},{"title":"Missing data‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#missing-data","content":"Genotypes‚Äã Missing genotypes can be formatted as all-zeros (ex.000000) or negative-nine -9 Location data‚Äã If location data is missing for a sample (which is ok!), make sure the value is blank, otherwise there will be transcription errors! (example at line 3 in the example above) alias You can also use the command csv() synonymously with delimited(). "},{"title":"Writing to a delimited file‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#writing-to-a-delimited-file","content":"All file writing options can be performed using PopGen.write(), which calls delimited when writing to a delimited file. delimited(data::PopData; filename::String, delim::String = &quot;,&quot;, digits::Integer = 3, format::String = &quot;wide&quot;, miss::Int = 0)  Write PopData to a text-delimited file. "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#keyword-arguments-1","content":"filename::String: the output filenamedigits::Integer : how many digits to format each allele (default: 3) e.g. digits = 3 will turn (1, 2) into 001002 format::String: whether to output in&quot;wide&quot; or &quot;long&quot; (aka &quot;tidy&quot;) format wide : the standard-format CSV for importing into PopGen.jl (default)long : the loci table with longitude and latitude columns added delim::String: delimiter to use for writing the file (default: &quot;,&quot;)miss::Integer: how you would like missing values written 0 : As a genotype represented as a number of zeroes equal to digits √ó ploidy like 000000 (default) -9 : As a single value -9 "},{"title":"Example‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#example-1","content":"cats = @nancycats; fewer_cats = omit(cats, name = samplenames(cats)[1:10]); delimited(fewer_cats, filename = &quot;filtered_nancycats.gen&quot;, digits = 3, format = &quot;wide&quot;, delim = &quot; &quot;)  "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Delimited","url":"/PopGen.jl/docs/io/delimited#acknowledgements","content":"Thanks to the efforts of the CSV.jl team, we are able leverage that package to do much of the heavy lifting within this parser. "},{"title":"Genepop","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/io/genepop","content":"","keywords":""},{"title":"Import a genepop file as PopData‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#import-a-genepop-file-as-popdata","content":"genepop(infile; kwargs...)  "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#arguments","content":"infile::String : path to genepop file, in quotes "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#keyword-arguments","content":"digits::Integer: number of digits denoting each allele (default: 3)popsep::String : word that separates populations in infile (default: &quot;POP&quot;)diploid::Bool : whether samples are diploid for parsing optimizations (default: true)silent::Bool : whether to print file information during import (default: false) population names By default, the file reader will assign numbers as population ID's (as Strings) in order of appearance in the genepop file. Use the populations! function to rename these with your own population ID's. "},{"title":"Example‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#example","content":"julia&gt; wasp_data = genepop(&quot;/data/wasp_hive.gen&quot;, digits = 3, popsep = &quot;POP&quot;)  "},{"title":"Format‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#format","content":"Files must follow standard Genepop formatting: First line is a comment (and skipped)Loci are listed after first line as one-per-line without commas or in single comma-separated rowA line with a particular and consistent keyword must delimit populations must be the same word each time and not a unique population name File is tab delimited or space delimited, but not both genepop w/loci stacked verticallygenepop w/loci stacked horizontally Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120  "},{"title":"Writing to a Genepop file‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#writing-to-a-genepop-file","content":"All file writing options can be performed using PopGen.write(), which calls genpop when writing to a Genepop file. genepop(data::PopData; filename::String = &quot;output.gen&quot;, digits::Int = 3, format::String = &quot;vertical&quot;, miss::Int = 0)  Writes a PopData object to a Genepop-formatted file. "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#arguments-1","content":"data: the PopData object you wish to convert to a Genepop file "},{"title":"Keyword arguments‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#keyword-arguments-1","content":"filename::String: the output filenamedigits::Integer: how many digits to format each allele e.g. digits = 3 will turn (1, 2) into 001002 format::String : the way loci should be formatted vertically (&quot;v&quot; or &quot;vertical&quot;)hortizontally (&quot;h&quot;, or &quot;horizontal&quot;)isolation-by-distance (&quot;ibd&quot;) where each sample is a population with coordinate data prepended miss::Integer : how you would like missing values written 0 : as a genotype represented as a number of zeroes equal to digits √ó ploidy like 000000 (default) -9 : as a single value -9 "},{"title":"Example‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#example-1","content":"cats = @nancycats; fewer_cats = omit(cats, name = samplenames(cats)[1:10]); julia&gt; genepop(fewer_cats, filename = &quot;filtered_nancycats.gen&quot;, digits = 3, format = &quot;h&quot;)   "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Genepop","url":"/PopGen.jl/docs/io/genepop#acknowledgements","content":"The original implementations of the importing parser were written using only Base Julia, and while the speed was fantastic, the memory footprint involved seemed unusually high (~650mb RAM to parse gulfsharks, which is only 3.2mb in size). However, thanks to the efforts of CSV.jl, we leverage that package to preserve the speed and reduce the memory footprint quite a bit! "},{"title":"Plink","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/io/plink","content":"","keywords":""},{"title":"Import PLINK files as PopData‚Äã","type":1,"pageTitle":"Plink","url":"/PopGen.jl/docs/io/plink#import-plink-files-as-popdata","content":"plink(infile::String; keepfields::Symbol|Vector{Symbol}, silent::Bool)  Read a PLINK .ped or binary .bed file into memory as a PopData object. Requires an accompanying .fam file in the same directory, but an accompanying .bim file is optional. infile::String : path to .ped or .bed file "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Plink","url":"/PopGen.jl/docs/io/plink#keyword-arguments","content":"famfields::Symbol|Vector{Symbol}: which additional fields to import from the .fam file :all (default):noneany one or combination of [:sire, :dam, :sex, :phenotype] bimfields::Symbol|Vector{Symbol}: which additional fields to import from the optional .bim file :all (default):noneany one or combination of [:chromosome, :cm, :bp] silent::Bool: whether to print file information during import (default: false) Example # assumes there is parakeet.ped + parakeet.fam in same directory julia&gt; parakeet = plink(&quot;datadir/parakeet.ped&quot;, famfields = :sex) # assumes there is parrot.ped + parrot.fam in same directory julia&gt; parrot = plink(&quot;datadir/parrot.bed&quot;, famfields = [:sire, :dam], bimfields = :chromosome)  "},{"title":"Write PopData to PLINK format‚Äã","type":1,"pageTitle":"Plink","url":"/PopGen.jl/docs/io/plink#write-popdata-to-plink-format","content":"plink(data::PopData; filename::String)  Write a biallelic PopData object to PLINK .ped format with an accompanying.fam file. Genotypes are coded by the PLINK standard: Integers are the alleles0 encodes missingAfter column 6, every two numbers indicate a diploid genotype such that: 00 Homozygous for first allele01 Missing genotype10 Heterozygous11 Homozygous for second allele Example julia&gt; sharks = dropmultiallelic(@gulfsharks) ; julia&gt; plink(sharks, filename = &quot;biallelic_sharks.ped&quot;)  "},{"title":"Structure","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/io/structure","content":"","keywords":""},{"title":"Import a Structure file as PopData‚Äã","type":1,"pageTitle":"Structure","url":"/PopGen.jl/docs/io/structure#import-a-structure-file-as-popdata","content":"structure(infile::String; kwargs...)  "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Structure","url":"/PopGen.jl/docs/io/structure#arguments","content":"infile::String : path to Structure file "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Structure","url":"/PopGen.jl/docs/io/structure#keyword-arguments","content":"extracols::Integer: how many additional optional columns there are beyond Stucture's POPDATA the reader needs to ignore (default: 0) these include POPFLAG, LOCDATA, or anything else you might have added extrarows::Integer : how many additional optional rows there are beyond the first row of locus names (default: 0)missingval::String : the value used to identify missing values in the data (default: &quot;-9&quot;)silent::Bool : whether to print file information during import (default: false)allow_monomorphic::Bool : whether to keep monomorphic loci in the dataset (default: false)faststructure::Bool: whether the file is fastStructure format (default: false) "},{"title":"File formatting‚Äã","type":1,"pageTitle":"Structure","url":"/PopGen.jl/docs/io/structure#file-formatting","content":"Structure files are not an ideal format because there is a bit too much wiggle room in the specifications that are later cleaned up with a config file when running the software. As such, PopGen.jl requires somewhat more specificity in how the files are formatted for things to work correctly: StucturefastStructre the file is tab or space delimited but not bothfirst row is locus names separated by the delimiter leading/trailing whitespaces are toleratedoptional rows allowed after the locus names number of rows per sample = ploidy e.g. if diploid, that sample would have 2 rowsmulti-column variant not supported first data column is sample namesecond data column is population ID optional columns allowed after the population ID (2nd) column remaining columns are the genotype for that individual for that locus Structure file example:‚Äã locus_1 locus_2 locus_3 locus_4 locus_5 walnut_01 1 -9 145 66 0 92 walnut_01 1 -9 -9 64 0 94 walnut_02 1 106 142 68 1 92 walnut_02 1 106 148 64 0 94 walnut_03 2 110 145 -9 0 92 walnut_03 2 110 148 66 1 -9 Example‚Äã walnuts = structure(&quot;juglans_nigra.str&quot;, extracols = 0, extrarows = 0)  "},{"title":"Writing to a Structure file‚Äã","type":1,"pageTitle":"Structure","url":"/PopGen.jl/docs/io/structure#writing-to-a-structure-file","content":"All file writing options can be performed using PopGen.write(), which calls structure when writing to a Structure/fastStructure file. structure(data::PopData; filename::String, faststructure::Bool, delim::String)  Write a PopData object to a Stucture format file "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Structure","url":"/PopGen.jl/docs/io/structure#arguments-1","content":"data: the PopData object you wish to convert to a Structure file "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Structure","url":"/PopGen.jl/docs/io/structure#keyword-arguments-1","content":"filename::String: the output filenamedelim::String : either &quot;tab&quot; or &quot;space&quot; indicating the delimiter (default: &quot;tab&quot;)faststructure::Bool: if the output should be formatted for fastStructure (default: false) Example‚Äã cats = @nancycats; fewer_cats = omit(cats, name = samplenames(cats)[1:10]); structure(fewer_cats, filename = &quot;filtered_nancycats.str&quot;, faststructure = true)  "},{"title":"Read/Write data","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/io/readwrite","content":"","keywords":""},{"title":"Read in data‚Äã","type":1,"pageTitle":"Read/Write data","url":"/PopGen.jl/docs/io/readwrite#read-in-data","content":"You're encouraged to use these functions, but PopGen.jl also provides you with an all-encompassing wrapper PopGen.read(). Given the ubiquity of the function name, it is not exported. If using PopGenCore.jl directly, you will need to call it with PopGenCore.read. Windows users Make sure to change the backslashes \\ in your file path to double-backslashes \\\\ or forward slashes / monomorphic loci By default, the file reading methods drop monomorphic loci and inform you which were removed, so do not be alarmed if the number of loci in your PopData is different from the source data. You can disable this behavior with the argument allow_monomorphic = true. Monomorphic loci are removed by default because they can give spurious/misleading results for some analyses, such as kinship estimators. "},{"title":"PopGen.read()‚Äã","type":1,"pageTitle":"Read/Write data","url":"/PopGen.jl/docs/io/readwrite#popgenread","content":"PopGen.read(infile::String; kwargs...)  where infile is a String of your filename (in quotes) and kwargs are the corresponding keyword arguments associated with your file type. The function PopGen.read() uses all the same keyword arguments as do the commands specific to their file types, therefore you should have a look at those commands (usually the defaults suffice). PopGen.read() infers the file type from the file extension, so for it to work properly your file must end with the extensions permitted below (case insensitive). If you're feeling particularly rebellious and your file does not conform to these extensions (such as a genepop file with a .gen.final.v2.seriously extension), then feel free to use the specific file importers, since they use the same exact syntax, there is zero difference in performance, and ignore file extensions. Ultimately, what crazy extensions you give your files is your business, and we love that about you. Examples salmon = PopGen.read(&quot;o_mykiss.gen&quot;, digits = 3, popsep = &quot;SALMON&quot;) ginko = PopGen.read(&quot;g_biloba.txt&quot;, delim = &quot;,&quot;, digits = 2, silent = true)  "},{"title":"Write PopData to file‚Äã","type":1,"pageTitle":"Read/Write data","url":"/PopGen.jl/docs/io/readwrite#write-popdata-to-file","content":"PopGen.write(data::PopData; filename::String, kwargs...)  To complement PopGen.read(), PopGen.jl offers PopGen.write(), which writes PopData to different file formats. Like the file reader, PopGen.write() will infer the correct output file type from the output filename's extensions. Given the ubiquity of the function name, it is not exported. If using PopGenCore.jl directly, you will need to call it with PopGenCore.write. Additional keyword arguments kwargs... are specific to the intended file type, and are listed in the docstrings of the specific file writer with the format ?filetype like shown above. For example, to find the appropriate keywords for a conversion to Genepop format, call up the docstring to genepop with ?genepop. Examples cats = @nancycats; fewer_cats = omit(cats, names = samplenames(cats)[1:10]); PopGen.write(fewer_cats, filename = &quot;filtered_nancycats.gen&quot;, digits = 3, format = &quot;horizontal&quot;) PopGen.write(fewer_cats, filename = &quot;filtered_nancycats.txt&quot;, digits = 4, format = &quot;tidy&quot;, delim = &quot;,&quot;)  "},{"title":"Variant Call Format","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/io/vcf","content":"","keywords":""},{"title":"Import a BCF/VCF file as PopData‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#import-a-bcfvcf-file-as-popdata","content":"vcf(infile::String; rename_loci::Bool, silent::Bool, allow_monomorphic::Bool) bcf(infile::String; rename_loci::Bool, silent::Bool, allow_monomorphic::Bool)  PopGen.jl provides the commands vcf and bcf to import a variant call format files into PopData. The reader also accepts files that are gzipped. "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#arguments","content":"infile::String : path to file, in quotes. must end in .gz if gzipped "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#keyword-arguments","content":"rename_loci::Bool: whether to simplify loci names to snp_# (default: false)allow_monomorphic::Bool : whether to keep monomorphic loci (default: false)silent::Bool : whether to print file information during import (default: false) "},{"title":"Example‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#example","content":"cabbage = bcf(&quot;/home/data/nappa_cabbage.bcf&quot;, rename_loci = true, silent = true) potato = vcf(&quot;/home/data/russet_potatoes.vcf.gz&quot;, allow_monomorphic = true)  "},{"title":"Mixed-Ploidy data‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#mixed-ploidy-data","content":"In the event your variant call file is for mixed-ploidy data (where ploidy is not the same across all samples, e.g. PoolSeq), you will need to perform an additional step after reading in your data as PopData to convert the .genodata.genotype column into a GenoArray: julia&gt; mydata = bcf(&quot;path/to/file.bcf&quot;, silent = true, rename_loci = true) ; julia&gt; mydata.genodata.genotype = mydata.genodata.genotype |&gt; Array{Union{Missing, NTuple}}  WIP The extra step required by mixed-ploidy data is a work in progress. Feel free to submit a PR if you have ideas! "},{"title":"Format‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#format","content":"Variant Call Format files follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a BCF/VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use Freebayes ourselves). Please open an issue if they do, or reach out to us on the community Slack. "},{"title":"Allele encodings‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#allele-encodings","content":"When converting to PopData, the nucleotides will be recoded according to the table below. Note that this system differs slightly from how PGDSpider2 recodes alleles (the 3 and 4 are switched). Base\tA\tT\tC\tGAllele\t1\t2\t3\t4 VCF Filtering Keep in mind, BCF/VCF files need to be filtered before importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to vcftools, bcftools, and vcflib to filter your sequence data. "},{"title":"What BCF/VCF files contain‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#what-bcfvcf-files-contain","content":"Due to the nature of the file format, importing variant call files will provide: sample namesploidy of each samplelocus namesgenotypes "},{"title":"What BCF/VCF files lack‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#what-bcfvcf-files-lack","content":"population informationgeographical coordinate information This means you will need to add that information separately afterwards. Location data (which is optional) can be added to the PopData with the locations! command. Population names (mandatory) can be added using populations!() "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Variant Call Format","url":"/PopGen.jl/docs/io/vcf#acknowledgements","content":"The heavy lifting of the BCF/VCF reader is thanks to the tremendous efforts of the contributors involved withGeneticVariation.jl, and its successor VariantCallFormat.jlwhich we use to parse files into PopData format. More specifically, the two packages use a file parser created from Automa.jl. If you love the file importer, then give those folks your thanks. If something is wrong and/or you hate the importer, blame us first (and please open up an issue üòÖ). "},{"title":"What's New","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/latest","content":"","keywords":""},{"title":"v0.8‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v08","content":""},{"title":"v0.8.0‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v080","content":"‚ö†Ô∏è‚ö†Ô∏è Breaking Changes‚Äã dropped support for Julia &lt;v1.6 new count methods we use aren't supported by previous versions ‚ú®‚ú® New Things‚Äã k-means clustering using Kmeans++ via kmeans()Principcal Component Analysis via pca()Jason and Pavel both completed their doctorates! ‚ö°‚ö° Improvements‚Äã allele matrix creation methods (internal) have &gt;50% fewer LOC and are &gt;2x faster! üêõüêõ Bug fixes‚Äã none, I think  "},{"title":"v0.7‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v07","content":""},{"title":"v0.7.0‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v070","content":"‚ö†Ô∏è‚ö†Ô∏è Breaking Changes‚Äã all PopData functionality moved to separate package PopGenCore.jlPopGen.jl reexports functions from PopGenCore.jl for familiar functionality.meta and .loci have been renamed .metadata and .genodata.metadata is no longer a DataFrame and instead a new PopDataInfo typelatitude and longitude columns no longer mandatory and omitted in cases where not used ‚ö°‚ö° Improvements‚Äã PopData can be indexed like a DataFrame and it will return a brand new PopData!PopDataInfo is self-updating (in most cases)preliminary plink .bed file importing (not writing, yet)show for PopData is now smaller and cleanerINFO text for data importing now elides abs paths longer than the terminal widthVCF/BCF support no longer lazy loadedVCF/BCF uses VariantCallFormat.jl now (instead of GeneticVariations.jl)VCF/BCF uses different GZ library for decompressiontry...catch blocks used in file io for faster file reading and fewer lines of code üêõüêõ Bug fixes‚Äã super slow structure io on larger files  "},{"title":"v.0.6‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v06","content":""},{"title":"v.0.6.5‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v065","content":"Summary of changes from 0.6.2-5 ‚ö°‚ö° Improvements‚Äã Bumped compat for DataFrames.jl to 1.0VCF/BCF importing now naturally sorts the loci names includes new NaturalSort.jl dep file import INFO text consolidated somewhatPopData show method information consolidated somehwat üêõüêõ Bug fixes‚Äã Hudson fst works as expectedisbiallelic returns correct answer when used on PopData object[internal] conditional functions moved to Conditionals.jl filekeep and keep! are exported "},{"title":"v.0.6.1‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v061","content":"‚ú®‚ú® New Features‚Äã Hudson pairwise FST &amp; Permutation adds the Hudson et al. 1992 method isbiallelic adds boolean test if a PopData object has only biallelic lociadds boolean test if a GenoArray is biallelic drop_multiallelic mutating and non-mutating methods to remove non-biallelic loci from a PopData object ‚ö°‚ö° Improvements‚Äã drop_monomorphic now uses the same logic as drop_multiallelic, which should make it faster and leaner üêõüêõ Bug fixes‚Äã vcf and bcf kwarg rename_loci now consistent in functions and docstringsgenerate_meta now uses a comprehension rather than deprecated map(fn, groupeddataframe) method  "},{"title":"v.0.5‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v05","content":""},{"title":"v.0.5.2‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v052","content":"‚ö°‚ö° Improvements‚Äã a rewrite of nei and weir-cockerham fst methods to be matrix-based (faster!) ‚ú®‚ú® New Features‚Äã fully implements permutation testing for both pairwise fst methodsadds method for avg_allele_freq to accommodate new pairwise_neiextends pairwise_fst to include iterations keyword to activate permutation testing "},{"title":"v.0.5.1‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v051","content":"‚ú®‚ú® New features‚Äã pairwise_fst is now available for Weir &amp; Cockerham (1984) and Nei (1987) methods check out the benchmarks! added skipinf, skipnan, and skipinfnan methods (unexported) to Utils.jldropped safemean because the skip___ methods are a lot faster and slimmer "},{"title":"v.0.5.0‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v050","content":"This release fixes a critical bug in all the file importing functions that returned nothing when dropping monomorphic loci. Other changes include Dropping JLD2.jl suport due to its version-to-version instability. Two fewer dependencies! As a result, datasets() now reads nancycats and gulfsharks directly from their source data filesTo maintain all of the information, gulfsharks reads from a delimited file rather than a genepop file populations type signature and behavior has been changed: the default returns an array of the unique population namesthe keyword listall::Bool has been replaced with counts::Bool, which now returns a dataframe of the number of samples per population  "},{"title":"v.0.4‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v04","content":""},{"title":"v0.4.5‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v045","content":"This release builds off of 0.4.3 and does a better job with the VCF loading logic. Along with that, vcf and bcf exist in the namespace before loading in GeneticVariation.jl, meaning you can always view the docstrings. These stripped-down methods in the namespace will give helpful errors to remind you to load in GeneticVariation.jl and/or GZip.jl. "},{"title":"v0.4.3‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v043","content":"This release fixes and simplifies the under-the-hood allele_freq, geno_freq, and geno_count_xxx functions. The are faster now, and they infer types, making the output have expected type behavior. Changes‚Äã You no longer need to import both GeneticVariations.jl and GZip.jl to have the vcf and bcf functions work. The reason is that if your file isn't gzipped, then why load in an unnecessary library? Therefore, if your file is gzipped, then you'll need to load in GZip.jl too, otherwise you just need GeneticVariation.jl. üÜíavg_allele_freq now has a different method, where the second positional argument is power, which will raise the calculated frequencies to the given value (default = 1). This simplifies having to do things like square the values of the resulting Dict. "},{"title":"v0.4.0‚Äã","type":1,"pageTitle":"What's New","url":"/PopGen.jl/docs/latest#v040","content":"This release adds a slew of relatedness estimators, which can be bootstrapped and are performed in parallel. Paired with release of PopGenSims.jl v0.0.2. ‚ö†Ô∏è‚ö†Ô∏è Breaking changes‚Äã CategoricalArrays replaced with PooledArraysVCF/BCF now lazy load and require GeneticVariations.jl and GZip.jl separately ‚ú®‚ú® New features‚Äã relatedness estimators (see blog for tutorial)internal functions: loci_dataframeloci_matrixnonmissingspairwise_pairs pairwiseidentical() to compare percent identical lociphase() methodStructure/fastStructure file IO ‚ö°‚ö° Improvements‚Äã some internal function locations moved around (housekeeping)nancycats() and gulfsharks() are being phased out in favor of @nancycats and @gulfsharks. (You will see deprecation warning)documentation (Docusaurus) upgrades edit button now correctly works on blog posts B/VCF reader rewritten (see docs) "},{"title":"The PopData type","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata","content":"","keywords":""},{"title":"Metadata‚Äã","type":1,"pageTitle":"The PopData type","url":"/PopGen.jl/docs/popdata#metadata","content":"The metadata component exists to frontload commonly used values like the number of populations and if the data is biallelicstore information about samples or loci that may be relevant in specific applicationsprovide flexibility in storing that information in wide format because storing it in long format would dramatically increase the size of PopData objectsprovide easy access to viewing sample or locus information See viewing data for a closer look at accessing this information. "},{"title":"Genodata‚Äã","type":1,"pageTitle":"The PopData type","url":"/PopGen.jl/docs/popdata#genodata","content":"The genotype information is stored in a separate table lovingly called genodata. This table is rather special in that it is stored in &quot;long&quot; format, i.e. one record per row. Storing data this way makes it a lot easier to interrogate the data and write new functions. It also means the table will have as many rows as loci x samples, which can become a lot. To reduce redundant objects inflating object size, the columns name, population, and locus are each a special type of compressed vector from PooledArrays.jl, which is a memory-saving data structure for long repetitive categorical data. Without using this format, gulfsharks, whose source file is 3.2mb, would occupy about 27mb in your RAM! The classes of .genodata can be directly accessed with PopData.genodata.colname where PopData is the name of your PopData object, and colname is one of name, population, locus, genotype. See Advanced Indexing for a deeper dive into manipulating genodata. immutable genotypes We use the Tuple type for genotypes of individuals because they are immutable (cannot be changed). By the time you're using PopGen.jl, your data should already be filtered and screened. Hand-editing of genotype alleles is strongly discouraged, so we outlawed it. "},{"title":"Other Data Types‚Äã","type":1,"pageTitle":"The PopData type","url":"/PopGen.jl/docs/popdata#other-data-types","content":"While not strictly their own composite types, we also define aliases for genotypes and vectors of genotypes, as their explicit types can get a little unwieldy to use. The types shown below in the code blocks include their name and type (all types are of type DataType) on the first line, and what the alias actually defines on the second line. "},{"title":"Genotype‚Äã","type":1,"pageTitle":"The PopData type","url":"/PopGen.jl/docs/popdata#genotype","content":"Genotype::DataType NTuple{N,&lt;:Signed} where N  An NTuple is itself an alias for a Tuple{Vararg{}} , but you can think of it as Tuple of N length composed of items of a particular type, in this case it's items that are subtypes of Signed (the integer types). The length of the tuple (N) will vary based on the ploidy of the sample, and the element Type will vary whether the markers are snps (Int8) or microsatellites (Int16), making this a pretty flexible (but immutable) structure. SNP and Msat‚Äã Snp::NTuple{N,Int8} where N Msat::NTuple{N,Int16} where N  These are convenience aliases for the two main kinds of NTuples of genotypes you will see. These are typically used internally. "},{"title":"GenoArray‚Äã","type":1,"pageTitle":"The PopData type","url":"/PopGen.jl/docs/popdata#genoarray","content":"GenoArray::DataType AbstractVector{S} where S&lt;:Union{Missing,Genotype}  As you can guess from the name, this Type wraps Genotype into a Vector, while permitting missing values (what's genetics without missing data!?). By using AbstractVector (rather than Vector), we also have the flexibility of functions working on things like SubArrays out of the box. why bother defining these aliases? Getting the most out of Julia and demonstrating good practices means making sure functions work on the things they're supposed to, and give informative error messages when the input isn't suitable for the function (a rare case of wanting MethodErrors). Without these aliases, functions would either have vague definitions like f(x,y,z) where x &lt;: AbstractArray and potentially cause errors, or overly complicated definitions like f(x::AbstractVector{S},y,z) where {N, T&lt;:Signed,S&lt;:NTuple{N,T}} and not be very legible. Instead, functions are written as f(x,y,z) where x&lt;:GenotypeArray, and that seems like a good compromise of getting the latter while looking like the former.  "},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"The PopData type","url":"/PopGen.jl/docs/popdata#acknowledgements","content":"A lot of what's possible in PopGen.jl is thanks to the tireless work of the contributors and maintainers of DataFrames.jl. It's no small task to come up with and maintain a robust, performant, and sensible tabular data type, and they deserve so much credit for it. "},{"title":"Adding sample/locus data","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/addingdata","content":"","keywords":""},{"title":"adding sampleinfo‚Äã","type":1,"pageTitle":"Adding sample/locus data","url":"/PopGen.jl/docs/popdata/addingdata#adding-sampleinfo","content":"sampleinfo!(::PopData, metadata::Pair{Symbol, Vector}; categorical::Bool = false) sampleinfo!(::PopData, metadata::Pair{String, Vector}; categorical::Bool = false)  Add an additional column sample information to PopData metadata. Mutates PopData in place. The new values must be in the same order as the samples in sampleinfo(popdata). "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Adding sample/locus data","url":"/PopGen.jl/docs/popdata/addingdata#arguments","content":"metadata : A Pair of :ColumnName =&gt; [Values] "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Adding sample/locus data","url":"/PopGen.jl/docs/popdata/addingdata#keyword-arguments","content":"categorical : Boolean of whether the metadata being added is categorical aka &quot;factors&quot; (default: false) Example cats = @nancycats ; sampleinfo!(cats, :whiskerlength =&gt; rand(metadata(cats).samples)) sampleinfo!(cats, &quot;tailcolor&quot; =&gt; rand([&quot;orange&quot;, &quot;brown&quot;], metadata(cats).samples), categorical = true) cats PopData{Diploid, 9 Microsatellite loci} Samples: 237 Populations: 17 Other Info: [&quot;whiskerlength&quot;, &quot;tailcolor&quot;]  "},{"title":"adding locus information‚Äã","type":1,"pageTitle":"Adding sample/locus data","url":"/PopGen.jl/docs/popdata/addingdata#adding-locus-information","content":"locusinfo!(::PopData, metadata::Pair{Symbol, Vector}; categorical::Bool = false) locusinfo!(::PopData, metadata::Pair{String, Vector}; categorical::Bool = false)  Add an additional locus information to PopData metadata. Mutates PopData in place. Metadata must be in the same order as the samples in locusinfo(PopData). "},{"title":"Arguments‚Äã","type":1,"pageTitle":"Adding sample/locus data","url":"/PopGen.jl/docs/popdata/addingdata#arguments-1","content":"metadata : A Pair of :ColumnName =&gt; [Values] "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Adding sample/locus data","url":"/PopGen.jl/docs/popdata/addingdata#keyword-arguments-1","content":"categorical : Boolean of whether the metadata being added is categorical aka &quot;factors&quot; (default: false) Example cats = @nancycats locusinfo!(cats, :quality =&gt; rand(metadata(cats).loci)) cats PopData{Diploid, 9 Microsatellite loci} Samples: 237 Populations: 17 Other Info: [&quot;quality&quot;]  "},{"title":"Advanced PopData Indexing","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/advancedindexing","content":"","keywords":""},{"title":"Basic conditional indexing‚Äã","type":1,"pageTitle":"Advanced PopData Indexing","url":"/PopGen.jl/docs/popdata/advancedindexing#basic-conditional-indexing","content":"Basic conditional indexing is a fancy way of saying &quot;pulling out specific information&quot;. Let's say we wanted to omit locus fca8. julia&gt; ncats[genodata(ncats).locus .!= &quot;fca8&quot;] PopData{Diploid, 8 Microsatellite loci} Samples: 237 Populations: 17  Or, maybe we only want loci fca8 and fca23. We use the ‚àà (\\in&lt;TAB&gt;) operator and wrap the loci in Ref() to keep the set from being broadcasted. julia&gt; ncats[genodata(ncats).locus .‚àà Ref([&quot;fca8&quot;, &quot;fca23&quot;])] PopData{Diploid, 2 Microsatellite loci} Samples: 237 Populations: 17  Perhaps we want only populations 1 through 5. Again, we bind the set in Ref() to prevent broadcasting over its elements. We also need to change the integers to strings because population names are always strings. julia&gt; ncats[genodata(ncats).population .‚àà Ref(string.(1:5))] PopData{Diploid, 9 Microsatellite loci} Samples: 82 Populations: 5  Maybe we just wanted to know the names of the samples in population 5. Although for something like this you can just as well index the sampleinfo dataframe. Note that we need to use unique here because the genodata table is in long-format, meaning there are as many occurances of each sample name as there are loci. julia&gt; ncats[genodata(ncats).population .== &quot;5&quot;, :name] |&gt; unique 15-element Vector{InlineStrings.String7}: &quot;N55&quot; &quot;N56&quot; &quot;N57&quot; &quot;N58&quot; &quot;N59&quot; &quot;N60&quot; &quot;N61&quot; &quot;N62&quot; &quot;N63&quot; &quot;N64&quot; &quot;N65&quot; &quot;N66&quot; &quot;N67&quot; &quot;N68&quot; &quot;N69&quot;  "},{"title":"Advanced conditional indexing‚Äã","type":1,"pageTitle":"Advanced PopData Indexing","url":"/PopGen.jl/docs/popdata/advancedindexing#advanced-conditional-indexing","content":"Just like in DataFrames.jl, we can chain conditions with a broadcasted &quot;and&quot; operator (.&amp;) and really pull out information of interest. This also works for a broadcasted &quot;or&quot; operator (.|). Something to keep in mind is that each statement needs to be wrapped in parentheses like: popdata[(statement1) .&amp; (statement2)]  Let's find all the samples in population 2 that are heterozygous for allele 133 in locus fca8 and return just a dataframe. Notice we are using the ishet method ishet(genotype, allele) and broadcasting it with ishet.() over an array of genotypes. julia&gt; gd = genodata(ncats) ; julia&gt; ncats[(gd.locus .== &quot;fca8&quot;) .&amp; (gd.population .== &quot;2&quot;) .&amp; (ishet.(gd.genotype, 133)), :] 6√ó4 DataFrame Row ‚îÇ name population locus genotype ‚îÇ String7‚Ä¶ String String Tuple‚Ä¶? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ N141 2 fca8 (129, 133) 2 ‚îÇ N142 2 fca8 (129, 133) 3 ‚îÇ N146 2 fca8 (129, 133) 4 ‚îÇ N151 2 fca8 (129, 133) 5 ‚îÇ N154 2 fca8 (133, 135) 6 ‚îÇ N155 2 fca8 (131, 133)  How about which samples are missing data for locus fca8? julia&gt; gd = genodata(ncats) ; julia&gt; ncats[(gd.locus .== &quot;fca8&quot;) .&amp; (ismissing.(gd.genotype)), :name] 20-element PooledArrays.PooledVector{InlineStrings.String7, UInt8, Vector{UInt8}}: &quot;N215&quot; &quot;N216&quot; &quot;N188&quot; &quot;N189&quot; &quot;N190&quot; &quot;N191&quot; &quot;N192&quot; ‚ãÆ &quot;N197&quot; &quot;N198&quot; &quot;N199&quot; &quot;N200&quot; &quot;N201&quot; &quot;N206&quot;  This should get you started on thinking of ways to explore your data üòÑ. "},{"title":"Conditionals and Logic","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/conditionals","content":"","keywords":""},{"title":"Homozygosity‚Äã","type":1,"pageTitle":"Conditionals and Logic","url":"/PopGen.jl/docs/popdata/conditionals#homozygosity","content":"ishom(locus::Genotype) ishom(locus::GenoArray)  This will return true if a genotype is homozygous. The GenoaArray version just broadcasts it across all the genotypes in an array, returning a vector of true or false. Example julia&gt; cats = @nancycats ; julia&gt; subset = cats[1:10, :genotype] 10-element Vector{Union{Missing, Tuple{Int16, Int16}}}: missing missing (135, 143) (133, 135) (133, 135) (135, 143) (135, 135) (135, 143) (137, 143) (135, 135) julia&gt; ishom(subset[3]) false julia&gt; ishom(subset) 10-element Vector{Bool}: 0 0 0 0 0 0 1 0 0 1  using skipmissing If you want to avoid missing genotypes, you can use skipmissing to ignore them. This also works for ishet. julia&gt; ishom(skipmissing(subset)) 8-element Vector{Bool}: 0 0 0 0 1 0 0 1  Another option is to check if a genotype is homozygous for a specific allele. To do that, we exploit Julia's multiple dispatch and use ishom again, but with different arguments. ishom(geno::Genotype, allele::Signed) ishom(genos::GenoArray, allele::Signed)  This will return true if the geno (or genos) is/are homozygous for the specified allele. Notice that when we query a genotype that doesn't contain that allele, it returns false. Example julia&gt; ishom(subset[3], 135) false julia&gt; ishom(subset[10], 135) true julia&gt; ishom(subset[9], 135) false julia&gt; ishom(subset, 135) 10-element Vector{Bool}: 0 0 0 0 0 0 1 0 0 1  "},{"title":"Heterozygosity‚Äã","type":1,"pageTitle":"Conditionals and Logic","url":"/PopGen.jl/docs/popdata/conditionals#heterozygosity","content":"ishet(locus::Genotype) ishet(locus::GenoArray)  This is the exact opposite of ishom, returning true if the genotype (or genotypes) is/are heterozygous. Example julia&gt; cats = @nancycats ; julia&gt; subset = cats[1:10, :genotype] 10-element Vector{Union{Missing, Tuple{Int16, Int16}}}: missing missing (135, 143) (133, 135) (133, 135) (135, 143) (135, 135) (135, 143) (137, 143) (135, 135) julia&gt; ishet(subset[3]) true julia&gt; ishet(subset) 10-element Vector{Bool}: 0 0 1 1 1 1 0 1 1 0  We likewise have the option to check if a locus is heterozygous for a specific allele. To do that, we again exploit Julia's multiple dispatch and use ishet, but with different arguments. ishet(geno::Genotype, allele::Signed) ishet(genos::GenoArray, allele::Signed)  This will return true if the geno (or genos) is/are heterozygous for the specified allele. Notice that when we query a genotype that doesn't contain that allele, it returns false. Example julia&gt; ishet(subset[3], 135) true julia&gt; ishet(subset[10], 135) false julia&gt; ishet(subset[9], 135) true julia&gt; ishet(subset, 135) 10-element Vector{Bool}: 0 0 1 1 1 1 0 1 0 0  "},{"title":"Biallelic data‚Äã","type":1,"pageTitle":"Conditionals and Logic","url":"/PopGen.jl/docs/popdata/conditionals#biallelic-data","content":"Some analyses are restricted to work exclusively on biallelic data (e.g. Hudson pairwise FST), so it may help to know if things are biallelic. isbiallelic(data::GenoArray)  Returns true if the GenoArray is biallelic, false if not. isbiallelic(data::PopData)  Returns true all the loci in the PopData are biallelic, false if not. Example julia&gt; sharks = @gulfsharks ; julia&gt; isbiallelic(sharks) false julia&gt; drop_multiallelic!(sharks) [ Info: Removing 258 multialleic loci julia&gt; isbiallelic(sharks) true  "},{"title":"Data exclusion","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/exclusion","content":"","keywords":""},{"title":"Exclude certain things‚Äã","type":1,"pageTitle":"Data exclusion","url":"/PopGen.jl/docs/popdata/exclusion#exclude-certain-things","content":"exclude(data::PopData, kwargs...) omit(data::PopData, kwargs...) remove(data::PopData, kwargs...)  Returns a new PopData object without the criteria provided. Input can be a single item or, or an array of items. You will be informed you if your criteria were not found in the PopData. Using standard Julia conventions, exclude() will create a copy of your PopData excluding the specific criteria, whereas exclude!() will edit the input PopData in-place. "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Data exclusion","url":"/PopGen.jl/docs/popdata/exclusion#keyword-arguments","content":"Everything gets converted to string, so Symbol works too if you want to cut down on keystrokes. Integers work too if things are named &quot;1&quot;, &quot;2&quot;, etc. locus::Union{String, Vector{String}}: locus or loci you want to remove from the PopDatapopulation::Union{String, Vector{String}}: population(s) you want to remove from the PopDataname::Union{String, Vector{String}}: sample(s) you want to remove from the PopData sampleslocipopulationscombination julia&gt; fewer_sharks = exclude(sharks, name = &quot;cc_001&quot;) PopData{Diploid, 2209 SNP loci} Samples: 211 Populations: 7 Other info: [&quot;longitude&quot;, &quot;latitude&quot;] julia&gt; lots_fewer_sharks = remove(sharks, name = [&quot;cc_001&quot;, &quot;cc_002&quot;, &quot;cc_003&quot;]) PopData{Diploid, 2209 SNP loci} Samples: 209 Populations: 7 Other info: [&quot;longitude&quot;, &quot;latitude&quot;]  The in-place variant exclude!() follows all the same syntax as exclude(), therefore all examples above would be identical for exclude!(). alias functions The exclusion commands are interchangeable with omit and remove, both with and without the bang (!). This was done so you can use the function comfortably without needing to remember the specific name to perform it. Maybe you just prefer the wordomit to remove. We're not here to judge. The examples below use any combination of omit, remove, and exclude. "},{"title":"Keep only certain things‚Äã","type":1,"pageTitle":"Data exclusion","url":"/PopGen.jl/docs/popdata/exclusion#keep-only-certain-things","content":"keep(data::PopData, kwargs...)  Returns a new PopData object keeping only the occurrences of the specified keyword. All values are converted to String for filtering, so Symbol and numbers will also work. "},{"title":"Keyword Arguments‚Äã","type":1,"pageTitle":"Data exclusion","url":"/PopGen.jl/docs/popdata/exclusion#keyword-arguments-1","content":"locus::Union{String, Vector{String}}: locus or loci you want to keep in the PopDatapopulation::Union{String, Vector{String}}: population(s) you want to keep in the PopDataname::Union{String, Vector{String}}: sample(s) you want to keep in the PopData. Examples cats = @nancycats; keep(cats, population = 1:5) keep(cats, name = [&quot;N100&quot;, &quot;N102&quot;, &quot;N211&quot;]) keep(cats, locus = [:fca8, &quot;fca37&quot;])  "},{"title":"Remove monomorphic loci‚Äã","type":1,"pageTitle":"Data exclusion","url":"/PopGen.jl/docs/popdata/exclusion#remove-monomorphic-loci","content":"While included in the file parsers by default, you may want to do this manually withdropmonomorphic, which returns a new PopData object excluding any monomorphic loci. You can use the mutable version dropmonomorphic! to edit a PopData object in-place. dropmonomorphic(::PopData) dropmonomorphic!(::PopData)  "},{"title":"Remove multiallelic markers‚Äã","type":1,"pageTitle":"Data exclusion","url":"/PopGen.jl/docs/popdata/exclusion#remove-multiallelic-markers","content":"If your data isn't biallelic, you may want to remove multi-allelic markers for certain analyses (for example, the Hudson pairwise FST method requires biallelic data). For that we have dropmultiallelic, which returns a newPopData object, and the mutable version dropmultiallelic!, which edits a PopData object in-place. dropmultiallelic(::PopData) dropmultiallelic(::PopData)  Example julia&gt; sharks = @gulfsharks PopData{Diploid, 2209 SNP loci} Samples: 212 Populations: 7 Other info: [&quot;longitude&quot;, &quot;latitude&quot;] julia&gt; dropmultiallelic(sharks) [ Info: Removing 258 multialleic loci PopData{Diploid, 1951 SNP loci} Samples: 212 Populations: 7 Other info: [&quot;longitude&quot;, &quot;latitude&quot;]  "},{"title":"Data Exploration","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/dataexploration","content":"","keywords":""},{"title":"Allele frequency table‚Äã","type":1,"pageTitle":"Data Exploration","url":"/PopGen.jl/docs/popdata/dataexploration#allele-frequency-table","content":"allelefreqtable(data::PopData; by::Union{String, Symbol} = &quot;global&quot;)  Return a table of the observed global (default) or population allele frequencies in a PopData object. Use this if you want to see what the frequencies are for every allele at every locus. globalpopulation julia&gt; cats = @nancycats ; julia&gt; allelefreqtable(cats) 108√ó4 DataFrame Row ‚îÇ locus allele count frequency ‚îÇ String Int16? Int64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 135 105 0.241935 2 ‚îÇ fca8 143 44 0.101382 3 ‚îÇ fca8 133 33 0.0760369 4 ‚îÇ fca8 137 83 0.191244 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 105 ‚îÇ fca37 226 2 0.00421941 106 ‚îÇ fca37 216 7 0.0147679 107 ‚îÇ fca37 224 2 0.00421941 108 ‚îÇ fca37 204 6 0.0126582 100 rows omitted  "},{"title":"Genotype frequency table‚Äã","type":1,"pageTitle":"Data Exploration","url":"/PopGen.jl/docs/popdata/dataexploration#genotype-frequency-table","content":"genofreqtable(data::PopData; by::Union{String, Symbol} = &quot;global&quot;)  Return a table of the observed global (default) or population genotype frequencies in a PopData object. Use this if you want to see what the frequencies are for every genotype at every locus. globalpopulation julia&gt; cats = @nancycats ; julia&gt; genofreqtable(cats) 341√ó4 DataFrame Row ‚îÇ locus genotype count frequency ‚îÇ String Tuple‚Ä¶ Int64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 (135, 143) 16 0.0737327 2 ‚îÇ fca8 (133, 135) 9 0.0414747 3 ‚îÇ fca8 (135, 135) 23 0.105991 4 ‚îÇ fca8 (137, 143) 8 0.0368664 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 338 ‚îÇ fca37 (206, 220) 1 0.00421941 339 ‚îÇ fca37 (208, 218) 1 0.00421941 340 ‚îÇ fca37 (184, 184) 3 0.0126582 341 ‚îÇ fca37 (208, 210) 3 0.0126582 333 rows omitted  "},{"title":"Missing Data‚Äã","type":1,"pageTitle":"Data Exploration","url":"/PopGen.jl/docs/popdata/dataexploration#missing-data","content":"missingdata(data::PopData; by::Union{String, Symbol} = &quot;sample&quot;)  Get missing genotype information in a PopData object. Specify a mode of operation using the by = keyword to return a table corresponding with that missing information type. by\twhat it does&quot;sample&quot;\treturns a count of missing loci per individual (default) &quot;population&quot;\treturns a count of missing genotypes per population &quot;locus&quot;\treturns a count of missing genotypes per locus &quot;locusxpopulation&quot;\treturns a count of missing genotypes per locus per population samplepopulationlocuslocusxpopulation julia&gt; sharks = @gulfsharks ; julia&gt; missingdata(sharks) 212√ó2 DataFrame Row ‚îÇ name missing ‚îÇ String Int64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ cc_001 124 2 ‚îÇ cc_002 94 3 ‚îÇ cc_003 100 4 ‚îÇ cc_005 0 5 ‚îÇ cc_007 2 6 ‚îÇ cc_008 1 7 ‚îÇ cc_009 2 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ 206 ‚îÇ seg_025 0 207 ‚îÇ seg_026 0 208 ‚îÇ seg_027 2 209 ‚îÇ seg_028 25 210 ‚îÇ seg_029 0 211 ‚îÇ seg_030 1 212 ‚îÇ seg_031 1 198 rows omitted  "},{"title":"Pairwise Identical Genotypes‚Äã","type":1,"pageTitle":"Data Exploration","url":"/PopGen.jl/docs/popdata/dataexploration#pairwise-identical-genotypes","content":"While not a substitute for a kinship analysis, it may be useful to know or verify how similar your data are in a very literal sense: how many identical genotypes do two individuals have across all loci? To do this, we use pairwiseidentical() to perform an all x all comparison of identical genotypes. This can be done for all individuals in a PopData object, or restricted to a specific set of individuals: all samplessome samples julia&gt; cats = @nancycats; julia&gt; pairwiseidentical(cats) 27966√ó4 DataFrame Row ‚îÇ sample_1 sample_2 identical n ‚îÇ String String Float64 Int64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ N215 N216 0.5 8 2 ‚îÇ N215 N217 0.25 8 3 ‚îÇ N215 N218 0.38 8 4 ‚îÇ N215 N219 0.38 8 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 27963 ‚îÇ N297 N290 0.29 7 27964 ‚îÇ N281 N289 0.25 8 27965 ‚îÇ N281 N290 0.43 7 27966 ‚îÇ N289 N290 0.14 7 27958 rows omitted  "},{"title":"Allelic Richness‚Äã","type":1,"pageTitle":"Data Exploration","url":"/PopGen.jl/docs/popdata/dataexploration#allelic-richness","content":"If you were curious about allelic richness (number of alleles per locus), then you can use richness() to find that out. Use by = &quot;population&quot; to return a table by locus by population. by locusby locusxpopulation julia&gt; cats = @nancycats; julia&gt; richness(cats) 9√ó2 DataFrame Row ‚îÇ locus richness ‚îÇ String Int64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ fca8 16 2 ‚îÇ fca23 11 3 ‚îÇ fca43 10 4 ‚îÇ fca45 9 5 ‚îÇ fca77 12 6 ‚îÇ fca78 8 7 ‚îÇ fca90 12 8 ‚îÇ fca96 12 9 ‚îÇ fca37 18  "},{"title":"Average Number of Alleles‚Äã","type":1,"pageTitle":"Data Exploration","url":"/PopGen.jl/docs/popdata/dataexploration#average-number-of-alleles","content":"Similar to richness, if you wanted to know the average number of alleles per locus, use alleleavg(). Use rounding = false if you don't want the answer rounded to 4 decimal places. julia&gt; alleleavg(@nancycats) (mean = 12.0, stdev = 0.2668) julia&gt; alleleavg(@nancycats, rounding = false) (mean = 12.0, stdev = 0.2667968432263687)  "},{"title":"Summary Statistics‚Äã","type":1,"pageTitle":"Data Exploration","url":"/PopGen.jl/docs/popdata/dataexploration#summary-statistics","content":"Population genetics famously includes all manner of coefficients with which to summarize data. Use summary() to view FST, DST, HT, etc. (like Hierfstat::basic.stats). globalby locus julia&gt; summary(@nancycats) 1√ó10 DataFrame Row ‚îÇ Het_obs HS HT DST HT‚Ä≤ DST‚Ä≤ FST FST‚Ä≤ FIS DEST ‚îÇ Float64 Float64 Float64 Float64 Float64 Float64 Float64 Float64 Float64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ 0.6299 0.7083 0.7717 0.0634 0.7757 0.0674 0.0821 0.0869 0.1108 0.231  prime symbol The column names above use the unicode prime symbol ‚Ä≤ to better reflect the actual coefficient (&quot;FST prime&quot; etc.). To print that character, press \\prime&lt;TAB&gt;, which reads &quot;backslash, the word 'prime', and the TAB button&quot;. "},{"title":"Location data","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/locationdata","content":"","keywords":""},{"title":"View location data‚Äã","type":1,"pageTitle":"Location data","url":"/PopGen.jl/docs/popdata/locationdata#view-location-data","content":"locationdata(data::PopData)  View location (if present) data in a PopData, returning a table the longitude and latitude information in the metadata. julia&gt; locationdata(sharks) 212√ó2 SubDataFrame Row ‚îÇ longitude latitude ‚îÇ Float64 Float64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ 28.3062 -80.5993 2 ‚îÇ 28.3079 -80.5995 3 ‚îÇ 28.3023 -80.5996 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ 210 ‚îÇ 30.0522 -87.3662 211 ‚îÇ 29.8234 -85.7143 212 ‚îÇ 29.8234 -85.7143 206 rows omitted  "},{"title":"Add geographical coordinates‚Äã","type":1,"pageTitle":"Location data","url":"/PopGen.jl/docs/popdata/locationdata#add-geographical-coordinates","content":""},{"title":"decimal minutes‚Äã","type":1,"pageTitle":"Location data","url":"/PopGen.jl/docs/popdata/locationdata#decimal-minutes","content":"locationdata!(data::PopData; longitude::Vector{T}, latitude::Vector{T}) where T&lt;:AbstractFloat  Location data can be added using one of the methods of locations!. As indicated by the bang !, your PopData will be edited in place, and there will be no return output. If your data is in anything other than Decimal-Degrees format, this function will convert your long/lat into Decimal Degrees. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. The functions accept keywords longitude and latitude, or can be used without them so long as the vectors are input in that order. This method is pretty straightforward and tolerates vectors with missing data. formatting requirements‚Äã Coordinates must be decimal-minutes as either Float32 or Float64 (e.g. -21.321) # generate some fake location data julia&gt; long = rand(212) .* 10 ; lat = rand(212) .* -10 julia&gt; locationdata!(sharks, long, lat)  "},{"title":"other formats‚Äã","type":1,"pageTitle":"Location data","url":"/PopGen.jl/docs/popdata/locationdata#other-formats","content":"locationdata!(data::PopData; longitude::Vector{String}, latitude::Vector{String})  formatting requirements‚Äã Coordinates as String separated by spaces (&quot;11 43 41&quot;) or colons (&quot;11:43:41&quot;)Must use negative sign (&quot;-11 43.52&quot;) or single-letter cardinal direction (&quot;11 43.52W&quot;)Missing data should be coded as missing or the string &quot;missing&quot;Can mix colons and spaces (although it's bad practice) If not already in decimal-minutes format, it would likely be most convenient if you imported your coordinate data as vectors of strings, which would look something like this: longitude = [&quot;-43 54 11&quot;, &quot;22 23 11N&quot;] latitude = [&quot;11 44 31&quot;, &quot;-25 41 13&quot;]  Missing values This method tolerates missing values, but you will need to replace! instances of missing with the string &quot;missing&quot;. "},{"title":"Population data","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/populationdata","content":"","keywords":""},{"title":"View unique population names‚Äã","type":1,"pageTitle":"Population data","url":"/PopGen.jl/docs/popdata/populationdata#view-unique-population-names","content":"populations(data::PopData; counts::Bool = false)  If counts = false, returns a Vector of the unique populations present in the PopData. If counts = true, returns a table of sample counts per population. unique populationscounts per population Return a vector of the unique populations. julia&gt; populations(sharks) 7-element Array{String,1}: &quot;CapeCanaveral&quot; &quot;Georgia&quot; &quot;SouthCarolina&quot; &quot;FloridaKeys&quot; &quot;MideastGulf&quot; &quot;NortheastGulf&quot; &quot;SoutheastGulf&quot;  "},{"title":"Rename populations‚Äã","type":1,"pageTitle":"Population data","url":"/PopGen.jl/docs/popdata/populationdata#rename-populations","content":"populations!(data::PopData, rename::Dict) populations!(data::PopData, rename::Vector{String}) populations!(data::PopData, samples::Vector{String}, populations::Vector{String})  There are a handful of methods to alter PopData population names depending on what you find most convenient. Each of these methods start with populations!() and vary in their inputs. It's for that reason this function has an uncharacteristically long docstring. However, all the methods for populations! are unified in that they edit PopData in place. with a Dictionarywith a Vector of namesreassign by sample populations!(data::PopData, rename::Dict) tip Recommended for renaming existing populations Rename existing population ID's of PopData using a Dict ofpopulation_name =&gt; replacement. # create a dictionary of name conversions julia&gt; new_popnames = Dict( &quot;CapeCanaveral&quot; =&gt; &quot;Atlantic&quot;, &quot;Georgia&quot; =&gt; &quot;Atlantic&quot;, &quot;SouthCarolina&quot; =&gt; &quot;Atlantic&quot;, &quot;FloridaKeys&quot; =&gt; &quot;Gulf&quot;, &quot;MideastGulf&quot; =&gt; &quot;Gulf&quot;, &quot;NortheastGulf&quot; =&gt; &quot;Gulf&quot;, &quot;SoutheastGulf&quot; =&gt; &quot;Gulf&quot; ); julia&gt; populations!(sharks, new_popnames) julia&gt; populations(sharks, counts = true) 2√ó2 DataFrame Row ‚îÇ population count ‚îÇ String Int64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ Atlantic 79 2 ‚îÇ Gulf 133  "},{"title":"Simulating Samples","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/simulations","content":"","keywords":""},{"title":"Simulate samples within populations‚Äã","type":1,"pageTitle":"Simulating Samples","url":"/PopGen.jl/docs/simulations#simulate-samples-within-populations","content":"simulate(data::PopData; n::Int) simulate(data::PopData; n::Dict{String,Int}) simulate(data::PopData; scale::Int)  Simulate data using per-population allele frequencies. The simulated samples will have the naming convention sim_1...sim_# where # is the total number of simulated samples in the new PopData. fixed samplesarbitrary samplesproportional samples simulate(data::PopData; n::Int) If you want to simulate data with a fixed number of individuals per population, you can do so with simulate(PopData, n = Int), which takes a PopData object and simulates n number of individuals per population. Returns a new PopData with samples having the same ploidy as the source PopData, but will not work on mixed-ploidy data. In the example below, we simulate 100 individuals per population using the nancycats data, which has 17 populations, therefore the resulting PopData will have 1700 samples (100 samples x 17 populations). Example julia&gt; cats = @nancycats; julia&gt; sims = simulate(cats , n = 100) PopData{Diploid, 9 Microsatellite loci} Samples: 1700 Populations: 17  "},{"title":"Viewing data","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/popdata/viewdata","content":"","keywords":""},{"title":"Loading in the data‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#loading-in-the-data","content":"Let's keep things simple by loading in the nancycats data and calling it ncats. julia&gt; ncats = @nancycats PopData{Diploid, 9 Microsatellite loci} Samples: 237 Populations: 17  Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopData. The DataFrames uses the convention dataframe.colname to directly access the columns we want. "},{"title":"The metadata (data about the data)‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#the-metadata-data-about-the-data","content":"Some critical information about the data is front-loaded into a PopData object to eliminate constantly getting these values in calculations. To view this information, use metadata(). julia&gt; metadata(ncats) ploidy: 2 loci: 9 samples: 237 populations: 17 biallelic: false  Included in metadata are two DataFrames, one for sample information, and another for locus information. sample informationlocus information sampleinfo‚Äã To view the sample information, you can use sampleinfo() julia&gt; sampleinfo(ncats) 237√ó3 DataFrame Row ‚îÇ name population ploidy ‚îÇ String7‚Ä¶ String Int8 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ N217 1 2 2 ‚îÇ N218 1 2 3 ‚îÇ N219 1 2 4 ‚îÇ N220 1 2 5 ‚îÇ N221 1 2 6 ‚îÇ N222 1 2 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ 232 ‚îÇ N197 14 2 233 ‚îÇ N198 14 2 234 ‚îÇ N199 14 2 235 ‚îÇ N200 14 2 236 ‚îÇ N201 14 2 237 ‚îÇ N206 14 2 222 rows omitted Using the standard DataFrames getindex methods, we can access these columns like so: julia&gt; sinfo = sampleinfo(ncats) ; julia&gt; sinfo.name 237-element Array{String,1}: &quot;N1&quot; &quot;N2&quot; &quot;N3&quot; &quot;N4&quot; &quot;N5&quot; &quot;N6&quot; &quot;N7&quot; &quot;N8&quot; ‚ãÆ &quot;N230&quot; &quot;N231&quot; &quot;N232&quot; &quot;N233&quot; &quot;N234&quot; &quot;N235&quot; &quot;N236&quot; &quot;N237&quot;   "},{"title":"The genotype table‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#the-genotype-table","content":""},{"title":"genodata‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#genodata","content":"You can view the genotype information with genodata(). julia&gt; genodata(ncats) 2133√ó4 DataFrame Row ‚îÇ name population locus genotype ‚îÇ String String String Tuple‚Ä¶? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ N215 1 fca8 missing 2 ‚îÇ N216 1 fca8 missing 3 ‚îÇ N217 1 fca8 (135, 143) 4 ‚îÇ N218 1 fca8 (133, 135) 5 ‚îÇ N219 1 fca8 (133, 135) 6 ‚îÇ N220 1 fca8 (135, 143) ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ ‚ãÆ 2128 ‚îÇ N295 17 fca37 (208, 208) 2129 ‚îÇ N296 17 fca37 (208, 220) 2130 ‚îÇ N297 17 fca37 (208, 208) 2131 ‚îÇ N281 17 fca37 (208, 208) 2132 ‚îÇ N289 17 fca37 (208, 208) 2133 ‚îÇ N290 17 fca37 (208, 208) 2121 rows omitted  Because the genotype data is in long format (aka &quot;tidy&quot;), accessing genotypes in a meaningful way is fairly straightforward if you have any experience with dataframe manipulation. For a deeper look into indexing PopData, read Advanced PopData Indexing The functions here help you inspect your PopData and pull information from it easily. "},{"title":"View specific information‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#view-specific-information","content":""},{"title":"sample names‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#sample-names","content":"samplenames(data::PopData)  View individual/sample names in a PopData. julia&gt; samplenames(sharks) 212-element Array{String,1}: &quot;cc_001&quot; &quot;cc_002&quot; &quot;cc_003&quot; &quot;cc_005&quot; &quot;cc_007&quot; ‚ãÆ &quot;seg_027&quot; &quot;seg_028&quot; &quot;seg_029&quot; &quot;seg_030&quot; &quot;seg_031&quot;  "},{"title":"locus names‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#locus-names","content":"loci(data::PopData)  Returns a vector of strings of the loci names in a PopData julia&gt; loci(sharks) 2213-element Array{String,1}: &quot;contig_35208&quot; &quot;contig_23109&quot; &quot;contig_4493&quot; &quot;contig_10742&quot; &quot;contig_14898&quot; ‚ãÆ &quot;contig_43517&quot; &quot;contig_27356&quot; &quot;contig_475&quot; &quot;contig_19384&quot; &quot;contig_22368&quot; &quot;contig_2784&quot;  "},{"title":"View genotypes‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#view-genotypes","content":""},{"title":"all genotypes in one locus or sample‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#all-genotypes-in-one-locus-or-sample","content":"genotypes(data::PopData, samplelocus::String)  Returns a vector (view) of genotypes for a locus, or sample, depending on which the function finds in your data. Don't worry too much about the wild type signature of the return vector. julia&gt; genotypes(sharks, &quot;contig_2784&quot;) 212-element view(::PooledArrays.PooledVector{Union{Missing, Tuple{Int8, Int8}}, UInt8, Vector{UInt8}}, [468097, 468098, 468099, 468100, 468101, 468102, 468103, 468104, 468105, 468106 ‚Ä¶ 468299, 468300, 468301, 468302, 468303, 468304, 468305, 468306, 468307, 468308]) with eltype Union{Missing, Tuple{Int8, Int8}}: (1, 1) (1, 1) (1, 1) ‚ãÆ (1, 1) (1, 1) (1, 1) julia&gt; genotypes(sharks, &quot;cc_001&quot;) 2209-element view(::PooledArrays.PooledVector{Union{Missing, Tuple{Int8, Int8}}, UInt8, Vector{UInt8}}, [1, 213, 425, 637, 849, 1061, 1273, 1485, 1697, 1909 ‚Ä¶ 466189, 466401, 466613, 466825, 467037, 467249, 467461, 467673, 467885, 468097]) with eltype Union{Missing, Tuple{Int8, Int8}}: (1, 2) (1, 1) (1, 2) ‚ãÆ (2, 2) (1, 1) (1, 1)  "},{"title":"one sample, one locus‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#one-sample-one-locus","content":"genotype(data::PopData, sample::String =&gt; locus::String)  Returns the genotype of the sample at the locus. Uses Pair notation. julia&gt; genotype(sharks, &quot;cc_001&quot; =&gt; &quot;contig_2784&quot;) (1, 1)  "},{"title":"many samples, one locus‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#many-samples-one-locus","content":"genotype(data::PopData, samples::Vector{String} =&gt; loci::String)  Returns a subdataframe of the genotypes of the samples at the locus. Uses Pair notation. julia&gt; genotypes(sharks, samplenames(sharks)[1:3] =&gt; &quot;contig_2784&quot;) 3√ó4 SubDataFrame Row ‚îÇ name population locus genotype ‚îÇ String7 String String Tuple‚Ä¶? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ cc_001 CapeCanaveral contig_2784 (1, 1) 2 ‚îÇ cc_002 CapeCanaveral contig_2784 (1, 1) 3 ‚îÇ cc_003 CapeCanaveral contig_2784 (1, 1)  "},{"title":"one sample, many loci‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#one-sample-many-loci","content":"genotype(data::PopData, sample::String =&gt; loci::Vector{String})  Returns a subdataframe of the genotypes of the sample at the loci. Uses Pair notation. julia&gt; genotypes(sharks, &quot;cc_001&quot; =&gt; loci(sharks)[1:3]) 3√ó4 SubDataFrame Row ‚îÇ name population locus genotype ‚îÇ String7 String String Tuple‚Ä¶? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ cc_001 CapeCanaveral contig_35208 (1, 2) 2 ‚îÇ cc_001 CapeCanaveral contig_23109 (1, 1) 3 ‚îÇ cc_001 CapeCanaveral contig_4493 (1, 2)  "},{"title":"many samples, many loci‚Äã","type":1,"pageTitle":"Viewing data","url":"/PopGen.jl/docs/popdata/viewdata#many-samples-many-loci","content":"genotype(data::PopData, samples::Vector{String} =&gt; loci::Vector{String})  Returns a subdataframe of the genotypes of the samples at the loci. Uses Pair notation. julia&gt; genotypes(sharks, samplenames(sharks)[1:3] =&gt; loci(sharks)[1:3]) 9√ó4 SubDataFrame Row ‚îÇ name population locus genotype ‚îÇ String7 String String Tuple‚Ä¶? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ cc_001 CapeCanaveral contig_35208 (1, 2) 2 ‚îÇ cc_002 CapeCanaveral contig_35208 (1, 2) 3 ‚îÇ cc_003 CapeCanaveral contig_35208 (1, 1) 4 ‚îÇ cc_001 CapeCanaveral contig_23109 (1, 1) 5 ‚îÇ cc_002 CapeCanaveral contig_23109 (1, 2) 6 ‚îÇ cc_003 CapeCanaveral contig_23109 missing 7 ‚îÇ cc_001 CapeCanaveral contig_4493 (1, 2) 8 ‚îÇ cc_002 CapeCanaveral contig_4493 (1, 1) 9 ‚îÇ cc_003 CapeCanaveral contig_4493 (1, 1)  "},{"title":"Simulate Sibling Pairs","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/simulations/sibship_simulations","content":"","keywords":""},{"title":"Relationship‚Äã","type":1,"pageTitle":"Simulate Sibling Pairs","url":"/PopGen.jl/docs/simulations/sibship_simulations#relationship","content":"Simulated parents will be crossed to generate samples depending on the relationship: relationship\t# parents\t# offspring\treturnsfullsib\t2\t2 full siblings\t2 offspring halfsib\t3\t2 half siblings\t2 offspring unrelated\t-\t-\t2 randomly generated individuals parentoffspring\t2\t1 offspring\t1 parent + 1 offspring "},{"title":"Identifying pairs‚Äã","type":1,"pageTitle":"Simulate Sibling Pairs","url":"/PopGen.jl/docs/simulations/sibship_simulations#identifying-pairs","content":"The relationship between the newly generated samples can be identified by: Sample names will specify their simulation number, relationship, and whether parent or offspring Naming convention: [simulation #]_[relationship]_[offspring #]example: sim005_fullsib_1 = [simulation 005]_[full sibling]_[offspring 1] Their population name will be that of their relationship (e.g. &quot;fullsib&quot;) plugging into relatedness The kinship function will recognize the population names output from simulating siblingship and only estimate relatedness for the appropriate pairs. If you need this functionality, you are strongly discouraged from manually editing the resulting PopData from simulatekin. "},{"title":"Ploidy‚Äã","type":1,"pageTitle":"Simulate Sibling Pairs","url":"/PopGen.jl/docs/simulations/sibship_simulations#ploidy","content":"By default, the ploidy of the simulated parents and offspring are inferred from the supplied PopData. adjusting ploidy If you have mixed-ploidy data or wish to generate parents and offspring of a ploidy different than the sourcePopData you can specify the ploidy with which to simulate parents and offspring. For example, if your PopDatais diploid, but you wish to generate triploid or octoploid parents and offspring, you would specify ploidy = 3or ploidy = 8 repectively. Odd ploidy‚Äã If trying to create offspring with an odd ploidy (3, 5, etc.), each parent has a 50% chance of contributing (¬Ω √ó ploidy) + 1 alleles for all loci to the offspring. In other words, if ploidy = 3, there's a 50% chance parent_1 will give 2 alleles for every locus for that simulated cross. "},{"title":"Example‚Äã","type":1,"pageTitle":"Simulate Sibling Pairs","url":"/PopGen.jl/docs/simulations/sibship_simulations#example","content":"julia&gt; cats = @nanycats ; julia&gt; cat_sims = simulatekin(cats, fullsib = 10, halfsib = 50) PopData{Diploid, 9 Microsatellite loci} Samples: 120 Populations: 2 julia&gt; cat_sims.sampleinfo 120√ó3 DataFrame Row ‚îÇ name population ploidy ‚îÇ String String Int64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 ‚îÇ sim01_fullsib_1 fullsib 2 2 ‚îÇ sim01_fullsib_2 fullsib 2 3 ‚îÇ sim02_fullsib_1 fullsib 2 4 ‚îÇ sim02_fullsib_2 fullsib 2 5 ‚îÇ sim03_fullsib_1 fullsib 2 6 ‚îÇ sim03_fullsib_2 fullsib 2 ‚ãÆ ‚îÇ ‚ãÆ ‚ãÆ ‚ãÆ 115 ‚îÇ sim48_halfsib_1 halfsib 2 116 ‚îÇ sim48_halfsib_2 halfsib 2 117 ‚îÇ sim49_halfsib_1 halfsib 2 118 ‚îÇ sim49_halfsib_2 halfsib 2 119 ‚îÇ sim50_halfsib_1 halfsib 2 120 ‚îÇ sim50_halfsib_2 halfsib 2 108 rows omitted  "},{"title":"Simulate Breeding Crosses","type":0,"sectionRef":"#","url":"/PopGen.jl/docs/simulations/breedingcrosses","content":"","keywords":""},{"title":"Perform a cross‚Äã","type":1,"pageTitle":"Simulate Breeding Crosses","url":"/PopGen.jl/docs/simulations/breedingcrosses#perform-a-cross","content":"cross(::PopData, parent1::String, parent2::String; n::Int, generation::String)  The cross function performs a simple parental cross from individuals parent1 and parent2 in the same PopData object. The parents are strings of the names of the parents in the PopData. The keyword argument n is the number of offspring to produce, and generation is a keyword argument for the population name to the assign the offspring (default: &quot;F1&quot;). Example‚Äã julia&gt; cats = @nancycats; julia&gt; f1 = cross(cats, &quot;N111&quot;, &quot;N107&quot;, n = 100000) PopData{Diploid, 9 Microsatellite loci} Samples: 100000 Populations: 1  Here is a look at the resulting PopData metadatagenodata There are two things that should jump out at you: The name of offspring are prepended with generation and the population is the generation.There is a never-before-seen parents column. This column exists for better record keeping of who has what parents if you are performing multiple crosses. julia&gt; f1.sampleinfo 100000√ó6 DataFrame ‚îÇ Row ‚îÇ name ‚îÇ ploidy ‚îÇ population ‚îÇ parents ‚îÇ ‚îÇ ‚îÇ String ‚îÇ Int8 ‚îÇ String ‚îÇ Tuple‚Ä¶ ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ 1 ‚îÇ F1_offspring_1 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 2 ‚îÇ F1_offspring_2 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 3 ‚îÇ F1_offspring_3 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 4 ‚îÇ F1_offspring_4 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 5 ‚îÇ F1_offspring_5 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚ãÆ ‚îÇ 99995 ‚îÇ F1_offspring_99995 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 99996 ‚îÇ F1_offspring_99996 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 99997 ‚îÇ F1_offspring_99997 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 99998 ‚îÇ F1_offspring_99998 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 99999 ‚îÇ F1_offspring_99999 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ ‚îÇ 100000 ‚îÇ F1_offspring_100000 ‚îÇ 2 ‚îÇ F1 ‚îÇ (&quot;N111&quot;, &quot;N107&quot;) ‚îÇ  "},{"title":"Perform a cross/backcross‚Äã","type":1,"pageTitle":"Simulate Breeding Crosses","url":"/PopGen.jl/docs/simulations/breedingcrosses#perform-a-crossbackcross","content":"cross(PopData =&gt; &quot;Parent1Name&quot;, PopData =&gt; &quot;Parent2Name&quot;, n::Int, generation::String)  This syntax uses the Pair notation of PopData =&gt; &quot;Parent&quot; to specify inputs. This method can be used for performing a cross like above, with the flexibility of parents allowed from two different PopData objects, which makes backcrosses possible. The keyword argument n is the number of offspring to produce, and generation is a keyword argument for the population name to the assign the offspring (default: &quot;F1&quot;). Example‚Äã julia&gt; f2_backcross = cross(cats =&gt; &quot;N111&quot;, f1 =&gt; &quot;F1_offspring_99&quot;, n = 100000, generation = &quot;F2_manycats&quot;) PopData{Diploid, 9 Microsatellite loci} Samples: 100000 Populations: 1  And here you can see that generation was again prepended to each offspring name, along with assigned to the population for each. julia&gt; f2_backcross.sampleinfo 100000√ó6 DataFrame ‚îÇ Row ‚îÇ name ‚îÇ ploidy ‚îÇ population ‚îÇ parents ‚îÇ ‚îÇ ‚îÇ String ‚îÇ Int8 ‚îÇ String ‚îÇ Tuple{String,String} ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ 1 ‚îÇ F2_manycats_offspring_1 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 2 ‚îÇ F2_manycats_offspring_2 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 3 ‚îÇ F2_manycats_offspring_3 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 4 ‚îÇ F2_manycats_offspring_4 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 5 ‚îÇ F2_manycats_offspring_5 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚ãÆ ‚îÇ 99995 ‚îÇ F2_manycats_offspring_99995 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 99996 ‚îÇ F2_manycats_offspring_99996 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 99997 ‚îÇ F2_manycats_offspring_99997 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 99998 ‚îÇ F2_manycats_offspring_99998 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 99999 ‚îÇ F2_manycats_offspring_99999 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ ‚îÇ 100000 ‚îÇ F2_manycats_offspring_100000 ‚îÇ 2 ‚îÇ F2_manycats ‚îÇ (&quot;N111&quot;, &quot;F1_offspring_99&quot;) ‚îÇ  caution When crossing parents from different PopData, the parents must have the same loci. You will see error messages if they don't. "},{"title":"Merge results‚Äã","type":1,"pageTitle":"Simulate Breeding Crosses","url":"/PopGen.jl/docs/simulations/breedingcrosses#merge-results","content":"The PopData generated from breeding crosses can be combined used append or append! append(::PopData, ::PopData) append!(::PopData, ::PopData)  These methods use outer joins and the PopData you are combining must have the same loci. Example‚Äã # non mutating crossed_sims = append(f1, f2_backcross) # mutating append!(f1, f2_backcross)  "}]