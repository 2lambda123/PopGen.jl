using BenchmarkTools, DataFrames, CSV

function csv2(infile::String; delim::Union{Nothing,String} = nothing, marker::String = "snp")
    if lowercase(marker) == "snp"
        geno_type = Int8
    else
        geno_type = Int16
    end

    # read in CSV
    if delim == nothing
        x = CSV.read(infile, header = 1, copycols = true, type = String)
    else
        x = CSV.read(infile, delim = delim, header = 1, copycols = true, type = String)
    end

    # pull out loci
    y = select(x, Not(:1,:2,:3,:4))

    # pull out sample meta
    select!(x, [:1,:2,:3,:4])
    rename!(x, [:name, :population, :longitude, :latitude])
    x.name = String.(x.name)
    x.population = String.(x.population)

    @info "\n$(abspath(infile))
$(size(x,1)) samples detected
$(length(unique(x.population))) populations detected
$(size(y,2))) loci detected"

    x.longitude = map(x.longitude) do val
        floatval = parse(Float64, val)
        if iszero(floatval) == true
            return missing
        else
            return floatval
        end
    end |> Vector{Union{Missing, Float64}}

    x.latitude = map(x.latitude) do val
        floatval = parse(Float64, val)
        if iszero(floatval) == true
            return missing
        else
            return floatval
        end
    end |> Vector{Union{Missing, Float64}}

    # phase the locus genotypes
    z = map(eachcol(y)) do locus
        phase.(locus, geno_type, 3)
    end |> DataFrame
    rename!(z, names(y))

    ## ploidy finding
    ploidy = Vector{Int8}()

    @inbounds for i in 1:length(x.name)
        @inbounds for j in eachcol(z)
            j[i] === missing && continue   # if missing, go to next locus
            push!(ploidy, length(j[i]))   # if not, get ploidy and push to vector
            break   # break out of the loop and begin next sample
        end
    end

    insertcols!(x, 3, :ploidy => ploidy)

    return PopObj(x, z)

end



# 10.158 ms (46945 allocations: 2.61 MiB)
# 11.996 ms (60588 allocations: 3.21 MiB)
